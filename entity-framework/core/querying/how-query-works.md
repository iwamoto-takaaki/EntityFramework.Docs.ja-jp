---
title: クエリのしくみ - EF Core
author: rowanmiller
ms.date: 09/26/2018
ms.assetid: de2e34cd-659b-4cab-b5ed-7a979c6bf120
uid: core/querying/how-query-works
ms.openlocfilehash: ba0d68469530e6272ffbb51946d7856122a261c7
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2020
ms.locfileid: "78413739"
---
# <a name="how-queries-work"></a>クエリのしくみ

Entity Framework Core では統合言語クエリ (LINQ) を使用し、データベースにデータを問い合わせます。 LINQ では C# (あるいは自分で選んだ .NET 言語) を使用し、派生コンテキストとエンティティ クラスに基づいて、厳密に型指定されたクエリを記述できます。

## <a name="the-life-of-a-query"></a>クエリの全体像

各クエリが通過するプロセスの高次元での概要を次に示します。

1. LINQ クエリは、データベース プロバイダーで処理するために用意された表現をビルドするために、Entity Framework Core によって処理されます。
   1. クエリが実行されるたびにこの処理が実行される必要がないように、結果はキャッシュされます。
2. 結果が、データベース プロバイダーに渡されます。
   1. データベース プロバイダーは、クエリのどの部分がデータベースで評価できるかを識別します。
   2. クエリのこれらの部分は、データベース固有のクエリ言語 (リレーショナル データベースの SQL など) に変換されます。
   3. 1 つまたは複数のクエリがデータべースに送信され、結果セットが返されます (結果は、エンティティ インスタンスではなく、データベースからの値です)。
3. 結果セット内の各項目で、
   1. これが追跡クエリの場合、EF では、データがコンテキスト インスタンスの変更追跡に既にあるエンティティを表しているかどうかをチェックします。
      * 既にある場合、既存のエンティティが返されます。
      * ない場合、新しいエンティティが作成され、変更追跡が設定されて、新しいエンティティが返されます。
   2. これが追跡なしのクエリの場合、EF では、データがこのクエリの結果セットに既にあるエンティティを表しているかどうかをチェックします。
      * 既にある場合、既存のエンティティが返されます<sup>(1)</sup>。
      * ない場合、新しいエンティティが作成されて、返されます。

<sup>(1)</sup> 既に返されたエンティティの追跡を継続するために、追跡なしクエリでは弱参照が使用されます。 同じ ID の前の結果が範囲外になっている場合は、ガベージ コレクションが実行され、新しいエンティティ インスタンスを取得できます。

## <a name="when-queries-are-executed"></a>クエリの実行時

LINQ 演算子を呼び出すと、単純にクエリのメモリ内表現がビルドされます。 クエリは、結果が使用されるときにデータベースに送信されるだけです。

クエリでの結果がデータベースに送信される最も一般的な操作は、次のとおりです。

* `for` ループ内で結果を反復処理する
* `ToList`、`ToArray`、`Single`、`Count` などの演算子を使用する
* クエリの結果を UI にデータバインドする

> [!WARNING]  
> **ユーザー入力を常に検証する:** クエリでパラメーターを使用し、リテラルをエスケープすることで、EF Core によって SQL インジェクション攻撃から保護されていますが、入力は検証されません。 信頼されていないソースの値が LINQ クエリで使用されたり、エンティティ プロパティに割り当てられたり、他の EF Core API に渡される前に、アプリケーションの要件ごとに適切な検証を実行する必要があります。 これには、動的にクエリを構築する際に使用されるユーザー入力も含まれます。 LINQ を使用している場合であっても、式をビルドするためのユーザー入力を許可しているなら、目的の式だけは構築できることを確認する必要があります。
