---
title: クライアントとサーバーの評価 - EF Core
description: Entity Framework Core を使用した、クライアントおよびサーバーでのクエリの評価
author: smitpatel
ms.date: 11/09/2020
uid: core/querying/client-eval
ms.openlocfilehash: a1ddfb625be36cb05f01da08eb3be29512c54ab5
ms.sourcegitcommit: f3512e3a98e685a3ba409c1d0157ce85cc390cf4
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/10/2020
ms.locfileid: "94430145"
---
# <a name="client-vs-server-evaluation"></a><span data-ttu-id="7f985-103">クライアントとサーバーの評価</span><span class="sxs-lookup"><span data-stu-id="7f985-103">Client vs. Server Evaluation</span></span>

<span data-ttu-id="7f985-104">一般に、Entity Framework Core では、可能な限りサーバーでのクエリの評価を試みます。</span><span class="sxs-lookup"><span data-stu-id="7f985-104">As a general rule, Entity Framework Core attempts to evaluate a query on the server as much as possible.</span></span> <span data-ttu-id="7f985-105">EF Core ではクエリの一部をパラメーターに変換し、クライアント側で評価することができます。</span><span class="sxs-lookup"><span data-stu-id="7f985-105">EF Core converts parts of the query into parameters, which it can evaluate on the client side.</span></span> <span data-ttu-id="7f985-106">クエリの残りの部分 (生成されたパラメーターを含む) は、データベース プロバイダーに与えられ、サーバー上で評価する同等のデータベース クエリが判別されます。</span><span class="sxs-lookup"><span data-stu-id="7f985-106">The rest of the query (along with the generated parameters) is given to the database provider to determine the equivalent database query to evaluate on the server.</span></span> <span data-ttu-id="7f985-107">EF Core では、最上位レベルのプロジェクション (基本的には、`Select()` への最後の呼び出し) で部分的なクライアント評価がサポートされています。</span><span class="sxs-lookup"><span data-stu-id="7f985-107">EF Core supports partial client evaluation in the top-level projection (essentially, the last call to `Select()`).</span></span> <span data-ttu-id="7f985-108">クエリの最上位レベルのプロジェクションをサーバーに変換できない場合、EF Core ではサーバーから必要なデータをフェッチし、クライアントでクエリの残りの部分を評価します。</span><span class="sxs-lookup"><span data-stu-id="7f985-108">If the top-level projection in the query can't be translated to the server, EF Core will fetch any required data from the server and evaluate remaining parts of the query on the client.</span></span> <span data-ttu-id="7f985-109">EF Core では、サーバーに変換できない最上位レベルのプロジェクション以外の場所で式が検出された場合、ランタイム例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="7f985-109">If EF Core detects an expression, in any place other than the top-level projection, which can't be translated to the server, then it throws a runtime exception.</span></span> <span data-ttu-id="7f985-110">EF Core でサーバーに変換できないものを判別する方法については、[クエリのしくみ](xref:core/querying/how-query-works)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="7f985-110">See [How queries work](xref:core/querying/how-query-works) to understand how EF Core determines what can't be translated to server.</span></span>

> [!NOTE]
> <span data-ttu-id="7f985-111">バージョン 3.0 より前では、Entity Framework Core で、クエリ内の任意の場所でのクライアント評価がサポートされていました。</span><span class="sxs-lookup"><span data-stu-id="7f985-111">Prior to version 3.0, Entity Framework Core supported client evaluation anywhere in the query.</span></span> <span data-ttu-id="7f985-112">詳細については、[以前のバージョンに関するセクション](#previous-versions)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7f985-112">For more information, see the [previous versions section](#previous-versions).</span></span>

> [!TIP]
> <span data-ttu-id="7f985-113">この記事の[サンプル](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/ClientEvaluation)は GitHub で確認できます。</span><span class="sxs-lookup"><span data-stu-id="7f985-113">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying/ClientEvaluation) on GitHub.</span></span>

## <a name="client-evaluation-in-the-top-level-projection"></a><span data-ttu-id="7f985-114">最上位レベルのプロジェクションでのクライアント評価</span><span class="sxs-lookup"><span data-stu-id="7f985-114">Client evaluation in the top-level projection</span></span>

<span data-ttu-id="7f985-115">次の例では、SQL Server データベースから返される、ブログの URL を標準化するために、ヘルパー メソッドが使用されています。</span><span class="sxs-lookup"><span data-stu-id="7f985-115">In the following example, a helper method is used to standardize URLs for blogs, which are returned from a SQL Server database.</span></span> <span data-ttu-id="7f985-116">SQL Server プロバイダーではこのメソッドの実装方法が把握されないため、SQL に変換することはできません。</span><span class="sxs-lookup"><span data-stu-id="7f985-116">Since the SQL Server provider has no insight into how this method is implemented, it isn't possible to translate it into SQL.</span></span> <span data-ttu-id="7f985-117">クエリの他の側面はすべてデータベースで評価されますが、このメソッド経由で返された `URL` の受け渡しはクライアント上で行われます。</span><span class="sxs-lookup"><span data-stu-id="7f985-117">All other aspects of the query are evaluated in the database, but passing the returned `URL` through this method is done on the client.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEvaluation/Program.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/ClientEvaluation/Program.cs#ClientMethod)]

## <a name="unsupported-client-evaluation"></a><span data-ttu-id="7f985-118">サポートされていないクライアント評価</span><span class="sxs-lookup"><span data-stu-id="7f985-118">Unsupported client evaluation</span></span>

<span data-ttu-id="7f985-119">クライアント評価は便利ですが、パフォーマンスが低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7f985-119">While client evaluation is useful, it can result in poor performance sometimes.</span></span> <span data-ttu-id="7f985-120">次のクエリについて考えてみます。ここでは、ヘルパー メソッドが where フィルターで使用されています。</span><span class="sxs-lookup"><span data-stu-id="7f985-120">Consider the following query, in which the helper method is now used in a where filter.</span></span> <span data-ttu-id="7f985-121">フィルターはデータベースで適用できないため、クライアントにフィルターを適用するには、すべてのデータをメモリに取り込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="7f985-121">Because the filter can't be applied in the database, all the data needs to be pulled into memory to apply the filter on the client.</span></span> <span data-ttu-id="7f985-122">フィルターとサーバー上のデータの量に基づいて、クライアント評価でパフォーマンスが低下する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7f985-122">Based on the filter and the amount of data on the server, client evaluation could result in poor performance.</span></span> <span data-ttu-id="7f985-123">そのため、Entity Framework Core ではこのようなクライアント評価をブロックし、ランタイム例外をスローします。</span><span class="sxs-lookup"><span data-stu-id="7f985-123">So Entity Framework Core blocks such client evaluation and throws a runtime exception.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEvaluation/Program.cs#ClientWhere)]

## <a name="explicit-client-evaluation"></a><span data-ttu-id="7f985-124">明示的なクライアント評価</span><span class="sxs-lookup"><span data-stu-id="7f985-124">Explicit client evaluation</span></span>

<span data-ttu-id="7f985-125">次のような特定のケースでは、クライアント評価を明示的に強制することが必要な場合があります</span><span class="sxs-lookup"><span data-stu-id="7f985-125">You may need to force into client evaluation explicitly in certain cases like following</span></span>

- <span data-ttu-id="7f985-126">データの量が少ないため、クライアントでの評価によってパフォーマンスが大幅に低下することがない。</span><span class="sxs-lookup"><span data-stu-id="7f985-126">The amount of data is small so that evaluating on the client doesn't incur a huge performance penalty.</span></span>
- <span data-ttu-id="7f985-127">使用されている LINQ 演算子がサーバー側で変換されない。</span><span class="sxs-lookup"><span data-stu-id="7f985-127">The LINQ operator being used has no server-side translation.</span></span>

<span data-ttu-id="7f985-128">このような場合は、`AsEnumerable` または `ToList` (非同期の場合は `AsAsyncEnumerable` または `ToListAsync`) のようなメソッドを呼び出すことにより、クライアント評価を明示的に選択することができます。</span><span class="sxs-lookup"><span data-stu-id="7f985-128">In such cases, you can explicitly opt into client evaluation by calling methods like `AsEnumerable` or `ToList` (`AsAsyncEnumerable` or `ToListAsync` for async).</span></span> <span data-ttu-id="7f985-129">`AsEnumerable` を使用すると、結果をストリーミングすることになりますが、`ToList` を使用すると、リストを作成することによってバッファリングが発生し、追加のメモリも必要になります。</span><span class="sxs-lookup"><span data-stu-id="7f985-129">By using `AsEnumerable` you would be streaming the results, but using `ToList` would cause buffering by creating a list, which also takes additional memory.</span></span> <span data-ttu-id="7f985-130">複数回列挙する場合でも、データベースに対するクエリは 1 つのみであるため、結果をリストに格納するのがより有効です。</span><span class="sxs-lookup"><span data-stu-id="7f985-130">Though if you're enumerating multiple times, then storing results in a list helps more since there's only one query to the database.</span></span> <span data-ttu-id="7f985-131">特定の使用方法に応じて、ケースにより有効なメソッドを評価する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7f985-131">Depending on the particular usage, you should evaluate which method is more useful for the case.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEvaluation/Program.cs#ExplicitClientEvaluation)]

> [!TIP]
> <span data-ttu-id="7f985-132">`AsAsyncEnumerable` を使用していて、さらにクライアント側でクエリを作成する場合は、async 列挙体の演算子を定義する [System.Interactive.Async](https://www.nuget.org/packages/System.Interactive.Async/) ライブラリを使用できます。</span><span class="sxs-lookup"><span data-stu-id="7f985-132">If you are using `AsAsyncEnumerable` and want to compose the query further on client side then you can use [System.Interactive.Async](https://www.nuget.org/packages/System.Interactive.Async/) library which defines operators for async enumerables.</span></span> <span data-ttu-id="7f985-133">詳細については、[クライアント側の linq 演算子](xref:core/miscellaneous/async#client-side-async-linq-operators)に関するページをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="7f985-133">For more information, see [client side linq operators](xref:core/miscellaneous/async#client-side-async-linq-operators).</span></span>

## <a name="potential-memory-leak-in-client-evaluation"></a><span data-ttu-id="7f985-134">クライアント評価での潜在的なメモリ リーク</span><span class="sxs-lookup"><span data-stu-id="7f985-134">Potential memory leak in client evaluation</span></span>

<span data-ttu-id="7f985-135">クエリの変換とコンパイルにはコストがかかるため、EF Core ではコンパイル済みのクエリ プランをキャッシュします。</span><span class="sxs-lookup"><span data-stu-id="7f985-135">Since query translation and compilation are expensive, EF Core caches the compiled query plan.</span></span> <span data-ttu-id="7f985-136">キャッシュされたデリゲートでは、最上位レベルのプロジェクションのクライアント評価を行うときに、クライアント コードを使用する場合があります。</span><span class="sxs-lookup"><span data-stu-id="7f985-136">The cached delegate may use client code while doing client evaluation of top-level projection.</span></span> <span data-ttu-id="7f985-137">EF Core では、クライアントによって評価されるツリーの部分のパラメーターが生成され、パラメーター値を置き換えることによってクエリ プランが再利用されます。</span><span class="sxs-lookup"><span data-stu-id="7f985-137">EF Core generates parameters for the client-evaluated parts of the tree and reuses the query plan by replacing the parameter values.</span></span> <span data-ttu-id="7f985-138">しかし、式ツリー内の特定の定数をパラメーターに変換することはできません。</span><span class="sxs-lookup"><span data-stu-id="7f985-138">But certain constants in the expression tree can't be converted into parameters.</span></span> <span data-ttu-id="7f985-139">キャッシュされたデリゲートにこのような定数が含まれている場合、それらのオブジェクトは、まだ参照されているため、ガベージ コレクションを行うことはできません。</span><span class="sxs-lookup"><span data-stu-id="7f985-139">If the cached delegate contains such constants, then those objects can't be garbage collected since they're still being referenced.</span></span> <span data-ttu-id="7f985-140">このようなオブジェクトに DbContext またはその他のサービスが含まれている場合、アプリのメモリ使用量が時間の経過と共に増加する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="7f985-140">If such an object contains a DbContext or other services in it, then it could cause the memory usage of the app to grow over time.</span></span> <span data-ttu-id="7f985-141">通常、この動作はメモリ リークの兆候です。</span><span class="sxs-lookup"><span data-stu-id="7f985-141">This behavior is generally a sign of a memory leak.</span></span> <span data-ttu-id="7f985-142">現在のデータベース プロバイダーを使用してマップできない型の定数が見つかるたびに、EF Core で例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="7f985-142">EF Core throws an exception whenever it comes across constants of a type that can't be mapped using current database provider.</span></span> <span data-ttu-id="7f985-143">一般的な原因とその解決策は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="7f985-143">Common causes and their solutions are as follows:</span></span>

- <span data-ttu-id="7f985-144">**インスタンス メソッドを使用する**:クライアント プロジェクションでインスタンス メソッドを使用する場合、式ツリーにはインスタンスの定数が含まれます。</span><span class="sxs-lookup"><span data-stu-id="7f985-144">**Using an instance method**: When using instance methods in a client projection, the expression tree contains a constant of the instance.</span></span> <span data-ttu-id="7f985-145">メソッドでインスタンスのデータを使用しない場合は、メソッドを静的にすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="7f985-145">If your method doesn't use any data from the instance, consider making the method static.</span></span> <span data-ttu-id="7f985-146">メソッド本体にインスタンス データが必要な場合は、特定のデータを引数としてメソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="7f985-146">If you need instance data in the method body, then pass the specific data as an argument to the method.</span></span>
- <span data-ttu-id="7f985-147">**定数引数をメソッドに渡す**:このケースは通常、クライアント メソッドに対する引数で `this` を使用することで発生します。</span><span class="sxs-lookup"><span data-stu-id="7f985-147">**Passing constant arguments to method**: This case arises generally by using `this` in an argument to client method.</span></span> <span data-ttu-id="7f985-148">引数を複数のスカラー引数に分割することを検討してください。これは、データベース プロバイダーでマップできます。</span><span class="sxs-lookup"><span data-stu-id="7f985-148">Consider splitting the argument in to multiple scalar arguments, which can be mapped by the database provider.</span></span>
- <span data-ttu-id="7f985-149">**その他の定数**:その他のケースで定数が見つかった場合は、定数が処理で必要かどうかを評価できます。</span><span class="sxs-lookup"><span data-stu-id="7f985-149">**Other constants**: If a constant is come across in any other case, then you can evaluate whether the constant is needed in processing.</span></span> <span data-ttu-id="7f985-150">定数を指定する必要がある場合、または上記のケースの解決策を使用できない場合は、値を格納するローカル変数を作成し、クエリでローカル変数を使用します。</span><span class="sxs-lookup"><span data-stu-id="7f985-150">If it's necessary to have the constant, or if you can't use a solution from the above cases, then create a local variable to store the value and use local variable in the query.</span></span> <span data-ttu-id="7f985-151">EF Core では、ローカル変数をパラメーターに変換します。</span><span class="sxs-lookup"><span data-stu-id="7f985-151">EF Core will convert the local variable into a parameter.</span></span>

## <a name="previous-versions"></a><span data-ttu-id="7f985-152">以前のバージョン</span><span class="sxs-lookup"><span data-stu-id="7f985-152">Previous versions</span></span>

<span data-ttu-id="7f985-153">次のセクションは、3.0 より前のバージョンの EF Core に適用されます。</span><span class="sxs-lookup"><span data-stu-id="7f985-153">The following section applies to EF Core versions before 3.0.</span></span>

<span data-ttu-id="7f985-154">以前の EF Core バージョンでは、最上位レベルのプロジェクションだけでなく、クエリのどの部分でもクライアント評価がサポートされていました。</span><span class="sxs-lookup"><span data-stu-id="7f985-154">Older EF Core versions supported client evaluation in any part of the query--not just the top-level projection.</span></span> <span data-ttu-id="7f985-155">そのため、[サポートされていないクライアント評価](#unsupported-client-evaluation)に関するセクションで示されているものと同様のクエリが正常に動作していました。</span><span class="sxs-lookup"><span data-stu-id="7f985-155">That's why queries similar to one posted under the [Unsupported client evaluation](#unsupported-client-evaluation) section worked correctly.</span></span> <span data-ttu-id="7f985-156">この動作によってパフォーマンスの問題が発生する可能性があるため、EF Core ではクライアント評価の警告がログに記録されていました。</span><span class="sxs-lookup"><span data-stu-id="7f985-156">Since this behavior could cause unnoticed performance issues, EF Core logged a client evaluation warning.</span></span> <span data-ttu-id="7f985-157">ログ記録出力の表示について詳しくは、「[ログの記録](xref:core/logging-events-diagnostics/index)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="7f985-157">For more information on viewing logging output, see [Logging](xref:core/logging-events-diagnostics/index).</span></span>

<span data-ttu-id="7f985-158">必要に応じて、EF Core では既定の動作を変更し、クライアントの評価を行うときに例外をスローするか、何も実行しないようにすることができました (プロジェクションの場合を除く)。</span><span class="sxs-lookup"><span data-stu-id="7f985-158">Optionally EF Core allowed you to change the default behavior to either throw an exception or do nothing when doing client evaluation (except for in the projection).</span></span> <span data-ttu-id="7f985-159">例外をスローする動作は、3.0 の動作と似たようなものになります。</span><span class="sxs-lookup"><span data-stu-id="7f985-159">The exception throwing behavior would make it similar to the behavior in 3.0.</span></span> <span data-ttu-id="7f985-160">動作を変更するには、(通常は `DbContext.OnConfiguring` で、または ASP.NET Core を使用している場合は `Startup.cs` で) コンテキストのオプションを設定するときに警告を構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="7f985-160">To change the behavior, you need to configure warnings while setting up the options for your context - typically in `DbContext.OnConfiguring`, or in `Startup.cs` if you're using ASP.NET Core.</span></span>

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=EFQuerying;Trusted_Connection=True;")
        .ConfigureWarnings(warnings => warnings.Throw(RelationalEventId.QueryClientEvaluationWarning));
}
```
