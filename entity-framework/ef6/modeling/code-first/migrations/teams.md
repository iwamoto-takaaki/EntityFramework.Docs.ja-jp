---
title: チーム環境での Code First Migrations-EF6
description: Entity Framework 6 のチーム環境での Code First Migrations
author: ajcvickers
ms.date: 10/23/2016
uid: ef6/modeling/code-first/migrations/teams
ms.openlocfilehash: c617dc3c34e829585b21766c7738bd622890b286
ms.sourcegitcommit: 0a25c03fa65ae6e0e0e3f66bac48d59eceb96a5a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/14/2020
ms.locfileid: "92065083"
---
# <a name="code-first-migrations-in-team-environments"></a>チーム環境での Code First Migrations
> [!NOTE]
> この記事では、基本的なシナリオでの Code First Migrations の使用方法を理解していることを前提としています。 そうでない場合は、続行する前に [Code First Migrations](xref:ef6/modeling/code-first/migrations/index) を読む必要があります。

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a>コーヒーを入手するには、記事全体を読む必要があります

チーム環境の問題は、2人の開発者がローカルコードベースで移行を生成した場合の移行の主な部分です。 これらを解決する手順は非常に単純ですが、移行のしくみについて十分に理解している必要があります。 最後までスキップしないでください。記事全体を読んで、成功したことを確認してください。

## <a name="some-general-guidelines"></a>いくつかの一般的なガイドライン

複数の開発者によって生成されたマージ移行を管理する方法について詳しく説明する前に、成功を収めるために設定するための一般的なガイドラインをいくつか紹介します。

### <a name="each-team-member-should-have-a-local-development-database"></a>各チームメンバーには、ローカル開発データベースが必要です

移行では、 ** \_ \_ MigrationsHistory**テーブルを使用して、データベースに適用されている移行を格納します。 複数の開発者が同じデータベースを対象にしている間に異なる移行を生成している場合 (つまり、 ** \_ \_ MigrationsHistory**テーブルを共有する場合)、移行は混乱を招きます。

もちろん、移行を生成していないチームメンバーがいる場合は、中央開発データベースを共有することには問題ありません。

### <a name="avoid-automatic-migrations"></a>自動移行を回避する

最後の行は、チーム環境での自動移行は最初は良好ですが、実際には機能しません。 その理由を知りたい場合は、まだ読んでいない場合は、次のセクションに進むことができます。

自動移行を使用すると、コードファイル (コードベースの移行) を生成することなく、現在のモデルと一致するようにデータベーススキーマを更新することができます。 自動移行はチーム環境で非常に適しています。これを使用しただけで、コードベースの移行を生成したことはありません。 問題は、自動移行が制限され、いくつかの操作 (プロパティ/列の名前変更、別のテーブルへのデータの移動など) を処理しないことです。これらのシナリオを処理するために、自動移行によって処理される変更の間に混在するコードベースの移行 (およびスキャフォールディングコードの編集) が生成されます。 これにより、2人の開発者が移行をチェックインするときに、変更をマージできなくなります。

## <a name="screencasts"></a>キャスト

この記事で説明しているスクリーンキャストをご覧になりたい場合は、次の2つのビデオでこの記事と同じ内容をご確認ください。

### <a name="video-one-migrations---under-the-hood"></a>ビデオ 1: "移行-内部"

[このスクリーンキャスト](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) では、モデルの変更を検出するために、移行によってモデルに関する情報を追跡および使用する方法について説明します。

### <a name="video-two-migrations---team-environments"></a>ビデオ 2: 「移行-チーム環境」

[このスクリーンキャスト](https://channel9.msdn.com/blogs/ef/migrations-team-environments)では、前のビデオの概念を基に、チーム環境で発生する問題とその解決方法について説明します。

## <a name="understanding-how-migrations-works"></a>移行のしくみについて

チーム環境で移行を正常に使用するための鍵は、モデルの変更を検出するために、移行がモデルに関する情報を追跡して使用する方法を理解することです。

### <a name="the-first-migration"></a>最初の移行

プロジェクトに最初の移行を追加すると、まず、パッケージマネージャーコンソールで、 **追加の移行** などを実行します。 このコマンドが実行する大まかな手順を次に示します。

![最初の移行](~/ef6/media/firstmigration.png)

現在のモデルは、コード (1) から計算されます。 次に、必要なデータベースオブジェクトがモデルによって計算されます (2)。これは最初の移行であるため、モデルが異なるのは、比較に空のモデルを使用することだけです。 必要な変更がコードジェネレーターに渡され、必要な移行コード (3) が作成され、Visual Studio ソリューション (4) に追加されます。

メインコードファイルに格納されている実際の移行コードに加えて、移行によって追加の分離コードファイルも生成されます。 これらのファイルは、移行によって使用されるメタデータであり、編集する必要があるものではありません。 これらのファイルの1つは、移行が生成された時点のモデルのスナップショットを含むリソースファイル (.resx) です。 その方法については、次の手順で説明します。

この時点で、データベースに変更を適用するために **更新データベース** を実行し、アプリケーションの他の領域の実装について説明します。

### <a name="subsequent-migrations"></a>後続の移行

後で、モデルに何らかの変更を加えます。この例では、**ブログ**に**Url**プロパティを追加します。 次に、スキャフォールディングを移行するために、 **追加移行 AddUrl** などのコマンドを発行して、対応するデータベースの変更を適用します。 このコマンドが実行する大まかな手順を次に示します。

![2番目の移行](~/ef6/media/secondmigration.png)

前回と同じように、現在のモデルはコード (1) から計算されます。 ただし、今回は既存の移行があるため、以前のモデルは最新の移行から取得されます (2)。 この2つのモデルは、必要なデータベース変更 (3) を検出して、プロセスが前と同じように完了するようになっています。

この同じプロセスは、プロジェクトに追加するその他の移行でも使用されます。

### <a name="why-bother-with-the-model-snapshot"></a>モデルスナップショットを使用する理由

EF 面倒がモデルスナップショットと共に使用されている理由は、データベースを見るだけではないでしょうか。 その場合は、「」を参照してください。 関心がない場合は、このセクションを省略できます。

EF では、次のようなさまざまな理由でモデルスナップショットが保持されます。

-   これにより、データベースは EF モデルから逸脱することができます。 これらの変更はデータベースで直接行うことができます。また、移行のスキャフォールディングコードを変更して変更を加えることもできます。 実際の例を次に示します。
    -   挿入および更新された列を1つ以上のテーブルに追加しようとしていますが、これらの列を EF モデルに含める必要はありません。 移行がデータベースで見られた場合は、移行をスキャフォールディングするたびに、これらの列を常に削除しようとします。 EF では、モデルスナップショットを使用した場合にのみ、モデルに対する正当な変更が検出されます。
    -   更新に使用するストアドプロシージャの本文を変更して、いくつかのログ記録を含むようにします。 データベースからこのストアドプロシージャを参照している場合は、常に、EF が想定している定義にリセットされます。 Ef モデルでは、ef モデルのプロシージャの構造を変更するときに、モデルスナップショットを使用することによって、ストアドプロシージャを変更するコードをスキャフォールディングするだけで済みます。
    -   これらの同じ原則は、データベース内の余分なテーブルを含む追加のインデックスの追加、テーブルに配置されているデータベースビューへの EF のマッピングなどに適用されます。
-   EF モデルには、データベースの構造を超えるものが含まれています。 モデル全体を使用すると、モデル内のプロパティとクラスに関する情報と、それらが列とテーブルにどのようにマップされるかを確認できます。 この情報によって、スキャフォールディングしたコードで移行をよりインテリジェントにすることができます。 たとえば、プロパティがマップされている列の名前を変更すると、その名前が同じプロパティであることを確認することによって名前変更を検出できます。これは、データベーススキーマしかない場合には実行できません。 

## <a name="what-causes-issues-in-team-environments"></a>チーム環境での問題の原因

前のセクションで説明したワークフローは、1人の開発者がアプリケーションを操作する場合に適しています。 また、モデルに変更を加える唯一のユーザーであれば、チーム環境でも適切に機能します。 このシナリオでは、モデルの変更を行い、移行を生成して、ソース管理に送信できます。 他の開発者は、変更を同期し、 **更新データベース** を実行してスキーマ変更を適用することができます。

複数の開発者が EF モデルに変更を加え、同時にソース管理に送信すると、問題が発生し始めます。 EF に欠けているのは、最後に同期した後に別の開発者がソース管理に送信した移行を使用して、ローカル移行をマージするための最初の方法です。

## <a name="an-example-of-a-merge-conflict"></a>マージの競合の例

まず、このようなマージの競合の具体的な例を見てみましょう。 前に見た例について説明します。 出発点として、前のセクションの変更が元の開発者によってチェックインされたものとします。 コードベースに変更を加えると、2つの開発者が追跡されます。

EF モデルと移行については、さまざまな変更を通じて追跡します。 開始点として、次の図に示すように、両方の開発者がソース管理リポジトリに同期しています。

![開始ポイント](~/ef6/media/startingpoint.png)

Developer \# 1 と developer \# 2 では、ローカルコードベースで EF モデルにいくつかの変更が加えられるようになりました。 Developer \# 1 は、 **評価** プロパティを **ブログ** に追加し、変更をデータベースに適用するための **addrating** 移行を生成します。 Developer \# 2 は、**ブログ**に**閲覧**者プロパティを追加し、対応する**addreaders**移行を生成します。 どちらの開発者も、 **更新データベース**を実行し、変更をローカルデータベースに適用して、アプリケーションの開発を続けます。

> [!NOTE]
> 移行にはタイムスタンプが付けられているため、Developer 2 からの AddReaders の移行は Developer 1 からの追加評価の後に行われることを示して \# \# います。 Developer \# 1 または \# 2 が最初に移行を生成したかどうかによって、チームでの作業に関する問題や、次のセクションで説明するようにマージするプロセスの違いはありません。

![ローカルの変更](~/ef6/media/localchanges.png)

開発者 \# 1 が最初に変更を送信するときには、運が良ければさいわいです。 リポジトリを同期した後に他のユーザーがチェックインしていないため、マージを実行せずに変更を送信するだけで済みます。

![変更の送信](~/ef6/media/submit.png)

これで、Developer \# 2 が送信されます。 幸運なことではありません。 他のユーザーが同期後に変更を送信したため、変更を取得してマージする必要があります。 ソース管理システムは、非常に単純であるため、変更をコードレベルで自動的にマージできる可能性があります。 同期後の Developer \# 2 のローカルリポジトリの状態を次の図に示します。 

![ソース管理からのプル](~/ef6/media/pull.png)

この段階で、Developer \# 2 は、新しい**addrating**移行 (Developer 2 のデータベースには適用されていません) を検出して適用する**更新データベース**を実行でき \# ます。 これで、[ **評価** ] 列が [ **ブログ** ] テーブルに追加され、データベースがモデルと同期されます。

ただし、いくつかの問題があります。

1.  **更新データベース**は**addrating**の移行を適用しますが、警告が発生します。*保留中の変更があり、自動移行が無効になっているため、現在のモデルと一致するようにデータベースを更新できません*...
    問題は、最後の移行 (**Addreader**) に格納されているモデルスナップショットに、**ブログ**の**評価**プロパティ (移行が生成されたときにモデルに含まれていなかったため) がないことです。 Code First は、前回の移行でモデルが現在のモデルと一致しないことを検出し、警告を発生させます。
2.  アプリケーションを実行すると、*データベースの作成後に "BInvalidOperationException context" コンテキストをサポートするモデルが変更されたことを示す、"" という結果が返されます。Code First Migrations を使用してデータベースを更新することを検討*してください... "
    ここでも、前回の移行で格納されているモデルスナップショットが現在のモデルと一致しないという問題があります。
3.  最後に、[ **追加の移行** ] を実行すると、(データベースに適用する変更がないため) 空の移行が生成されることが予想されます。 ただし、移行によって現在のモデルが前回の移行と比較されるため (**評価**プロパティがない)、**評価**列に追加する別の**addcolumn**呼び出しが実際にスキャフォールディングます。 もちろん、**評価**列が既に存在しているため、この移行は**更新データベース**中に失敗します。

## <a name="resolving-the-merge-conflict"></a>マージの競合を解決する

移行がどのように機能するかについて理解していれば、マージを手動で処理するのは困難です。 では、このセクションにスキップしています。 申し訳ありません。先に戻って、記事の残りの部分を読む必要があります。

2つのオプションがありますが、最も簡単なのは、スナップショットとして正しい現在のモデルを持つ空の移行を生成することです。 2つ目の方法は、最後の移行でスナップショットを更新して、正しいモデルスナップショットを作成することです。 2番目のオプションは少し難しく、すべてのシナリオで使用することはできませんが、追加の移行を追加する必要がないため、クリーナーもすっきりしています。

### <a name="option-1-add-a-blank-merge-migration"></a>オプション 1: 空の ' マージ ' 移行を追加する

このオプションでは、最新の移行に適切なモデルスナップショットが格納されていることを確認するためだけに、空の移行が生成されます。

このオプションは、最後に移行を行ったユーザーに関係なく使用できます。 この例では、開発者2に従ってマージを行い、 \# 最後の移行を生成しました。 ただし、Developer \# 1 が最後の移行を生成した場合は、これらの同じ手順を使用できます。 この手順は、複数の移行が関係している場合にも適用されます。単純にするために、2つを見てきました。

次のプロセスは、ソース管理から同期する必要がある変更があることがわかった時点から、この方法で使用できます。

1.  ローカルコードベースで保留中のモデルの変更が移行に書き込まれていることを確認します。 この手順により、空の移行を生成するときに、正当な変更が漏れないようにすることができます。
2.  ソース管理と同期します。
3.  他の開発者がチェックインした新しい移行を適用するには、 **Update-Database** を実行します。
    **_注:_** *Update-Database コマンドから警告が表示されない場合は、他の開発者からの新しい移行はありませんでした。さらにマージを実行する必要はありません。*
4.  [追加の移行] を実行して ** &lt; \_ \_ 名前を &gt; 選択** します (たとえば、[移行の追加]、[ **ignorechanges 適用]** など)。 これにより、すべてのメタデータ (現在のモデルのスナップショットを含む) との移行が生成されますが、現在のモデルを最後の移行のスナップショットと比較するときに検出されるすべての変更が無視されます (つまり、空の **Up** および **Down** メソッドを取得します)。
5.  **更新プログラムデータベース**を実行し、最新の移行を更新されたメタデータで再適用します。
6.  開発を続行するか、(コースの単体テストを実行した後で) ソース管理に送信します。

\#この方法を使用した後の Developer 2 のローカルコードベースの状態を次に示します。

![マージ移行](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a>オプション 2: 前回の移行でモデルスナップショットを更新する

このオプションはオプション1とよく似ていますが、ソリューションに余分なコードファイルを必要としているため、余分な空白の移行は削除されます。

**この方法は、最新の移行がローカルコードベースにのみ存在し、ソース管理にまだ送信されていない場合にのみ実行できます (たとえば、最後の移行がマージを行ったユーザーによって生成された場合など)**。 他の開発者によって開発データベースに既に適用されている可能性がある移行のメタデータを編集したり、実稼働データベースに適用したりすると、予期しない副作用が発生する可能性があります。 このプロセスでは、ローカルデータベースの最後の移行をロールバックし、更新されたメタデータを使用して再適用します。

最後の移行はローカルコードベースでのみ必要ですが、続行する移行の数や順序に制限はありません。 複数の異なる開発者から複数の移行を行うことができ、同じ手順が適用されます。単純にするために、2つを見ているだけです。

次のプロセスは、ソース管理から同期する必要がある変更があることがわかった時点から、この方法で使用できます。

1.  ローカルコードベースで保留中のモデルの変更が移行に書き込まれていることを確認します。 この手順により、空の移行を生成するときに、正当な変更が漏れないようにすることができます。
2.  ソース管理と同期します。
3.  他の開発者がチェックインした新しい移行を適用するには、 **Update-Database** を実行します。
    **_注:_** *Update-Database コマンドから警告が表示されない場合は、他の開発者からの新しい移行はありませんでした。さらにマージを実行する必要はありません。*
4.  **更新プログラムデータベースを実行する– targetmigration &lt; second \_ 最後の \_ 移行 &gt; ** (この例では、**更新データベース– targetmigration addrating**)。 これにより、データベースが最後に最後に移行されたときの状態にロールバックされます。最後にデータベースからの移行を実際に "適用解除" します。
    **_注:_** *この手順は、メタデータも \_ \_ データベースの MigrationsHistoryTable に格納されるため、移行のメタデータの編集を安全に行うために必要です。このため、最後の移行がローカルコードベースのみである場合にのみ、このオプションを使用する必要があります。他のデータベースに最後に移行が適用されている場合は、ロールバックして、最後の移行を再適用してメタデータを更新する必要もあります。* 
5.  ** &lt; \_ \_ \_ \_ \_ 最後の \_ 移行のタイムスタンプを含む、追加移行の完全な名前**を実行 &gt; します (この後の例では、**追加移行 201311062215252 \_ addreaders**のようになります)。
    **_注:_** *新しい移行をスキャフォールディングするのではなく、既存の移行を編集することを移行が認識できるように、タイムスタンプを含める必要があります。*
    これにより、現在のモデルに一致するように、最後の移行のメタデータが更新されます。 コマンドが完了すると、次の警告が表示されますが、これはまさに必要なことです。 "*移行 ' 201311062215252 addreaders ' のデザイナーコードのみ \_ が再スキャフォールディングされました。移行全体を再スキャフォールディングするには、-Force パラメーターを使用します。*
6.  **更新プログラムデータベース**を実行し、最新の移行を更新されたメタデータで再適用します。
7.  開発を続行するか、(コースの単体テストを実行した後で) ソース管理に送信します。

\#この方法を使用した後の Developer 2 のローカルコードベースの状態を次に示します。

![更新されたメタデータ](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a>まとめ

チーム環境で Code First Migrations を使用する場合、いくつかの課題があります。 ただし、移行のしくみ、およびマージの競合を解決するための簡単な方法についての理解を深めることで、これらの課題を簡単に克服できます。

基本的な問題は、最新の移行に格納されている不適切なメタデータです。 これにより、Code First は、現在のモデルとデータベーススキーマが一致しないことを誤って検出し、次の移行で誤ったコードをスキャフォールディングします。 この状況は、正しいモデルを使用して空の移行を生成したり、最新の移行でメタデータを更新したりすることによって克服できます。
