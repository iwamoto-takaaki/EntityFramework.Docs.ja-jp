---
title: チーム環境での Code First Migrations-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
ms.openlocfilehash: 46c22c997b8db53bb381d0b528c65733f1766849
ms.sourcegitcommit: 387cbd8109c0fc5ce6bdc85d0dec1aed72ad4c33
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2020
ms.locfileid: "82103166"
---
# <a name="code-first-migrations-in-team-environments"></a><span data-ttu-id="23210-102">チーム環境での Code First Migrations</span><span class="sxs-lookup"><span data-stu-id="23210-102">Code First Migrations in Team Environments</span></span>
> [!NOTE]
> <span data-ttu-id="23210-103">この記事では、基本的なシナリオでの Code First Migrations の使用方法を理解していることを前提としています。</span><span class="sxs-lookup"><span data-stu-id="23210-103">This article assumes you know how to use Code First Migrations in basic scenarios.</span></span> <span data-ttu-id="23210-104">そうでない場合は、続行する前に[Code First Migrations](~/ef6/modeling/code-first/migrations/index.md)を読む必要があります。</span><span class="sxs-lookup"><span data-stu-id="23210-104">If you don’t, then you’ll need to read [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) before continuing.</span></span>

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a><span data-ttu-id="23210-105">コーヒーを入手するには、記事全体を読む必要があります</span><span class="sxs-lookup"><span data-stu-id="23210-105">Grab a coffee, you need to read this whole article</span></span>

<span data-ttu-id="23210-106">チーム環境の問題は、2人の開発者がローカルコードベースで移行を生成した場合の移行の主な部分です。</span><span class="sxs-lookup"><span data-stu-id="23210-106">The issues in team environments are mostly around merging migrations when two developers have generated migrations in their local code base.</span></span> <span data-ttu-id="23210-107">これらを解決する手順は非常に単純ですが、移行のしくみについて十分に理解している必要があります。</span><span class="sxs-lookup"><span data-stu-id="23210-107">While the steps to solve these are pretty simple, they require you to have a solid understanding of how migrations works.</span></span> <span data-ttu-id="23210-108">最後までスキップしないでください。記事全体を読んで、成功したことを確認してください。</span><span class="sxs-lookup"><span data-stu-id="23210-108">Please don’t just skip ahead to the end – take the time to read the whole article to ensure you are successful.</span></span>

## <a name="some-general-guidelines"></a><span data-ttu-id="23210-109">いくつかの一般的なガイドライン</span><span class="sxs-lookup"><span data-stu-id="23210-109">Some general guidelines</span></span>

<span data-ttu-id="23210-110">複数の開発者によって生成されたマージ移行を管理する方法について詳しく説明する前に、成功を収めるために設定するための一般的なガイドラインをいくつか紹介します。</span><span class="sxs-lookup"><span data-stu-id="23210-110">Before we dig into how to manage merging migrations generated by multiple developers, here are some general guidelines to set you up for success.</span></span>

### <a name="each-team-member-should-have-a-local-development-database"></a><span data-ttu-id="23210-111">各チームメンバーには、ローカル開発データベースが必要です</span><span class="sxs-lookup"><span data-stu-id="23210-111">Each team member should have a local development database</span></span>

<span data-ttu-id="23210-112">移行では、 \*\* \_ \_MigrationsHistory\*\*テーブルを使用して、データベースに適用されている移行を格納します。</span><span class="sxs-lookup"><span data-stu-id="23210-112">Migrations uses the **\_\_MigrationsHistory** table to store what migrations have been applied to the database.</span></span> <span data-ttu-id="23210-113">複数の開発者が同じデータベースを対象にしている間に異なる移行を生成している場合 (つまり、 \*\* \_ \_MigrationsHistory\*\*テーブルを共有する場合)、移行は混乱を招きます。</span><span class="sxs-lookup"><span data-stu-id="23210-113">If you have multiple developers generating different migrations while trying to target the same database (and thus share a **\_\_MigrationsHistory** table) migrations is going to get very confused.</span></span>

<span data-ttu-id="23210-114">もちろん、移行を生成していないチームメンバーがいる場合は、中央開発データベースを共有することには問題ありません。</span><span class="sxs-lookup"><span data-stu-id="23210-114">Of course, if you have team members that aren’t generating migrations, there is no problem having them share a central development database.</span></span>

### <a name="avoid-automatic-migrations"></a><span data-ttu-id="23210-115">自動移行を回避する</span><span class="sxs-lookup"><span data-stu-id="23210-115">Avoid automatic migrations</span></span>

<span data-ttu-id="23210-116">最後の行は、チーム環境での自動移行は最初は良好ですが、実際には機能しません。</span><span class="sxs-lookup"><span data-stu-id="23210-116">The bottom line is that automatic migrations initially look good in team environments, but in reality they just don’t work.</span></span> <span data-ttu-id="23210-117">その理由を知りたい場合は、まだ読んでいない場合は、次のセクションに進むことができます。</span><span class="sxs-lookup"><span data-stu-id="23210-117">If you want to know why, keep reading – if not, then you can skip to the next section.</span></span>

<span data-ttu-id="23210-118">自動移行を使用すると、コードファイル (コードベースの移行) を生成することなく、現在のモデルと一致するようにデータベーススキーマを更新することができます。</span><span class="sxs-lookup"><span data-stu-id="23210-118">Automatic migrations allows you to have your database schema updated to match the current model without the need to generate code files (code-based migrations).</span></span> <span data-ttu-id="23210-119">自動移行はチーム環境で非常に適しています。これを使用しただけで、コードベースの移行を生成したことはありません。</span><span class="sxs-lookup"><span data-stu-id="23210-119">Automatic migrations would work very well in a team environment if you only ever used them and never generated any code-based migrations.</span></span> <span data-ttu-id="23210-120">問題は、自動移行が制限され、いくつかの操作 (プロパティ/列の名前変更、別のテーブルへのデータの移動など) を処理しないことです。これらのシナリオを処理するために、自動移行によって処理される変更の間に混在するコードベースの移行 (およびスキャフォールディングコードの編集) が生成されます。</span><span class="sxs-lookup"><span data-stu-id="23210-120">The problem is that automatic migrations are limited and don’t handle a number of operations – property/column renames, moving data to another table, etc. To handle these scenarios you end up generating code-based migrations (and editing the scaffolded code) that are mixed in between changes that are handled by automatic migrations.</span></span> <span data-ttu-id="23210-121">これにより、2人の開発者が移行をチェックインするときに、変更をマージできなくなります。</span><span class="sxs-lookup"><span data-stu-id="23210-121">This makes it near on impossible to merge changes when two developers check in migrations.</span></span>

## <a name="screencasts"></a><span data-ttu-id="23210-122">キャスト</span><span class="sxs-lookup"><span data-stu-id="23210-122">Screencasts</span></span>

<span data-ttu-id="23210-123">この記事で説明しているスクリーンキャストをご覧になりたい場合は、次の2つのビデオでこの記事と同じ内容をご確認ください。</span><span class="sxs-lookup"><span data-stu-id="23210-123">If you'd rather watch a screencast than read this article, the following two videos cover the same content as this article.</span></span>

### <a name="video-one-migrations---under-the-hood"></a><span data-ttu-id="23210-124">ビデオ 1: "移行-内部"</span><span class="sxs-lookup"><span data-stu-id="23210-124">Video One: "Migrations - Under the Hood"</span></span>

<span data-ttu-id="23210-125">[このスクリーンキャスト](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood)では、モデルの変更を検出するために、移行によってモデルに関する情報を追跡および使用する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="23210-125">[This screencast](https://channel9.msdn.com/blogs/ef/migrations-under-the-hood) covers how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="video-two-migrations---team-environments"></a><span data-ttu-id="23210-126">ビデオ 2: 「移行-チーム環境」</span><span class="sxs-lookup"><span data-stu-id="23210-126">Video Two: "Migrations - Team Environments"</span></span>

<span data-ttu-id="23210-127">[このスクリーンキャスト](https://channel9.msdn.com/blogs/ef/migrations-team-environments)では、前のビデオの概念を基に、チーム環境で発生する問題とその解決方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="23210-127">Building on the concepts from the previous video, [this screencast](https://channel9.msdn.com/blogs/ef/migrations-team-environments) covers the issues that arise in a team environment and how to solve them.</span></span>

## <a name="understanding-how-migrations-works"></a><span data-ttu-id="23210-128">移行のしくみについて</span><span class="sxs-lookup"><span data-stu-id="23210-128">Understanding how migrations works</span></span>

<span data-ttu-id="23210-129">チーム環境で移行を正常に使用するための鍵は、モデルの変更を検出するために、移行がモデルに関する情報を追跡して使用する方法を理解することです。</span><span class="sxs-lookup"><span data-stu-id="23210-129">The key to successfully using migrations in a team environment is a basic understanding how migrations tracks and uses information about the model to detect model changes.</span></span>

### <a name="the-first-migration"></a><span data-ttu-id="23210-130">最初の移行</span><span class="sxs-lookup"><span data-stu-id="23210-130">The first migration</span></span>

<span data-ttu-id="23210-131">プロジェクトに最初の移行を追加すると、まず、パッケージマネージャーコンソールで、**追加の移行**などを実行します。</span><span class="sxs-lookup"><span data-stu-id="23210-131">When you add the first migration to your project, you run something like **Add-Migration First** in Package Manager Console.</span></span> <span data-ttu-id="23210-132">このコマンドが実行する大まかな手順を次に示します。</span><span class="sxs-lookup"><span data-stu-id="23210-132">The high level steps that this command performs are pictured below.</span></span>

![最初の移行](~/ef6/media/firstmigration.png)

<span data-ttu-id="23210-134">現在のモデルは、コード (1) から計算されます。</span><span class="sxs-lookup"><span data-stu-id="23210-134">The current model is calculated from your code (1).</span></span> <span data-ttu-id="23210-135">次に、必要なデータベースオブジェクトがモデルによって計算されます (2)。これは最初の移行であるため、モデルが異なるのは、比較に空のモデルを使用することだけです。</span><span class="sxs-lookup"><span data-stu-id="23210-135">The required database objects are then calculated by the model differ (2) – since this is the first migration the model differ just uses an empty model for the comparison.</span></span> <span data-ttu-id="23210-136">必要な変更がコードジェネレーターに渡され、必要な移行コード (3) が作成され、Visual Studio ソリューション (4) に追加されます。</span><span class="sxs-lookup"><span data-stu-id="23210-136">The required changes are passed to the code generator to build the required migration code (3) which is then added to your Visual Studio solution (4).</span></span>

<span data-ttu-id="23210-137">メインコードファイルに格納されている実際の移行コードに加えて、移行によって追加の分離コードファイルも生成されます。</span><span class="sxs-lookup"><span data-stu-id="23210-137">In addition to the actual migration code that is stored in the main code file, migrations also generates some additional code-behind files.</span></span> <span data-ttu-id="23210-138">これらのファイルは、移行によって使用されるメタデータであり、編集する必要があるものではありません。</span><span class="sxs-lookup"><span data-stu-id="23210-138">These files are metadata that is used by migrations and are not something you should edit.</span></span> <span data-ttu-id="23210-139">これらのファイルの1つは、移行が生成された時点のモデルのスナップショットを含むリソースファイル (.resx) です。</span><span class="sxs-lookup"><span data-stu-id="23210-139">One of these files is a resource file (.resx) that contains a snapshot of the model at the time the migration was generated.</span></span> <span data-ttu-id="23210-140">その方法については、次の手順で説明します。</span><span class="sxs-lookup"><span data-stu-id="23210-140">You’ll see how this is used in the next step.</span></span>

<span data-ttu-id="23210-141">この時点で、データベースに変更を適用するために**更新データベース**を実行し、アプリケーションの他の領域の実装について説明します。</span><span class="sxs-lookup"><span data-stu-id="23210-141">At this point you would probably run **Update-Database** to apply your changes to the database, and then go about implementing other areas of your application.</span></span>

### <a name="subsequent-migrations"></a><span data-ttu-id="23210-142">後続の移行</span><span class="sxs-lookup"><span data-stu-id="23210-142">Subsequent migrations</span></span>

<span data-ttu-id="23210-143">後で、モデルに何らかの変更を加えます。この例では、**ブログ**に**Url**プロパティを追加します。</span><span class="sxs-lookup"><span data-stu-id="23210-143">Later you come back and make some changes to your model – in our example we’ll add a **Url** property to **Blog**.</span></span> <span data-ttu-id="23210-144">次に、スキャフォールディングを移行するために、**追加移行 AddUrl**などのコマンドを発行して、対応するデータベースの変更を適用します。</span><span class="sxs-lookup"><span data-stu-id="23210-144">You would then issue a command such as **Add-Migration AddUrl** to scaffold a migration to apply the corresponding database changes.</span></span> <span data-ttu-id="23210-145">このコマンドが実行する大まかな手順を次に示します。</span><span class="sxs-lookup"><span data-stu-id="23210-145">The high level steps that this command performs are pictured below.</span></span>

![2番目の移行](~/ef6/media/secondmigration.png)

<span data-ttu-id="23210-147">前回と同じように、現在のモデルはコード (1) から計算されます。</span><span class="sxs-lookup"><span data-stu-id="23210-147">Just like last time, the current model is calculated from code (1).</span></span> <span data-ttu-id="23210-148">ただし、今回は既存の移行があるため、以前のモデルは最新の移行から取得されます (2)。</span><span class="sxs-lookup"><span data-stu-id="23210-148">However, this time there are existing migrations so the previous model is retrieved from the latest migration (2).</span></span> <span data-ttu-id="23210-149">この2つのモデルは、必要なデータベース変更 (3) を検出して、プロセスが前と同じように完了するようになっています。</span><span class="sxs-lookup"><span data-stu-id="23210-149">These two models are diffed to find the required database changes (3) and then the process completes as before.</span></span>

<span data-ttu-id="23210-150">この同じプロセスは、プロジェクトに追加するその他の移行でも使用されます。</span><span class="sxs-lookup"><span data-stu-id="23210-150">This same process is used for any further migrations that you add to the project.</span></span>

### <a name="why-bother-with-the-model-snapshot"></a><span data-ttu-id="23210-151">モデルスナップショットを使用する理由</span><span class="sxs-lookup"><span data-stu-id="23210-151">Why bother with the model snapshot?</span></span>

<span data-ttu-id="23210-152">EF 面倒がモデルスナップショットと共に使用されている理由は、データベースを見るだけではないでしょうか。</span><span class="sxs-lookup"><span data-stu-id="23210-152">You may be wondering why EF bothers with the model snapshot – why not just look at the database.</span></span> <span data-ttu-id="23210-153">その場合は、「」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="23210-153">If so, read on.</span></span> <span data-ttu-id="23210-154">関心がない場合は、このセクションを省略できます。</span><span class="sxs-lookup"><span data-stu-id="23210-154">If you’re not interested then you can skip this section.</span></span>

<span data-ttu-id="23210-155">EF では、次のようなさまざまな理由でモデルスナップショットが保持されます。</span><span class="sxs-lookup"><span data-stu-id="23210-155">There are a number of reasons EF keeps the model snapshot around:</span></span>

-   <span data-ttu-id="23210-156">これにより、データベースは EF モデルから逸脱することができます。</span><span class="sxs-lookup"><span data-stu-id="23210-156">It allows your database to drift from the EF model.</span></span> <span data-ttu-id="23210-157">これらの変更はデータベースで直接行うことができます。また、移行のスキャフォールディングコードを変更して変更を加えることもできます。</span><span class="sxs-lookup"><span data-stu-id="23210-157">These changes can be made directly in the database, or you can change the scaffolded code in your migrations to make the changes.</span></span> <span data-ttu-id="23210-158">実際の例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="23210-158">Here are a couple of examples of this in practice:</span></span>
    -   <span data-ttu-id="23210-159">挿入および更新された列を1つ以上のテーブルに追加しようとしていますが、これらの列を EF モデルに含める必要はありません。</span><span class="sxs-lookup"><span data-stu-id="23210-159">You want to add an Inserted and Updated to column to one or more of your tables but you don’t want to include these columns in the EF model.</span></span> <span data-ttu-id="23210-160">移行がデータベースで見られた場合は、移行をスキャフォールディングするたびに、これらの列を常に削除しようとします。</span><span class="sxs-lookup"><span data-stu-id="23210-160">If migrations looked at the database it would continually try to drop these columns every time you scaffolded a migration.</span></span> <span data-ttu-id="23210-161">EF では、モデルスナップショットを使用した場合にのみ、モデルに対する正当な変更が検出されます。</span><span class="sxs-lookup"><span data-stu-id="23210-161">Using the model snapshot, EF will only ever detect legitimate changes to the model.</span></span>
    -   <span data-ttu-id="23210-162">更新に使用するストアドプロシージャの本文を変更して、いくつかのログ記録を含むようにします。</span><span class="sxs-lookup"><span data-stu-id="23210-162">You want to change the body of a stored procedure used for updates to include some logging.</span></span> <span data-ttu-id="23210-163">データベースからこのストアドプロシージャを参照している場合は、常に、EF が想定している定義にリセットされます。</span><span class="sxs-lookup"><span data-stu-id="23210-163">If migrations looked at this stored procedure from the database it would continually try and reset it back to the definition that EF expects.</span></span> <span data-ttu-id="23210-164">Ef モデルでは、ef モデルのプロシージャの構造を変更するときに、モデルスナップショットを使用することによって、ストアドプロシージャを変更するコードをスキャフォールディングするだけで済みます。</span><span class="sxs-lookup"><span data-stu-id="23210-164">By using the model snapshot, EF will only ever scaffold code to alter the stored procedure when you change the shape of the procedure in the EF model.</span></span>
    -   <span data-ttu-id="23210-165">これらの同じ原則は、データベース内の余分なテーブルを含む追加のインデックスの追加、テーブルに配置されているデータベースビューへの EF のマッピングなどに適用されます。</span><span class="sxs-lookup"><span data-stu-id="23210-165">These same principles apply to adding extra indexes, including extra tables in your database, mapping EF to a database view that sits over a table, etc.</span></span>
-   <span data-ttu-id="23210-166">EF モデルには、データベースの構造を超えるものが含まれています。</span><span class="sxs-lookup"><span data-stu-id="23210-166">The EF model contains more than just the shape of the database.</span></span> <span data-ttu-id="23210-167">モデル全体を使用すると、モデル内のプロパティとクラスに関する情報と、それらが列とテーブルにどのようにマップされるかを確認できます。</span><span class="sxs-lookup"><span data-stu-id="23210-167">Having the entire model allows migrations to look at information about the properties and classes in your model and how they map to the columns and tables.</span></span> <span data-ttu-id="23210-168">この情報によって、スキャフォールディングしたコードで移行をよりインテリジェントにすることができます。</span><span class="sxs-lookup"><span data-stu-id="23210-168">This information allows migrations to be more intelligent in the code that it scaffolds.</span></span> <span data-ttu-id="23210-169">たとえば、プロパティがマップされている列の名前を変更すると、その名前が同じプロパティであることを確認することによって名前変更を検出できます。これは、データベーススキーマしかない場合には実行できません。</span><span class="sxs-lookup"><span data-stu-id="23210-169">For example, if you change the name of the column that a property maps to migrations can detect the rename by seeing that it’s the same property – something that can’t be done if you only have the database schema.</span></span> 

## <a name="what-causes-issues-in-team-environments"></a><span data-ttu-id="23210-170">チーム環境での問題の原因</span><span class="sxs-lookup"><span data-stu-id="23210-170">What causes issues in team environments</span></span>

<span data-ttu-id="23210-171">前のセクションで説明したワークフローは、1人の開発者がアプリケーションを操作する場合に適しています。</span><span class="sxs-lookup"><span data-stu-id="23210-171">The workflow covered in the previous section works great when you are a single developer working on an application.</span></span> <span data-ttu-id="23210-172">また、モデルに変更を加える唯一のユーザーであれば、チーム環境でも適切に機能します。</span><span class="sxs-lookup"><span data-stu-id="23210-172">It also works well in a team environment if you are the only person making changes to the model.</span></span> <span data-ttu-id="23210-173">このシナリオでは、モデルの変更を行い、移行を生成して、ソース管理に送信できます。</span><span class="sxs-lookup"><span data-stu-id="23210-173">In this scenario you can make model changes, generate migrations and submit them to your source control.</span></span> <span data-ttu-id="23210-174">他の開発者は、変更を同期し、**更新データベース**を実行してスキーマ変更を適用することができます。</span><span class="sxs-lookup"><span data-stu-id="23210-174">Other developers can sync your changes and run **Update-Database** to have the schema changes applied.</span></span>

<span data-ttu-id="23210-175">複数の開発者が EF モデルに変更を加え、同時にソース管理に送信すると、問題が発生し始めます。</span><span class="sxs-lookup"><span data-stu-id="23210-175">Issues start to arise when you have multiple developers making changes to the EF model and submitting to source control at the same time.</span></span> <span data-ttu-id="23210-176">EF に欠けているのは、最後に同期した後に別の開発者がソース管理に送信した移行を使用して、ローカル移行をマージするための最初の方法です。</span><span class="sxs-lookup"><span data-stu-id="23210-176">What EF lacks is a first class way to merge your local migrations with migrations that another developer has submitted to source control since you last synced.</span></span>

## <a name="an-example-of-a-merge-conflict"></a><span data-ttu-id="23210-177">マージの競合の例</span><span class="sxs-lookup"><span data-stu-id="23210-177">An example of a merge conflict</span></span>

<span data-ttu-id="23210-178">まず、このようなマージの競合の具体的な例を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="23210-178">First let’s look at a concrete example of such a merge conflict.</span></span> <span data-ttu-id="23210-179">前に見た例について説明します。</span><span class="sxs-lookup"><span data-stu-id="23210-179">We’ll continue on with the example we looked at earlier.</span></span> <span data-ttu-id="23210-180">出発点として、前のセクションの変更が元の開発者によってチェックインされたものとします。</span><span class="sxs-lookup"><span data-stu-id="23210-180">As a starting point let’s assume the changes from the previous section were checked in by the original developer.</span></span> <span data-ttu-id="23210-181">コードベースに変更を加えると、2つの開発者が追跡されます。</span><span class="sxs-lookup"><span data-stu-id="23210-181">We’ll track two developers as they make changes to code base.</span></span>

<span data-ttu-id="23210-182">EF モデルと移行については、さまざまな変更を通じて追跡します。</span><span class="sxs-lookup"><span data-stu-id="23210-182">We’ll track the EF model and the migrations thru a number of changes.</span></span> <span data-ttu-id="23210-183">開始点として、次の図に示すように、両方の開発者がソース管理リポジトリに同期しています。</span><span class="sxs-lookup"><span data-stu-id="23210-183">For a starting point, both developers have synced to the source control repository, as depicted in the following graphic.</span></span>

![開始ポイント](~/ef6/media/startingpoint.png)

<span data-ttu-id="23210-185">Developer \#1 と developer \#2 では、ローカルコードベースで EF モデルにいくつかの変更が加えられるようになりました。</span><span class="sxs-lookup"><span data-stu-id="23210-185">Developer \#1 and developer \#2 now makes some changes to the EF model in their local code base.</span></span> <span data-ttu-id="23210-186">Developer \#1 は、**評価**プロパティを**ブログ**に追加し、変更をデータベースに適用するための**addrating**移行を生成します。</span><span class="sxs-lookup"><span data-stu-id="23210-186">Developer \#1 adds a **Rating** property to **Blog** – and generates an **AddRating** migration to apply the changes to the database.</span></span> <span data-ttu-id="23210-187">Developer \#2 は、**ブログ**に**閲覧**者プロパティを追加し、対応する**addreaders**移行を生成します。</span><span class="sxs-lookup"><span data-stu-id="23210-187">Developer \#2 adds a **Readers** property to **Blog** – and generates the corresponding **AddReaders** migration.</span></span> <span data-ttu-id="23210-188">どちらの開発者も、**更新データベース**を実行し、変更をローカルデータベースに適用して、アプリケーションの開発を続けます。</span><span class="sxs-lookup"><span data-stu-id="23210-188">Both developers run **Update-Database**, to apply the changes to their local databases, and then continue developing the application.</span></span>

> [!NOTE]
> <span data-ttu-id="23210-189">移行にはタイムスタンプが付けられているため、Developer \#2 からの addreaders の移行は developer \#1 からの追加評価の後に行われることを示しています。</span><span class="sxs-lookup"><span data-stu-id="23210-189">Migrations are prefixed with a timestamp, so our graphic represents that the AddReaders migration from Developer \#2 comes after the AddRating migration from Developer \#1.</span></span> <span data-ttu-id="23210-190">Developer \#1 または\#2 が最初に移行を生成したかどうかによって、チームでの作業に関する問題や、次のセクションで説明するようにマージするプロセスの違いはありません。</span><span class="sxs-lookup"><span data-stu-id="23210-190">Whether developer \#1 or \#2 generated the migration first makes no difference to the issues of working in a team, or the process for merging them that we’ll look at in the next section.</span></span>

![ローカルの変更](~/ef6/media/localchanges.png)

<span data-ttu-id="23210-192">開発者\#1 が最初に変更を送信するときには、運が良ければさいわいです。</span><span class="sxs-lookup"><span data-stu-id="23210-192">It’s a lucky day for Developer \#1 as they happen to submit their changes first.</span></span> <span data-ttu-id="23210-193">リポジトリを同期した後に他のユーザーがチェックインしていないため、マージを実行せずに変更を送信するだけで済みます。</span><span class="sxs-lookup"><span data-stu-id="23210-193">Because no one else has checked in since they synced their repository, they can just submit their changes without performing any merging.</span></span>

![[送信]](~/ef6/media/submit.png)

<span data-ttu-id="23210-195">これで、Developer \#2 が送信されます。</span><span class="sxs-lookup"><span data-stu-id="23210-195">Now it’s time for Developer \#2 to submit.</span></span> <span data-ttu-id="23210-196">幸運なことではありません。</span><span class="sxs-lookup"><span data-stu-id="23210-196">They aren’t so lucky.</span></span> <span data-ttu-id="23210-197">他のユーザーが同期後に変更を送信したため、変更を取得してマージする必要があります。</span><span class="sxs-lookup"><span data-stu-id="23210-197">Because someone else has submitted changes since they synced, they will need to pull down the changes and merge.</span></span> <span data-ttu-id="23210-198">ソース管理システムは、非常に単純であるため、変更をコードレベルで自動的にマージできる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="23210-198">The source control system will likely be able to automatically merge the changes at the code level since they are very simple.</span></span> <span data-ttu-id="23210-199">同期後の Developer \#2 のローカルリポジトリの状態を次の図に示します。</span><span class="sxs-lookup"><span data-stu-id="23210-199">The state of Developer \#2’s local repository after syncing is depicted in the following graphic.</span></span> 

![プル](~/ef6/media/pull.png)

<span data-ttu-id="23210-201">この段階で、 \#developer 2 は、新しい**addrating**移行 (Developer \#2 のデータベースには適用されていません) を検出して適用する**更新データベース**を実行できます。</span><span class="sxs-lookup"><span data-stu-id="23210-201">At this stage Developer \#2 can run **Update-Database** which will detect the new **AddRating** migration (which hasn’t been applied to Developer \#2’s database) and apply it.</span></span> <span data-ttu-id="23210-202">これで、[**評価**] 列が [**ブログ**] テーブルに追加され、データベースがモデルと同期されます。</span><span class="sxs-lookup"><span data-stu-id="23210-202">Now the **Rating** column is added to the **Blogs** table and the database is in sync with the model.</span></span>

<span data-ttu-id="23210-203">ただし、いくつかの問題があります。</span><span class="sxs-lookup"><span data-stu-id="23210-203">There are a couple of problems though:</span></span>

1.  <span data-ttu-id="23210-204">**更新データベース**は**addrating**の移行を適用しますが、警告が発生します。*保留中の変更があり、自動移行が無効になっているため、現在のモデルと一致するようにデータベースを更新できません*...</span><span class="sxs-lookup"><span data-stu-id="23210-204">Although **Update-Database** will apply the **AddRating** migration it will also raise a warning: *Unable to update database to match the current model because there are pending changes and automatic migration is disabled…*</span></span>
    <span data-ttu-id="23210-205">問題は、最後の移行 (**Addreader**) に格納されているモデルスナップショットに、**ブログ**の**評価**プロパティ (移行が生成されたときにモデルに含まれていなかったため) がないことです。</span><span class="sxs-lookup"><span data-stu-id="23210-205">The problem is that the model snapshot stored in the last migration (**AddReader**) is missing the **Rating** property on **Blog** (since it wasn’t part of the model when the migration was generated).</span></span> <span data-ttu-id="23210-206">Code First は、前回の移行でモデルが現在のモデルと一致しないことを検出し、警告を発生させます。</span><span class="sxs-lookup"><span data-stu-id="23210-206">Code First detects that the model in the last migration doesn’t match the current model and raises the warning.</span></span>
2.  <span data-ttu-id="23210-207">アプリケーションを実行すると、*データベースの作成後に "BInvalidOperationException context" コンテキストをサポートするモデルが変更されたことを示す、"" という結果が返されます。Code First Migrations を使用してデータベースを更新することを検討*してください... "</span><span class="sxs-lookup"><span data-stu-id="23210-207">Running the application would result in an InvalidOperationException stating that “*The model backing the 'BloggingContext' context has changed since the database was created. Consider using Code First Migrations to update the database…”*</span></span>
    <span data-ttu-id="23210-208">ここでも、前回の移行で格納されているモデルスナップショットが現在のモデルと一致しないという問題があります。</span><span class="sxs-lookup"><span data-stu-id="23210-208">Again, the problem is the model snapshot stored in the last migration doesn’t match the current model.</span></span>
3.  <span data-ttu-id="23210-209">最後に、[**追加の移行**] を実行すると、(データベースに適用する変更がないため) 空の移行が生成されることが予想されます。</span><span class="sxs-lookup"><span data-stu-id="23210-209">Finally, we would expect running **Add-Migration** now would generate an empty migration (since there are no changes to apply to the database).</span></span> <span data-ttu-id="23210-210">ただし、移行によって現在のモデルが前回の移行と比較されるため (**評価**プロパティがない)、**評価**列に追加する別の**addcolumn**呼び出しが実際にスキャフォールディングます。</span><span class="sxs-lookup"><span data-stu-id="23210-210">But because migrations compares the current model to the one from the last migration (which is missing the **Rating** property) it will actually scaffold another **AddColumn** call to add in the **Rating** column.</span></span> <span data-ttu-id="23210-211">もちろん、**評価**列が既に存在しているため、この移行は**更新データベース**中に失敗します。</span><span class="sxs-lookup"><span data-stu-id="23210-211">Of course, this migration would fail during **Update-Database** because the **Rating** column already exists.</span></span>

## <a name="resolving-the-merge-conflict"></a><span data-ttu-id="23210-212">マージの競合を解決する</span><span class="sxs-lookup"><span data-stu-id="23210-212">Resolving the merge conflict</span></span>

<span data-ttu-id="23210-213">移行がどのように機能するかについて理解していれば、マージを手動で処理するのは困難です。</span><span class="sxs-lookup"><span data-stu-id="23210-213">The good news is that it’s not too hard to deal with the merge manually – provided you have an understanding of how migrations works.</span></span> <span data-ttu-id="23210-214">では、このセクションにスキップしています。</span><span class="sxs-lookup"><span data-stu-id="23210-214">So if you’ve skipped ahead to this section…</span></span> <span data-ttu-id="23210-215">申し訳ありません。先に戻って、記事の残りの部分を読む必要があります。</span><span class="sxs-lookup"><span data-stu-id="23210-215">sorry, you need to go back and read the rest of the article first!</span></span>

<span data-ttu-id="23210-216">2つのオプションがありますが、最も簡単なのは、スナップショットとして正しい現在のモデルを持つ空の移行を生成することです。</span><span class="sxs-lookup"><span data-stu-id="23210-216">There are two options, the easiest is to generate a blank migration that has the correct current model as a snapshot.</span></span> <span data-ttu-id="23210-217">2つ目の方法は、最後の移行でスナップショットを更新して、正しいモデルスナップショットを作成することです。</span><span class="sxs-lookup"><span data-stu-id="23210-217">The second option is to update the snapshot in the last migration to have the correct model snapshot.</span></span> <span data-ttu-id="23210-218">2番目のオプションは少し難しく、すべてのシナリオで使用することはできませんが、追加の移行を追加する必要がないため、クリーナーもすっきりしています。</span><span class="sxs-lookup"><span data-stu-id="23210-218">The second option is a little harder and can’t be used in every scenario, but it’s also cleaner because it doesn’t involve adding an extra migration.</span></span>

### <a name="option-1-add-a-blank-merge-migration"></a><span data-ttu-id="23210-219">オプション 1: 空の ' マージ ' 移行を追加する</span><span class="sxs-lookup"><span data-stu-id="23210-219">Option 1: Add a blank ‘merge’ migration</span></span>

<span data-ttu-id="23210-220">このオプションでは、最新の移行に適切なモデルスナップショットが格納されていることを確認するためだけに、空の移行が生成されます。</span><span class="sxs-lookup"><span data-stu-id="23210-220">In this option we generate a blank migration solely for the purpose of making sure the latest migration has the correct model snapshot stored in it.</span></span>

<span data-ttu-id="23210-221">このオプションは、最後に移行を行ったユーザーに関係なく使用できます。</span><span class="sxs-lookup"><span data-stu-id="23210-221">This option can be used regardless of who generated the last migration.</span></span> <span data-ttu-id="23210-222">この例では、開発者\#2 に従ってマージを行い、最後の移行を生成しました。</span><span class="sxs-lookup"><span data-stu-id="23210-222">In the example we’ve been following Developer \#2 is taking care of the merge and they happened to generate the last migration.</span></span> <span data-ttu-id="23210-223">ただし、Developer \#1 が最後の移行を生成した場合は、これらの同じ手順を使用できます。</span><span class="sxs-lookup"><span data-stu-id="23210-223">But these same steps can be used if Developer \#1 generated the last migration.</span></span> <span data-ttu-id="23210-224">この手順は、複数の移行が関係している場合にも適用されます。単純にするために、2つを見てきました。</span><span class="sxs-lookup"><span data-stu-id="23210-224">The steps also apply if there are multiple migrations involved – we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="23210-225">次のプロセスは、ソース管理から同期する必要がある変更があることがわかった時点から、この方法で使用できます。</span><span class="sxs-lookup"><span data-stu-id="23210-225">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="23210-226">ローカルコードベースで保留中のモデルの変更が移行に書き込まれていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="23210-226">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="23210-227">この手順により、空の移行を生成するときに、正当な変更が漏れないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="23210-227">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="23210-228">ソース管理と同期します。</span><span class="sxs-lookup"><span data-stu-id="23210-228">Sync with source control.</span></span>
3.  <span data-ttu-id="23210-229">他の開発者がチェックインした新しい移行を適用するには、 **Update-Database**を実行します。</span><span class="sxs-lookup"><span data-stu-id="23210-229">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="23210-230">**_注:_** *データベースの更新コマンドから警告が表示されない場合は、他の開発者からの新しい移行が行われていないため、さらにマージを実行する必要はありません。*</span><span class="sxs-lookup"><span data-stu-id="23210-230">**_Note:_** *if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="23210-231">[**追加の移行&lt;]\_を\_実行&gt;して名前を選択**します (たとえば、[移行の追加]、[ **ignorechanges 適用]** など)。</span><span class="sxs-lookup"><span data-stu-id="23210-231">Run **Add-Migration &lt;pick\_a\_name&gt; –IgnoreChanges** (for example, **Add-Migration Merge –IgnoreChanges**).</span></span> <span data-ttu-id="23210-232">これにより、すべてのメタデータ (現在のモデルのスナップショットを含む) との移行が生成されますが、現在のモデルを最後の移行のスナップショットと比較するときに検出されるすべての変更が無視されます (つまり、空の**Up**および**Down**メソッドを取得します)。</span><span class="sxs-lookup"><span data-stu-id="23210-232">This generates a migration with all the metadata (including a snapshot of the current model) but will ignore any changes it detects when comparing the current model to the snapshot in the last migrations (meaning you get a blank **Up** and **Down** method).</span></span>
5.  <span data-ttu-id="23210-233">**更新プログラムデータベース**を実行し、最新の移行を更新されたメタデータで再適用します。</span><span class="sxs-lookup"><span data-stu-id="23210-233">Run **Update-Database** to re-apply the latest migration with the updated metadata.</span></span>
6.  <span data-ttu-id="23210-234">開発を続行するか、(コースの単体テストを実行した後で) ソース管理に送信します。</span><span class="sxs-lookup"><span data-stu-id="23210-234">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="23210-235">この方法を使用した\#後の Developer 2 のローカルコードベースの状態を次に示します。</span><span class="sxs-lookup"><span data-stu-id="23210-235">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![マージ移行](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a><span data-ttu-id="23210-237">オプション 2: 前回の移行でモデルスナップショットを更新する</span><span class="sxs-lookup"><span data-stu-id="23210-237">Option 2: Update the model snapshot in the last migration</span></span>

<span data-ttu-id="23210-238">このオプションはオプション1とよく似ていますが、ソリューションに余分なコードファイルを必要としているため、余分な空白の移行は削除されます。</span><span class="sxs-lookup"><span data-stu-id="23210-238">This option is very similar to option 1 but removes the extra blank migration – because let’s face it, who wants extra code files in their solution.</span></span>

<span data-ttu-id="23210-239">**この方法は、最新の移行がローカルコードベースにのみ存在し、ソース管理にまだ送信されていない場合にのみ実行できます (たとえば、最後の移行がマージを行ったユーザーによって生成された場合など)**。</span><span class="sxs-lookup"><span data-stu-id="23210-239">**This approach is only feasible if the latest migration exists only in your local code base and has not yet been submitted to source control (for example, if the last migration was generated by the user doing the merge)**.</span></span> <span data-ttu-id="23210-240">他の開発者によって開発データベースに既に適用されている可能性がある移行のメタデータを編集したり、実稼働データベースに適用したりすると、予期しない副作用が発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="23210-240">Editing the metadata of migrations that other developers may have already applied to their development database – or even worse applied to a production database – can result in unexpected side effects.</span></span> <span data-ttu-id="23210-241">このプロセスでは、ローカルデータベースの最後の移行をロールバックし、更新されたメタデータを使用して再適用します。</span><span class="sxs-lookup"><span data-stu-id="23210-241">During the process we’re going to roll back the last migration in our local database and re-apply it with updated metadata.</span></span>

<span data-ttu-id="23210-242">最後の移行はローカルコードベースでのみ必要ですが、続行する移行の数や順序に制限はありません。</span><span class="sxs-lookup"><span data-stu-id="23210-242">While the last migration needs to just be in the local code base there are no restrictions to the number or order of migrations that proceed it.</span></span> <span data-ttu-id="23210-243">複数の異なる開発者から複数の移行を行うことができ、同じ手順が適用されます。単純にするために、2つを見ているだけです。</span><span class="sxs-lookup"><span data-stu-id="23210-243">There can be multiple migrations from multiple different developers and the same steps apply– we’ve just been looking at two in order to keep it simple.</span></span>

<span data-ttu-id="23210-244">次のプロセスは、ソース管理から同期する必要がある変更があることがわかった時点から、この方法で使用できます。</span><span class="sxs-lookup"><span data-stu-id="23210-244">The following process can be used for this approach, starting from the time you realize you have changes that need to be synced from source control.</span></span>

1.  <span data-ttu-id="23210-245">ローカルコードベースで保留中のモデルの変更が移行に書き込まれていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="23210-245">Ensure any pending model changes in your local code base have been written to a migration.</span></span> <span data-ttu-id="23210-246">この手順により、空の移行を生成するときに、正当な変更が漏れないようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="23210-246">This step ensures you don’t miss any legitimate changes when it comes time to generate the blank migration.</span></span>
2.  <span data-ttu-id="23210-247">ソース管理と同期します。</span><span class="sxs-lookup"><span data-stu-id="23210-247">Sync with the source control.</span></span>
3.  <span data-ttu-id="23210-248">他の開発者がチェックインした新しい移行を適用するには、 **Update-Database**を実行します。</span><span class="sxs-lookup"><span data-stu-id="23210-248">Run **Update-Database** to apply any new migrations that other developers have checked in.</span></span>
    <span data-ttu-id="23210-249">**_注:_** *データベースの更新コマンドから警告が表示されない場合は、他の開発者からの新しい移行が行われていないため、さらにマージを実行する必要はありません。*</span><span class="sxs-lookup"><span data-stu-id="23210-249">**_Note:_** *if you don’t get any warnings from the Update-Database command then there were no new migrations from other developers and there is no need to perform any further merging.*</span></span>
4.  <span data-ttu-id="23210-250">**更新プログラムデータベースを実行する– &lt;targetmigration\_second&gt; \_最後の移行**(この例では、**更新データベース– targetmigration addrating**)。</span><span class="sxs-lookup"><span data-stu-id="23210-250">Run **Update-Database –TargetMigration &lt;second\_last\_migration&gt;** (in the example we’ve been following this would be **Update-Database –TargetMigration AddRating**).</span></span> <span data-ttu-id="23210-251">このロールは、データベースを最後に最後に移行したときの状態に戻ります。データベースからの最後の移行は、実際には適用を解除します。</span><span class="sxs-lookup"><span data-stu-id="23210-251">This roles the database back to the state of the second last migration – effectively ‘un-applying’ the last migration from the database.</span></span>
    <span data-ttu-id="23210-252">**_注:_** *この手順は、メタデータも\_ \_データベースの MigrationsHistoryTable に格納されるため、移行のメタデータの編集を安全に行うために必要です。このため、最後の移行がローカルコードベースのみである場合にのみ、このオプションを使用する必要があります。他のデータベースに最後に移行が適用されている場合は、ロールバックして、最後の移行を再適用してメタデータを更新する必要もあります。*</span><span class="sxs-lookup"><span data-stu-id="23210-252">**_Note:_** *This step is required to make it safe to edit the metadata of the migration since the metadata is also stored in the \_\_MigrationsHistoryTable of the database. This is why you should only use this option if the last migration is only in your local code base. If other databases had the last migration applied you would also have to roll them back and re-apply the last migration to update the metadata.*</span></span> 
5.  <span data-ttu-id="23210-253">**最後&lt;\_\_\_\_の移行のタイムスタンプを含む、\_追加移行の完全な名前を実行します (この後の例では、追加移行 201311062215252 addreaders のようになります)。\_** &gt; **\_**</span><span class="sxs-lookup"><span data-stu-id="23210-253">Run **Add-Migration &lt;full\_name\_including\_timestamp\_of\_last\_migration**&gt; (in the example we’ve been following this would be something like **Add-Migration 201311062215252\_AddReaders**).</span></span>
    <span data-ttu-id="23210-254">**_注:_** *新しい移行をスキャフォールディングするのではなく、既存の移行を編集することを移行が認識できるように、タイムスタンプを含める必要があります。*</span><span class="sxs-lookup"><span data-stu-id="23210-254">**_Note:_** *You need to include the timestamp so that migrations knows you want to edit the existing migration rather than scaffolding a new one.*</span></span>
    <span data-ttu-id="23210-255">これにより、現在のモデルに一致するように、最後の移行のメタデータが更新されます。</span><span class="sxs-lookup"><span data-stu-id="23210-255">This will update the metadata for the last migration to match the current model.</span></span> <span data-ttu-id="23210-256">コマンドが完了すると、次の警告が表示されますが、これはまさに必要なことです。</span><span class="sxs-lookup"><span data-stu-id="23210-256">You’ll get the following warning when the command completes, but that’s exactly what you want.</span></span> <span data-ttu-id="23210-257">"*移行 ' 201311062215252\_Addreaders ' のデザイナーコードのみが再スキャフォールディングされました。移行全体を再スキャフォールディングするには、-Force パラメーターを使用します。*</span><span class="sxs-lookup"><span data-stu-id="23210-257">“*Only the Designer Code for migration '201311062215252\_AddReaders' was re-scaffolded. To re-scaffold the entire migration, use the -Force parameter.”*</span></span>
6.  <span data-ttu-id="23210-258">**更新プログラムデータベース**を実行し、最新の移行を更新されたメタデータで再適用します。</span><span class="sxs-lookup"><span data-stu-id="23210-258">Run **Update-Database** to re-apply the latest migration with the updated metadata.</span></span>
7.  <span data-ttu-id="23210-259">開発を続行するか、(コースの単体テストを実行した後で) ソース管理に送信します。</span><span class="sxs-lookup"><span data-stu-id="23210-259">Continue developing, or submit to source control (after running your unit tests of course).</span></span>

<span data-ttu-id="23210-260">この方法を使用した\#後の Developer 2 のローカルコードベースの状態を次に示します。</span><span class="sxs-lookup"><span data-stu-id="23210-260">Here is the state of Developer \#2’s local code base after using this approach.</span></span>

![更新されたメタデータ](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a><span data-ttu-id="23210-262">要約</span><span class="sxs-lookup"><span data-stu-id="23210-262">Summary</span></span>

<span data-ttu-id="23210-263">チーム環境で Code First Migrations を使用する場合、いくつかの課題があります。</span><span class="sxs-lookup"><span data-stu-id="23210-263">There are some challenges when using Code First Migrations in a team environment.</span></span> <span data-ttu-id="23210-264">ただし、移行のしくみ、およびマージの競合を解決するための簡単な方法についての理解を深めることで、これらの課題を簡単に克服できます。</span><span class="sxs-lookup"><span data-stu-id="23210-264">However, a basic understanding of how migrations works and some simple approaches for resolving merge conflicts make it easy to overcome these challenges.</span></span>

<span data-ttu-id="23210-265">基本的な問題は、最新の移行に格納されている不適切なメタデータです。</span><span class="sxs-lookup"><span data-stu-id="23210-265">The fundamental issue is incorrect metadata stored in the latest migration.</span></span> <span data-ttu-id="23210-266">これにより、Code First は、現在のモデルとデータベーススキーマが一致しないことを誤って検出し、次の移行で誤ったコードをスキャフォールディングします。</span><span class="sxs-lookup"><span data-stu-id="23210-266">This causes Code First to incorrectly detect that the current model and database schema don’t match and to scaffold incorrect code in the next migration.</span></span> <span data-ttu-id="23210-267">この状況は、正しいモデルを使用して空の移行を生成したり、最新の移行でメタデータを更新したりすることによって克服できます。</span><span class="sxs-lookup"><span data-stu-id="23210-267">This situation can be overcome by generating a blank migration with the correct model, or updating the metadata in the latest migration.</span></span>
