---
title: EF4、EF5、および EF6 のパフォーマンスに関する考慮事項 - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: d6d5a465-6434-45fa-855d-5eb48c61a2ea
ms.openlocfilehash: 0ece383bb5083b41c7a2636c009473333af6d3e2
ms.sourcegitcommit: 144edccf9b29a7ffad119c235ac9808ec1a46193
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/16/2020
ms.locfileid: "81434340"
---
# <a name="performance-considerations-for-ef-4-5-and-6"></a>EF 4、5、および 6 のパフォーマンスに関する考慮事項
デビッド・オバンド、エリック・デッティングなど

公開日: 2012年4月

最終更新日:2014年5月

------------------------------------------------------------------------

## <a name="1-introduction"></a>1. 概要

オブジェクトリレーショナルマッピングフレームワークは、オブジェクト指向アプリケーションでデータアクセスの抽象化を提供する便利な方法です。 NET アプリケーションの場合、マイクロソフトの推奨 O/RM はエンティティ フレームワークです。 しかし、どんな抽象化でも、パフォーマンスが懸念される可能性があります。

このホワイト ペーパーは、Entity Framework を使用してアプリケーションを開発する際のパフォーマンスに関する考慮事項を示し、開発者にパフォーマンスに影響を与える可能性のある Entity Framework 内部アルゴリズムのアイデアを提供し、Entity Framework を使用するアプリケーションの調査とパフォーマンス向上のヒントを提供するために書かれています。 Web 上ですでに利用できるパフォーマンスに関する多くの良いトピックがあり、可能な場合はこれらのリソースを指し示す試みもあります。

パフォーマンスは難しいトピックです。 このホワイト ペーパーは、Entity Framework を使用するアプリケーションのパフォーマンスに関する決定を行う際に役立つリソースとして提供されています。 パフォーマンスを実証するためにいくつかのテスト指標が含まれていますが、これらの指標はアプリケーションで表示されるパフォーマンスの絶対的な指標としては意図されていません。

実用上、このドキュメントでは、Entity Framework 4 が .NET 4.0 で実行され、エンティティ フレームワーク 5 と 6 が .NET 4.5 で実行されていることを前提としています。 Entity Framework 5 のパフォーマンス向上の多くは、.NET 4.5 に付属するコア コンポーネント内にあります。

エンティティ フレームワーク 6 は帯域外リリースであり、.NET に付属する Entity Framework コンポーネントには依存しません。 エンティティ フレームワーク 6 は .NET 4.0 と .NET 4.5 の両方で動作し、.NET 4.0 からアップグレードしていないが、アプリケーションで最新の Entity Framework ビットを必要とするユーザーに大きなパフォーマンスの利点を提供できます。 このドキュメントでは、Entity Framework 6 について言及する場合、このドキュメントの執筆時点で利用可能な最新バージョンを参照します。

## <a name="2-cold-vs-warm-query-execution"></a>2. コールドクエリとウォームクエリの実行

特定のモデルに対してクエリが初めて行われると、Entity Framework はモデルを読み込んで検証するために、バックグラウンドで多くの作業を行います。 この最初のクエリは、しばしば "コールド" クエリと呼ばれます。既に読み込まれたモデルに対するクエリは"ウォーム" クエリと呼ばれ、はるかに高速です。

Entity Framework を使用してクエリを実行するときに時間が費やされる場所の概要を見て、Entity Framework 6 での状況が改善されている場所を見てみましょう。

**最初のクエリ実行 – コールド クエリ**

| コード ユーザーの書き込み                                                                                     | アクション                    | EF4 パフォーマンスへの影響                                                                                                                                                                                                                                                                                                                                                                                                        | EF5 パフォーマンスへの影響                                                                                                                                                                                                                                                                                                                                                                                                                                                    | EF6 パフォーマンスへの影響                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | コンテキストの作成          | Medium                                                                                                                                                                                                                                                                                                                                                                                                                        | Medium                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | クエリ式の作成 | 低                                                                                                                                                                                                                                                                                                                                                                                                                           | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var c1 = q1.First();`                                                                             | LINQ クエリの実行      | - メタデータの読み込み: 高いがキャッシュ <br/> - ビュー生成: 非常に高いがキャッシュされる可能性がある <br/> - パラメータ評価: 中 <br/> - クエリ翻訳: 中 <br/> - マテリアライザー生成: 中程度だがキャッシュ <br/> - データベースクエリの実行: 高くなる可能性があります <br/> + 接続.開く <br/> + コマンド.実行リーダー <br/> + データリーダー.読み取り <br/> オブジェクトのマテリアライズ: 中 <br/> - ID ルックアップ: 中 | - メタデータの読み込み: 高いがキャッシュ <br/> - ビュー生成: 非常に高いがキャッシュされる可能性がある <br/> - パラメータ評価: 低 <br/> - クエリ翻訳: 中程度ですがキャッシュされています <br/> - マテリアライザー生成: 中程度だがキャッシュ <br/> - データベースクエリの実行: 潜在的に高い (状況によってはクエリが改善されます) <br/> + 接続.開く <br/> + コマンド.実行リーダー <br/> + データリーダー.読み取り <br/> オブジェクトのマテリアライズ: 中 <br/> - ID ルックアップ: 中 | - メタデータの読み込み: 高いがキャッシュ <br/> - ビュー生成: 中程度だがキャッシュ <br/> - パラメータ評価: 低 <br/> - クエリ翻訳: 中程度ですがキャッシュされています <br/> - マテリアライザー生成: 中程度だがキャッシュ <br/> - データベースクエリの実行: 潜在的に高い (状況によってはクエリが改善されます) <br/> + 接続.開く <br/> + コマンド.実行リーダー <br/> + データリーダー.読み取り <br/> オブジェクトの実体化: 中型 (EF5 より高速) <br/> - ID ルックアップ: 中 |
| `}`                                                                                                  | 接続.閉じる          | 低                                                                                                                                                                                                                                                                                                                                                                                                                           | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |


**2 番目のクエリ実行 – ウォーム クエリ**

| コード ユーザーの書き込み                                                                                     | アクション                    | EF4 パフォーマンスへの影響                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | EF5 パフォーマンスへの影響                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | EF6 パフォーマンスへの影響                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | コンテキストの作成          | Medium                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Medium                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | クエリ式の作成 | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var c1 = q1.First();`                                                                             | LINQ クエリの実行      | - メタデータ~~の読み込み~~ルックアップ:~~高いがキャッシュされた~~低 <br/> - 表示~~生成~~ルックアップ:~~非常に高いがキャッシュされた~~低 <br/> - パラメータ評価: 中 <br/> - クエリ~~翻訳~~の検索: 中 <br/> - マテリアライザー~~生成~~ルックアップ:~~中程度だがキャッシュされた~~低 <br/> - データベースクエリの実行: 高くなる可能性があります <br/> + 接続.開く <br/> + コマンド.実行リーダー <br/> + データリーダー.読み取り <br/> オブジェクトのマテリアライズ: 中 <br/> - ID ルックアップ: 中 | - メタデータ~~の読み込み~~ルックアップ:~~高いがキャッシュされた~~低 <br/> - 表示~~生成~~ルックアップ:~~非常に高いがキャッシュされた~~低 <br/> - パラメータ評価: 低 <br/> - クエリ~~翻訳~~の検索:~~中程度ですが、キャッシュされた~~低 <br/> - マテリアライザー~~生成~~ルックアップ:~~中程度だがキャッシュされた~~低 <br/> - データベースクエリの実行: 潜在的に高い (状況によってはクエリが改善されます) <br/> + 接続.開く <br/> + コマンド.実行リーダー <br/> + データリーダー.読み取り <br/> オブジェクトのマテリアライズ: 中 <br/> - ID ルックアップ: 中 | - メタデータ~~の読み込み~~ルックアップ:~~高いがキャッシュされた~~低 <br/> - 表示~~生成~~ルックアップ:~~中程度だがキャッシュされた~~低 <br/> - パラメータ評価: 低 <br/> - クエリ~~翻訳~~の検索:~~中程度ですが、キャッシュされた~~低 <br/> - マテリアライザー~~生成~~ルックアップ:~~中程度だがキャッシュされた~~低 <br/> - データベースクエリの実行: 潜在的に高い (状況によってはクエリが改善されます) <br/> + 接続.開く <br/> + コマンド.実行リーダー <br/> + データリーダー.読み取り <br/> オブジェクトの実体化: 中型 (EF5 より高速) <br/> - ID ルックアップ: 中 |
| `}`                                                                                                  | 接続.閉じる          | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |


コールド クエリとウォーム クエリの両方のパフォーマンス コストを削減するには、いくつかの方法があります。 具体的には、事前生成されたビューを使用して、コールド クエリでのモデルの読み込みコストを削減する方法を見ていきます。 ウォーム クエリの場合は、クエリ プランのキャッシュ、追跡クエリ、およびさまざまなクエリ実行オプションについて説明します。

### <a name="21-what-is-view-generation"></a>2.1 ビュー生成とは

ビューの生成とは何かを理解するためには、まず「マッピングビュー」が何であるかを理解する必要があります。 マッピング ビューは、各エンティティ セットおよびアソシエーションのマッピングで指定された変換の実行可能な表現です。 内部的には、これらのマッピングビューは、CQT(正規照会ツリー)の形をとっています。 マッピング ビューには、次の 2 種類があります。

-   クエリ ビュー: これらは、データベース スキーマから概念モデルに移動するために必要な変換を表します。
-   ビューの更新: 概念モデルからデータベース スキーマに移動するために必要な変換を表します。

概念モデルは、データベース スキーマとはさまざまな点で異なる場合があります。 たとえば、1 つのテーブルを使用して、2 つの異なるエンティティ型のデータを格納できます。 継承と非自明なマッピングは、マッピング ビューの複雑さに役割を果たします。

マッピングの仕様に基づいてこれらのビューを計算するプロセスは、ビュー生成と呼ばれるものです。 ビューの生成は、モデルが読み込まれたときに動的に行うか、ビルド時に 「事前生成されたビュー」を使用して行うことができます。後者は、エンティティ SQL ステートメントの形式で C\#または VB ファイルにシリアル化されます。

ビューが生成されると、ビューも検証されます。 パフォーマンスの観点から見ると、ビュー生成のコストの大半は、実際には、エンティティ間の接続が意味をなし、サポートされているすべての操作に対して正しいカーディナリティを持っていることを保証するビューの検証です。

エンティティ セットに対するクエリが実行されると、クエリは対応するクエリ ビューと組み合わされ、この構成の結果は、バッキング ストアが理解できるクエリの表現を作成するためにプラン コンパイラを介して実行されます。 SQL Server の場合、このコンパイルの最終結果は、T-SQL の SELECT ステートメントになります。 エンティティ セットに対する更新が初めて実行されると、更新ビューは同様のプロセスを経て実行され、ターゲット データベースの DML ステートメントに変換されます。

### <a name="22-factors-that-affect-view-generation-performance"></a>2.2 ビュー生成のパフォーマンスに影響する要因

ビュー生成ステップのパフォーマンスは、モデルのサイズだけでなく、モデルの相互接続方法によっても異なります。 2 つのエンティティが継承チェーンまたは関連付けを介して接続されている場合、それらは接続されていると言います。 同様に、2 つのテーブルが外部キーを介して接続されている場合、それらは接続されます。 スキーマ内の接続されたエンティティとテーブルの数が増加すると、ビュー生成コストが増加します。

ビューの生成と検証に使用するアルゴリズムは、最悪の場合は指数関数的ですが、これを改善するためにいくつかの最適化を使用します。 パフォーマンスに悪影響を及ぼすと思われる最大の要因は次のとおりです。

-   モデル サイズ (エンティティの数とこれらのエンティティ間のアソシエーションの量を参照)。
-   モデルの複雑さ、特に多数の型を含む継承。
-   外部キーアソシエーションの代わりに独立アソシエーションを使用する。

小さい単純なモデルでは、コストは、事前に生成されたビューを使用して気にしないように十分に小さい場合があります。 モデルのサイズと複雑さが増すに伴い、ビューの生成と検証のコストを削減するためにいくつかのオプションが用意されています。

### <a name="23-using-pre-generated-views-to-decrease-model-load-time"></a>2.3 事前生成されたビューを使用してモデルの読み込み時間を短縮する

Entity Framework 6 で事前生成されたビューを使用する方法の詳細については、[事前生成されたマッピング ビューを](~/ef6/fundamentals/performance/pre-generated-views.md)参照してください。

#### <a name="231-pre-generated-views-using-the-entity-framework-power-tools-community-edition"></a>2.3.1 Entity Framework のパワー ツール コミュニティ エディションを使用して事前に生成されたビュー

Entity Framework [6 Power Tools コミュニティ エディション](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition)を使用して、モデル クラス ファイルを右クリックし、Entity Framework メニューを使用して [ビューの生成] を選択することで、EDMX および Code First モデルのビューを生成できます。 エンティティ フレームワークのパワー ツール コミュニティ エディションは、DbContext 派生コンテキストでのみ動作します。

#### <a name="232-how-to-use-pre-generated-views-with-a-model-created-by-edmgen"></a>2.3.2 EDMGen によって作成されたモデルで事前生成されたビューを使用する方法

EDMGen は .NET に付属するユーティリティで、エンティティ フレームワーク 4 および 5 で動作しますが、エンティティ フレームワーク 6 では動作しません。 EDMGen を使用すると、コマンド ラインからモデル ファイル、オブジェクト レイヤ、ビューを生成できます。 出力の 1 つは、選択した言語のビュー ファイルです( VB\#または C . これは、エンティティ セットごとに Entity SQL スニペットを含むコード ファイルです。 事前に生成されたビューを有効にするには、プロジェクトにファイルを含めるだけです。

モデルのスキーマ ファイルを手動で編集する場合は、ビュー ファイルを再生成する必要があります。 これを行うには **、/モード:ビュージェネレーション**フラグを指定して EDMGen を実行します。

#### <a name="233-how-to-use-pre-generated-views-with-an-edmx-file"></a>2.3.3 EDMX ファイルで事前生成されたビューを使用する方法

EDMGen を使用して EDMX ファイルのビューを生成することもできます ( 前に参照した MSDN のトピックでは、ビルド前のイベントを追加してこれを行う方法について説明されています ) が、これは複雑で、不可能な場合もあります。 モデルが edmx ファイル内にある場合、一般に T4 テンプレートを使用してビューを生成する方が簡単です。

ADO.NETチームブログには、ビュー生成に T4 テンプレートを使用する方法を説明する投稿\<https://docs.microsoft.com/archive/blogs/adonet/how-to-use-a-t4-template-for-view-generation>)があります ( . この投稿には、ダウンロードしてプロジェクトに追加できるテンプレートが含まれています。 テンプレートは、Entity Framework の最初のバージョンのために書かれたため、Entity Framework の最新バージョンで動作する保証はありません。 ただし、エンティティ フレームワーク 4 と 5 のビュー生成テンプレートの最新のセットを Visual Studio ギャラリーからダウンロードできます。

-   VB.NET:\<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d>
-   C:\#\<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d>

エンティティ フレームワーク 6 を使用している場合は、ビュー生成 T4 テンプレートを Visual \< http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f>Studio ギャラリーの で入手できます。

### <a name="24-reducing-the-cost-of-view-generation"></a>2.4 ビュー生成コストの削減

事前生成されたビューを使用すると、ビュー生成のコストがモデルの読み込み (実行時) からデザイン時に移動します。 これにより、実行時の起動時のパフォーマンスが向上しますが、開発中でもビュー生成の痛みが発生します。 コンパイル時と実行時の両方で、ビュー生成のコストを削減できるいくつかの追加のトリックがあります。

#### <a name="241-using-foreign-key-associations-to-reduce-view-generation-cost"></a>2.4.1 外部キーアソシエーションを使用してビュー生成コストを削減する

モデル内のアソシエーションを独立アソシエーションから外部キーアソシエーションに切り替えることで、ビュー生成に費やす時間が劇的に短縮されるケースが数多く見られました。

この改善を実証するために、EDMGen を使用して、2 つのバージョンの Navision モデルを生成しました。 *注: Navision モデルの説明については、付録 C を参照してください。* Navision モデルは、この演習では、非常に大量のエンティティとそれらの間の関係が興味深いものです。

この非常に大きなモデルの 1 つのバージョンは、外部キーアソシエーションで生成され、もう 1 つは独立アソシエーションで生成されました。 次に、各モデルのビューの生成にかかった時間を時間を設定しました。 エンティティ フレームワーク 5 テストでは、クラス EntityViewGenerator の GenerateViews() メソッドを使用してビューを生成し、エンティティ フレームワーク 6 テストではクラスから GenerateViews() メソッドを使用しました。 これは、Entity Framework 6 のコードベースで発生したコード再構築によるものです。

Entity Framework 5 を使用して、外部キーを持つモデルのビューの生成は、ラボ コンピューターで 65 分かかりました。 独立した関連付けを使用したモデルのビューの生成にどれくらいの時間がかかったかは不明です。 毎月の更新プログラムをインストールするために、ラボでマシンが再起動される前に、テストを 1 か月以上実行したままにしました。

Entity Framework 6 を使用して、外部キーを持つモデルのビューの生成は、同じラボ コンピューターで 28 秒かかりました。 独立アソシエーションを使用するモデルのビューの生成には 58 秒かかりました。 ビュー生成コードの Entity Framework 6 に対する機能強化は、多くのプロジェクトが起動時間を短縮するために事前に生成されたビューを必要としないことを意味します。

Entity Framework 4 と 5 のビューを生成する前に EDMGen またはエンティティ フレームワークの電源ツールを使用して行うことができることを注意してください。 Entity Framework 6 ビューの生成は、Entity Framework の Power Tools を使用して行うか、[または事前に生成されたマッピング ビュー](~/ef6/fundamentals/performance/pre-generated-views.md)の説明に従ってプログラムで行うことができます。

##### <a name="2411-how-to-use-foreign-keys-instead-of-independent-associations"></a>2.4.1.1 独立アソシエーションの代わりに外部キーを使用する方法

EdMGen またはエンティティ デザイナーを使用する場合、既定では、FKs を取得し、FK と IA を切り替えるには 1 つのチェック ボックスまたはコマンド ライン フラグのみで行われます。

大規模な Code First モデルがある場合、独立アソシエーションを使用すると、ビューの生成に対して同じ効果が得られます。 外部キープロパティを依存オブジェクトのクラスに含めることで、この影響を回避できますが、開発者の中には、オブジェクト モデルを汚染していると考える開発者もいます。 このテーマの詳細については、「」を参照\<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/>してください。

| 使用する場合      | 方法                                                                                                                                                                                                                                                                                                                              |
|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| エンティティ デザイナー | 2 つのエンティティ間に関連付けを追加した後、参照制約があることを確認します。 参照制約は、独立したアソシエーションではなく外部キーを使用するように Entity Framework に指示します。 詳細については、\<https://docs.microsoft.com/archive/blogs/efdesign/foreign-keys-in-the-entity-framework>を参照してください。 |
| エドムジェン          | EDMGen を使用してデータベースからファイルを生成する場合、外部キーが尊重され、モデルに追加されます。 EDMGen によって公開されるさまざまなオプションの詳細については、[http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx)を参照してください。                           |
| Code First      | Code First を使用する場合に、依存オブジェクトに外部キー プロパティを含める方法については、「[コードファースト規約](~/ef6/modeling/code-first/conventions/built-in.md)」トピックの「関係規約」を参照してください。                                                                                              |

#### <a name="242-moving-your-model-to-a-separate-assembly"></a>2.4.2 モデルを別のアセンブリに移動する

モデルがアプリケーションのプロジェクトに直接含まれ、ビルド前のイベントまたは T4 テンプレートを通じてビューを生成する場合、モデルが変更されていなくても、プロジェクトが再構築されるたびにビューの生成と検証が行われます。 モデルを別のアセンブリに移動し、アプリケーションのプロジェクトから参照する場合、モデルを含むプロジェクトを再構築することなく、アプリケーションに他の変更を加えることができます。

*注:* モデルを個別のアセンブリに移動する場合は、モデルの接続文字列をクライアント プロジェクトのアプリケーション構成ファイルにコピーしてください。

#### <a name="243-disable-validation-of-an-edmx-based-model"></a>2.4.3 edmx ベースモデルの検証を無効にする

EDMX モデルは、モデルが変更されていない場合でも、コンパイル時に検証されます。 モデルが既に検証されている場合は、プロパティ ウィンドウで"ビルド時に検証" プロパティを false に設定することで、コンパイル時に検証を抑制できます。 マッピングまたはモデルを変更すると、一時的に検証を再び有効にして、変更を検証できます。

Entity Framework 6 の Entity Framework デザイナーのパフォーマンスが向上し、「ビルド時に検証」のコストは、デザイナーの以前のバージョンよりもはるかに低い点に注意してください。

## <a name="3-caching-in-the-entity-framework"></a>3 エンティティ フレームワークでのキャッシュ

エンティティ フレームワークには、次の形式のキャッシュが組み込まれています。

1.  オブジェクトのキャッシュ – ObjectContext インスタンスに組み込まれた ObjectStateManager は、そのインスタンスを使用して取得されたオブジェクトのメモリ内で追跡を保持します。 これは、第 1 レベル キャッシュとも呼ばれます。
2.  クエリ プラン のキャッシュ - クエリが複数回実行されたときに生成されたストア コマンドを再利用します。
3.  メタデータキャッシュ - 同じモデルに対する異なる接続間でモデルのメタデータを共有します。

EF が提供するキャッシュ以外にも、ラップ プロバイダーと呼ばれる特殊な種類のADO.NET データ プロバイダーを使用して、データベースから取得した結果のキャッシュ (第 2 レベル キャッシュとも呼ばれます) を使用して Entity Framework を拡張することもできます。

### <a name="31-object-caching"></a>3.1 オブジェクトキャッシュ

既定では、エンティティがクエリの結果に返されるとき、EF が具体化する直前に、同じキーを持つエンティティが既に ObjectStateManager に読み込まれているかどうかを確認します。 同じキーを持つエンティティが既に存在する場合、EF はクエリの結果に含めます。 EF はデータベースに対してクエリを発行しますが、この動作はエンティティを複数回具体化する場合のコストの多くをバイパスできます。

#### <a name="311-getting-entities-from-the-object-cache-using-dbcontext-find"></a>3.1.1 DbContext 検索を使用してオブジェクト キャッシュからエンティティを取得する

通常のクエリとは異なり、データベースに対してクエリを発行する前に、DbSet の Find メソッド (EF 4.1 に初めて含まれる API) がメモリ内で検索を実行します。 2 つの異なる ObjectContext インスタンスには 2 つの異なる ObjectStateManager インスタンスがあり、別々のオブジェクト キャッシュがあることに注意してください。

Find は、主キーの値を使用して、コンテキストによって追跡されるエンティティの検索を試みます。 エンティティがコンテキスト内にない場合、クエリは実行され、データベースに対して評価され、コンテキストまたはデータベースでエンティティが見つからない場合は null が返されます。 Find は、コンテキストに追加されたが、まだデータベースに保存されていないエンティティも返します。

検索を使用する場合は、パフォーマンスに関する考慮事項があります。 既定では、このメソッドを呼び出すと、データベースへのコミットが保留状態の変更を検出するために、オブジェクト キャッシュの検証がトリガーされます。 オブジェクト キャッシュまたは大きなオブジェクト グラフにオブジェクト キャッシュに追加されるオブジェクトの数が非常に多い場合、この処理は非常に高価になる可能性がありますが、無効にすることもできます。 場合によっては、変更の自動検出を無効にすると、Find メソッドを呼び出す際に、大きな差が生じることがあります。 しかし、オブジェクトが実際にキャッシュに入っているときと、オブジェクトをデータベースから取得する必要がある場合に対して、2 番目の大きさが認識されます。 次に、マイクロベンチマークの一部を使用して測定した測定例を示します( ミリ秒単位で表され、負荷は 5,000 個のエンティティーで)。

![.NET 4.5 対数目盛](~/ef6/media/net45logscale.png ".NET 4.5 - 対数目盛")

自動検出変更を無効にした検索の例:

``` csharp
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    context.Configuration.AutoDetectChangesEnabled = true;
    ...
```

Find メソッドを使用する際に考慮する必要がある内容は次のとおりです。

1.  オブジェクトがキャッシュにない場合は、Find の利点は否定されますが、構文はキーによるクエリよりも単純です。
2.  自動検出の変更が有効になっている場合、Find メソッドのコストは 1 桁ずつ増加するか、モデルの複雑さとオブジェクト キャッシュ内のエンティティの量によってさらに大きくなる場合があります。

また、検索は、探しているエンティティのみを返し、オブジェクト キャッシュにまだ存在しない場合は、関連付けられたエンティティを自動的に読み込まない点に注意してください。 関連付けられたエンティティを取得する必要がある場合は、キーによるクエリを使用して一括読み込みを行うことができます。 詳細については、「 **8.1 遅延読み込みと一括読み込み 」を参照してください。**

#### <a name="312-performance-issues-when-the-object-cache-has-many-entities"></a>3.1.2 オブジェクトキャッシュに多数のエンティティがある場合のパフォーマンスの問題

オブジェクト キャッシュは、エンティティ フレームワークの全体的な応答性を向上させるのに役立ちます。 ただし、オブジェクト キャッシュに大量のエンティティが読み込まれると、追加、削除、検索、エントリ、SaveChanges などの特定の操作に影響する可能性があります。 特に、DetectChanges の呼び出しをトリガーする操作は、非常に大きなオブジェクト キャッシュによって悪影響を受けます。 DetectChanges はオブジェクト グラフをオブジェクト状態マネージャーと同期し、そのパフォーマンスはオブジェクト グラフのサイズによって直接決定されます。 変更の検出の詳細については、「 [POCO エンティティの変更の追跡](https://msdn.microsoft.com/library/dd456848.aspx)」を参照してください。

エンティティ フレームワーク 6 を使用すると、開発者はコレクションを反復処理してインスタンスごとに 1 回 Add を呼び出す代わりに、DbSet で直接 AddRange と RemoveRange を呼び出す必要があります。 範囲メソッドを使用する利点は、追加された各エンティティごとに 1 回ではなく、一連のエンティティ全体に対して、DetectChanges のコストが 1 回だけ支払われるということです。

### <a name="32-query-plan-caching"></a>3.2 クエリ プランのキャッシュ

クエリが初めて実行されるとき、クエリは内部プラン コンパイラを通じて概念クエリを store コマンドに変換します (たとえば、SQL Server に対して実行されるときに実行される T-SQL)。クエリ プランのキャッシュが有効になっている場合、次にクエリを実行するときに、プラン のコンパイラをバイパスして、クエリ プラン キャッシュから直接ストア コマンドを取得します。

クエリ プラン キャッシュは、同じ AppDomain 内の ObjectContext インスタンス間で共有されます。 クエリ プランのキャッシュを利用するために ObjectContext インスタンスを保持する必要はありません。

#### <a name="321-some-notes-about-query-plan-caching"></a>3.2.1 クエリ プランのキャッシュに関する注意事項

-   クエリ プラン キャッシュは、エンティティ SQL、エンティティへの LINQ、および CompiledQuery オブジェクトのすべてのクエリの種類で共有されます。
-   既定では、クエリ プランのキャッシュは、EntityCommand または ObjectQuery を使用して実行されるかどうか、エンティティ SQL クエリに対して有効になっています。 また、既定では、.NET 4.5 のエンティティ フレームワークおよびエンティティ フレームワーク 6 で LINQ to Entity クエリが有効になっています。
    -   クエリ プランのキャッシュは、"EnablePlanCaching/プランキャッシュ" プロパティ (エンティティ コマンドまたは ObjectQuery) を false に設定することで無効にできます。 次に例を示します。
``` csharp
                    var query = from customer in context.Customer
                                where customer.CustomerId == id
                                select new
                                {
                                    customer.CustomerId,
                                    customer.Name
                                };
                    ObjectQuery oQuery = query as ObjectQuery;
                    oQuery.EnablePlanCaching = false;
```
-   パラメータ化クエリの場合、パラメータの値を変更してもキャッシュされたクエリにヒットします。 ただし、パラメータのファセット(サイズ、精度、スケールなど)を変更すると、キャッシュ内の別のエントリにヒットします。
-   Entity SQL を使用する場合、クエリ文字列はキーの一部です。 クエリをまったく変更すると、クエリが機能的に同等であっても、キャッシュ エントリが異なります。 これには、大文字と小文字の変更や空白の変更も含まれます。
-   LINQ を使用する場合、クエリはキーの一部を生成するために処理されます。 したがって、LINQ 式を変更すると、別のキーが生成されます。
-   その他の技術的な制限が適用される場合があります。詳細については、「自動コンパイルされたクエリ」を参照してください。

#### <a name="322-cache-eviction-algorithm"></a>3.2.2 キャッシュ除去アルゴリズム

内部アルゴリズムの動作を理解することは、クエリ プランのキャッシュを有効または無効にするタイミングを理解するのに役立ちます。 クリーンアップ アルゴリズムは次のとおりです。

1.  キャッシュに一定のエントリ数(800)が含まれると、定期的に(1 分に 1 回)キャッシュをスイープするタイマーが開始されます。
2.  キャッシュ スイープ中に、エントリは LFRU (最も頻繁に – 最近使用) ベースでキャッシュから削除されます。 このアルゴリズムでは、どのエントリを取り出すかを決定する際に、ヒット カウントと経過時間の両方が考慮されます。
3.  各キャッシュ スイープの最後に、キャッシュに再び 800 個のエントリが含まれます。

どのエントリを削除するかを決定する際に、すべてのキャッシュ エントリが均等に処理されます。 これは、CompiledQuery のストア コマンドがエンティティ SQL クエリのストア コマンドと同じ削除の可能性を持つということを意味します。

キャッシュに 800 個のエンティティがある場合、キャッシュの削除タイマーが開始されますが、キャッシュは、このタイマーが開始されてから 60 秒後にスイープされます。 つまり、最大 60 秒間、キャッシュが非常に大きくなる可能性があります。

#### <a name="323-test-metrics-demonstrating-query-plan-caching-performance"></a>3.2.3 クエリプランのキャッシュパフォーマンスを示すテストメトリック

クエリ プランのキャッシュがアプリケーションのパフォーマンスに及ぼす影響を示すために、Navision モデルに対して多数の Entity SQL クエリを実行したテストを実行しました。 Navision モデルの説明と実行されたクエリの種類については、付録を参照してください。 このテストでは、まずクエリのリストを反復処理し、それぞれを 1 回実行してキャッシュに追加します (キャッシュが有効な場合)。 このステップは時間がかからずに行ないます。 次に、メイン スレッドを 60 秒以上スリープしてキャッシュ スイープを実行できるようにします。最後に、キャッシュされたクエリを実行するために 2 回目のリストを反復処理します。 さらに、SQL Server プラン キャッシュは、クエリ の各セットが実行される前にフラッシュされるため、取得した時間がクエリ プラン キャッシュによって与えられた利点を正確に反映します。

##### <a name="3231-test-results"></a>3.2.3.1 テスト結果

| テスト                                                                   | EF5 キャッシュなし | EF5 キャッシュ | EF6 キャッシュなし | EF6 キャッシュ |
|:-----------------------------------------------------------------------|:-------------|:-----------|:-------------|:-----------|
| 18723 のすべてのクエリの列挙                                          | 124          | 125.4      | 124.3        | 125.3      |
| スイープの回避 (複雑さに関係なく、最初の 800 個のクエリだけ)  | 41.7         | 5.5        | 40.5         | 5.4        |
| 集計小計クエリ (合計 178 - スイープを回避) | 39.5         | 4.5        | 38.1         | 4.6        |

*すべての時間(秒単位)。*

モラル - 多数の異なるクエリ (動的に作成されたクエリなど) を実行する場合、キャッシュは役に立たないため、キャッシュのフラッシュによって、プランのキャッシュが実際に使用されないようにクエリを保持できます。

集計小計クエリは、テストしたクエリの中で最も複雑です。 予想どおり、クエリが複雑になるほど、クエリ プランのキャッシュによる利点が高くなります。

コンパイルクエリは実際には、そのプランがキャッシュされた LINQ クエリであるため、コンパイルクエリと同等のエンティティ SQL クエリの比較は、同様の結果を持っている必要があります。 実際、アプリに動的な Entity SQL クエリが多数存在する場合、キャッシュにクエリを含めると、キャッシュからフラッシュされるときに CompiledQueries が逆コンパイルされます。 このシナリオでは、動的クエリのキャッシュを無効にして、CompiledQuerys の優先順位を設定することでパフォーマンスを向上させることができます。 もちろん、動的クエリの代わりにパラメータ化されたクエリを使用するようにアプリを書き換える方が良いでしょう。

### <a name="33-using-compiledquery-to-improve-performance-with-linq-queries"></a>3.3 コンパイル済みクエリを使用して LINQ クエリのパフォーマンスを向上させる

このテストでは、CompiledQuery を使用すると、自動コンパイルされた LINQ クエリよりも 7% の利点が得られる可能性があることを示しています。つまり、Entity Framework スタックからのコードの実行に 7% 費やす時間が減少します。アプリケーションが 7% 高速になるわけではありません。 一般的に言えば、EF 5.0 での CompiledQuery オブジェクトの作成と保守のコストは、利点と比較しても、問題にならない場合があります。 走行距離は異なる場合がありますので、プロジェクトで余分なプッシュが必要な場合は、このオプションを実行します。 コンパイルクエリは、オブジェクト コンテキスト派生モデルとのみ互換性があり、DbContext 派生モデルとの互換性がないことに注意してください。

コンパイル済みクエリの作成と呼び出しの詳細については、「[コンパイル済みクエリ (LINQ to Entities)」](https://msdn.microsoft.com/library/bb896297.aspx)を参照してください。

CompiledQuery を使用する場合に必要な考慮事項は 2 つ、つまり静的インスタンスを使用する要件と、インスタンスの構成可能性に関する問題点があります。 ここでは、これら 2 つの考慮事項の詳細な説明を次に示します。

#### <a name="331-use-static-compiledquery-instances"></a>3.3.1 静的な CompiledQuery インスタンスを使用する

LINQ クエリのコンパイルは時間のかかるプロセスであるため、データベースからデータをフェッチする必要があるたびに実行する必要はありません。 CompiledQuery インスタンスを使用すると、コンパイルを 1 回実行して複数回実行できますが、同じ CompiledQuery インスタンスを何度も繰り返しコンパイルするのではなく、毎回再利用するように注意して調達する必要があります。 静的メンバーを使用して CompiledQuery インスタンスを格納する必要があります。それ以外の場合は、任意の利点が表示されません。

たとえば、選択したカテゴリの製品の表示を処理する次のメソッド本体がページに含されているとします。

``` csharp
    // Warning: this is the wrong way of using CompiledQuery
    using (NorthwindEntities context = new NorthwindEntities())
    {
        string selectedCategory = this.categoriesList.SelectedValue;

        var productsForCategory = CompiledQuery.Compile<NorthwindEntities, string, IQueryable<Product>>(
            (NorthwindEntities nwnd, string category) =>
                nwnd.Products.Where(p => p.Category.CategoryName == category)
        );

        this.productsGrid.DataSource = productsForCategory.Invoke(context, selectedCategory).ToList();
        this.productsGrid.DataBind();
    }

    this.productsGrid.Visible = true;
```

この場合、メソッドが呼び出されるたびに、新しい CompiledQuery インスタンスをその場で作成します。 クエリ プラン キャッシュからストア コマンドを取得することでパフォーマンス上の利点が得られる代わりに、CompiledQuery は新しいインスタンスが作成されるたびにプラン コンパイラを通過します。 実際には、メソッドが呼び出されるたびに、新しい CompiledQuery エントリを使用してクエリ プラン キャッシュを汚染します。

代わりに、コンパイル済みクエリの静的インスタンスを作成し、メソッドが呼び出されるたびに同じコンパイル済みクエリを呼び出します。 これを行う 1 つの方法は、オブジェクト コンテキストのメンバーとして CompiledQuery インスタンスを追加することです。次に、ヘルパー メソッドを使用して CompiledQuery にアクセスすることで、物事を少し簡潔にすることができます。

``` csharp
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IEnumerable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
            );

        public IEnumerable<Product> GetProductsForCategory(string categoryName)
        {
            return productsForCategoryCQ.Invoke(this, categoryName).ToList();
        }
```

このヘルパー メソッドは、次のように呼び出されます。

``` csharp
    this.productsGrid.DataSource = context.GetProductsForCategory(selectedCategory);
```

#### <a name="332-composing-over-a-compiledquery"></a>3.3.2 コンパイルクエリの作成

任意の LINQ クエリを構成する機能は非常に便利です。これを行うには *、Skip()* や*Count()* などの IQueryable の後にメソッドを呼び出すだけです。 ただし、この操作を行うと、基本的に新しい IQueryable オブジェクトが返されます。 技術的に CompiledQuery を使って作成することを止めるものは何もありませんが、そうすることで、プランコンパイラを再度渡す必要がある新しい IQueryable オブジェクトが生成されます。

コンポーネントによっては、構成された IQueryable オブジェクトを使用して高度な機能を実現します。 たとえば、ASP です。プロパティを使用して、IQuery が可能なオブジェクトにデータ バインドできます。 GridView は、データ モデルの並べ替えとページングを許可するこの IQueryable オブジェクトを構成します。 ご覧のとおり、GridView に CompiledQuery を使用すると、コンパイルされたクエリにはヒットしませんが、新しい自動コンパイルされたクエリが生成されます。

これに遭遇する場所の 1 つは、プログレッシブ フィルターをクエリに追加する場合です。 たとえば、オプションのフィルタ (たとえば、国と受注数) のドロップダウン リストが複数ある [得意先] ページがあるとします。 これらのフィルターは、CompiledQuery の IQueryable の結果を使用して構成できますが、その場合、新しいクエリは、毎回プラン コンパイラを通過します。

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployee();

        if (this.orderCountFilterList.SelectedItem.Value != defaultFilterText)
        {
            int orderCount = int.Parse(orderCountFilterList.SelectedValue);
            myCustomers = myCustomers.Where(c => c.Orders.Count > orderCount);
        }

        if (this.countryFilterList.SelectedItem.Value != defaultFilterText)
        {
            myCustomers = myCustomers.Where(c => c.Address.Country == countryFilterList.SelectedValue);
        }

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 この再コンパイルを回避するには、可能なフィルターを考慮するように CompiledQuery を書き直します。

``` csharp
    private static readonly Func<NorthwindEntities, int, int?, string, IQueryable<Customer>> customersForEmployeeWithFiltersCQ = CompiledQuery.Compile(
        (NorthwindEntities context, int empId, int? countFilter, string countryFilter) =>
            context.Customers.Where(c => c.Orders.Any(o => o.EmployeeID == empId))
            .Where(c => countFilter.HasValue == false || c.Orders.Count > countFilter)
            .Where(c => countryFilter == null || c.Address.Country == countryFilter)
        );
```

UI で次のように呼び出されます。

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        int? countFilter = (this.orderCountFilterList.SelectedIndex == 0) ?
            (int?)null :
            int.Parse(this.orderCountFilterList.SelectedValue);

        string countryFilter = (this.countryFilterList.SelectedIndex == 0) ?
            null :
            this.countryFilterList.SelectedValue;

        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployeeWithFilters(
                countFilter, countryFilter);

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 ここでのトレードオフは、生成されたストアコマンドは常に null チェックを持つフィルタを持ちますが、これらはデータベースサーバが最適化するためにかなり簡単でなければなりません。

``` SQL
...
WHERE ((0 = (CASE WHEN (@p__linq__1 IS NOT NULL) THEN cast(1 as bit) WHEN (@p__linq__1 IS NULL) THEN cast(0 as bit) END)) OR ([Project3].[C2] > @p__linq__2)) AND (@p__linq__3 IS NULL OR [Project3].[Country] = @p__linq__4)
```

### <a name="34-metadata-caching"></a>3.4 メタデータのキャッシュ

エンティティ フレームワークは、メタデータのキャッシュもサポートしています。 これは、基本的に、同じモデルに対する異なる接続間での型情報とタイプからデータベースへのマッピング情報のキャッシュです。 メタデータ キャッシュは、AppDomain ごとに一意です。

#### <a name="341-metadata-caching-algorithm"></a>3.4.1 メタデータキャッシュアルゴリズム

1.  モデルのメタデータ情報は、各エンティティ接続のアイテム コレクションに格納されます。
    -   この点に注意して、モデルの各部分に対して異なる ItemCollection オブジェクトがあります。 たとえば、StoreItemCollections にはデータベース モデルに関する情報が含まれています。データ モデルに関する情報が含まれています。EdmItemCollection には、概念モデルに関する情報が含まれています。

2.  2 つの接続で同じ接続文字列を使用する場合、それらは同じ ItemCollection インスタンスを共有します。
3.  機能的には同等ですが、テキストで異なる接続文字列は、異なるメタデータキャッシュをもたらす可能性があります。 接続文字列をトークン化するので、トークンの順序を変更するだけで共有メタデータが得られます。 しかし、機能的に同じように見える 2 つの接続文字列は、トークン化後に同一として評価されない場合があります。
4.  ItemCollection は定期的に使用されるかどうかを確認します。 ワークスペースが最近アクセスされていないと判断された場合、そのワークスペースは次のキャッシュ スイープでクリーンアップの対象としてマークされます。
5.  EntityConnection を作成するだけで、メタデータ キャッシュが作成されます (ただし、その中の項目コレクションは接続が開かれるまで初期化されません)。 このワークスペースは、キャッシュ アルゴリズムが "使用中" でないと判断するまで、メモリ内に残ります。

顧客アドバイザリー チームは、大規模なモデルを使用する場合の "廃止" を避けるために ItemCollection への参照を保持する方法を\<https://docs.microsoft.com/archive/blogs/appfabriccat/holding-a-reference-to-the-ef-metadataworkspace-for-wcf-services>説明するブログ記事を作成しました。

#### <a name="342-the-relationship-between-metadata-caching-and-query-plan-caching"></a>3.4.2 メタデータ キャッシュとクエリ プラン キャッシュの関係

クエリ プランのキャッシュ インスタンスは、ストアの種類のメタデータ ワークスペースの ItemCollection に格納されます。 つまり、キャッシュされたストア コマンドは、特定の MetadataWorkspace を使用してインスタンス化された任意のコンテキストに対するクエリに使用されます。 また、トークン化後にわずかに異なる 2 つの接続文字列が一致しない場合は、異なるクエリ プランのキャッシュ インスタンスが作成されます。

### <a name="35-results-caching"></a>3.5 結果のキャッシュ

結果のキャッシュ (「第 2 レベル キャッシュ」とも呼ばれます) を使用すると、クエリの結果をローカル キャッシュに保持できます。 クエリを発行する場合は、まず、結果がローカルで使用可能かどうかを確認してから、ストアに対してクエリを実行します。 結果のキャッシュは Entity Framework によって直接サポートされていませんが、ラッピング プロバイダーを使用して第 2 レベルのキャッシュを追加することはできます。 第 2 レベルのキャッシュを持つラッピング プロバイダーの例としては、 [NCache に基づく](https://www.alachisoft.com/ncache/entity-framework.html)Alachisoft のエンティティ フレームワークの第 2 レベル キャッシュがあります。

この第 2 レベル キャッシュの実装は、LINQ 式が評価された (および、不整合化された) 後に行われる挿入された機能であり、クエリ実行プランが計算されるか、第 1 レベルのキャッシュから取得されます。 第 2 レベルのキャッシュは生のデータベース結果のみを格納するため、マテリアライズパイプラインはその後も実行されます。

#### <a name="351-additional-references-for-results-caching-with-the-wrapping-provider"></a>3.5.1 ラッピング プロバイダでの結果キャッシュの追加参照

-   ジュリー・ラーマンは、Windows Server AppFabric キャッシュを使用するようにサンプル ラッピング プロバイダーを更新する方法を含む MSDN の記事「エンティティ フレームワークと Windows Azure の第 2 レベルのキャッシュ」を書いています。[https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)
-   Entity Framework 5 を使用している場合、チームのブログには、Entity Framework 5: のキャッシュ プロバイダーで実行する方法を\<https://docs.microsoft.com/archive/blogs/adonet/ef-caching-with-jarek-kowalskis-provider>説明する投稿があります。 また、プロジェクトへの第 2 レベルキャッシュの自動追加に役立つ T4 テンプレートも含まれています。

## <a name="4-autocompiled-queries"></a>4 自動コンパイルされたクエリ

Entity Framework を使用してデータベースに対してクエリを発行する場合、結果を実際に具体化する前に一連の手順を実行する必要があります。このようなステップの 1 つは、クエリ のコンパイルです。 Entity SQL クエリは自動的にキャッシュされるため、パフォーマンスが良好であると認識されていたため、2 回目または 3 回目に同じクエリを実行すると、プラン コンパイラをスキップしてキャッシュされたプランを使用できます。

エンティティ フレームワーク 5 では、LINQ to Entities クエリの自動キャッシュも導入されました。 過去のエディションでは、パフォーマンスを高速化する CompiledQuery を作成する Entity Framework の一般的な方法でした。 コンパイルクエリを使用せずにキャッシュが自動的に実行されるようになったので、この機能を「自動コンパイルされたクエリ」と呼びます。 クエリ プラン キャッシュとそのメカニズムの詳細については、「クエリ プランのキャッシュ」を参照してください。

Entity Framework は、クエリの再コンパイルが必要な場合を検出し、以前にコンパイルされた場合でもクエリが呼び出されたときに検出します。 クエリを再コンパイルする一般的な条件は次のとおりです。

-   クエリに関連付けられたマージ オプションを変更します。 キャッシュされたクエリは使用されず、プラン コンパイラが再実行され、新しく作成されたプランがキャッシュされます。
-   の値を変更します。 マージオプションを変更するのと同じ効果が得られます。

その他の条件によって、クエリでキャッシュが使用されなくなる場合があります。 一般的な例を次に示します。

-   IEnumerable&lt;T&gt;を使用します。(T 値) が含まれています&lt;&gt;。
-   定数を持つクエリを生成する関数を使用する。
-   マップされていないオブジェクトのプロパティを使用する。
-   クエリを再コンパイルする必要がある別のクエリにリンクする。

### <a name="41-using-ienumerablelttgtcontainslttgtt-value"></a>4.1 IEnumerable&lt;&gt;T を使用する 。T&lt;&gt;(T 値) が含まれています。

エンティティ フレームワークは、IEnumerable&lt;T&gt;を呼び出すクエリをキャッシュしません。コレクション&lt;の&gt;値は揮発性と見なされるため、メモリ内コレクションに対する T (T 値) が含まれます。 次のクエリ例はキャッシュされないので、常にプラン コンパイラによって処理されます。

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var query = context.MyEntities
                    .Where(entity => ids.Contains(entity.Id));

    var results = query.ToList();
    ...
}
```

Contains が実行される IEnumerable のサイズによって、クエリのコンパイル速度や処理速度が決まります。 上記の例のような大規模なコレクションを使用すると、パフォーマンスが大幅に低下する可能性があります。

エンティティ フレームワーク 6 には、IEnumerable&lt;T&gt;の方法に対する最適化が含まれています。クエリ&lt;が&gt;実行されるときに T (T 値) が機能します。 生成される SQL コードは、生成する速度が大幅に速く、読みやすくなり、ほとんどの場合、サーバーで実行速度が速くなります。

### <a name="42-using-functions-that-produce-queries-with-constants"></a>4.2 定数を持つクエリを生成する関数の使用

Skip() 、Take()、Contains() および DefautIfEmpty() LINQ 演算子は、パラメーターを持つ SQL クエリを生成せず、代わりに渡された値を定数として配置します。 このため、クエリが同じであれば、EF スタックとデータベース サーバーの両方でクエリ プラン キャッシュが汚染され、以降のクエリ実行で同じ定数が使用されない限り、再利用されません。 次に例を示します。

``` csharp
var id = 10;
...
using (var context = new MyContext())
{
    var query = context.MyEntities.Select(entity => entity.Id).Contains(id);

    var results = query.ToList();
    ...
}
```

この例では、このクエリが id に対して異なる値で実行されるたびに、クエリは新しいプランにコンパイルされます。

特に、ページングを行う際には、スキップとテイクの使用に注意してください。 EF6 では、これらのメソッドには、キャッシュされたクエリ プランを効率的に再利用できるラムダ オーバーロードがあります。 また、それ以外の場合は、Skip と Take の異なる定数を持つ各クエリが独自のクエリ プラン キャッシュ エントリを取得するため、キャッシュをクリーンに保ちます。

次のコードは、最適ではありませんが、このクラスのクエリを例示するためだけに使用します。

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

この同じコードの高速なバージョンでは、ラムダを使用して Skip を呼び出す必要があります。

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(() => i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

2 番目のスニペットは、クエリが実行されるたびに同じクエリ プランが使用されるため、最大 11% 高速に実行される可能性があります。 さらに、Skip のパラメーターがクロージャにあるため、コードは次のようになります。

``` csharp
var i = 0;
var skippyCustomers = context.Customers.OrderBy(c => c.LastName).Skip(() => i);
for (; i < count; ++i)
{
    var currentCustomer = skippyCustomers.FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

### <a name="43-using-the-properties-of-a-non-mapped-object"></a>4.3 非マップオブジェクトのプロパティの使用

マップされていないオブジェクト型のプロパティをクエリでパラメーターとして使用すると、クエリはキャッシュされません。 次に例を示します。

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();

    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myObject.MyProperty)
                select entity;

   var results = query.ToList();
    ...
}
```

この例では、クラス NonMappedType がエンティティ モデルの一部ではないと仮定します。 このクエリは、マップされていない型を使用せず、クエリのパラメータとしてローカル変数を使用するように簡単に変更できます。

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();
    var myValue = myObject.MyProperty;
    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myValue)
                select entity;

    var results = query.ToList();
    ...
}
```

この場合、クエリはキャッシュされ、クエリ プラン キャッシュの利点を得ることができます。

### <a name="44-linking-to-queries-that-require-recompiling"></a>4.4 再コンパイルが必要なクエリへのリンク

上記と同じ例に従って、再コンパイルが必要なクエリに依存する 2 番目のクエリがある場合は、2 番目のクエリ全体も再コンパイルされます。 このシナリオを例に示します。

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var firstQuery = from entity in context.MyEntities
                        where ids.Contains(entity.Id)
                        select entity;

    var secondQuery = from entity in context.MyEntities
                        where firstQuery.Any(otherEntity => otherEntity.Id == entity.Id)
                        select entity;

    var results = secondQuery.ToList();
    ...
}
```

この例は汎用的ですが、firstQuery へのリンクが原因で secondQuery がキャッシュに入れることができない様子を示しています。 firstQuery が再コンパイルを必要とするクエリでない場合は、secondQuery がキャッシュされていました。

## <a name="5-notracking-queries"></a>5 ノートラッキングクエリ

### <a name="51-disabling-change-tracking-to-reduce-state-management-overhead"></a>5.1 変更追跡を無効にして状態管理のオーバーヘッドを削減する

読み取り専用のシナリオで、オブジェクトを ObjectStateManager に読み込むオーバーヘッドを回避する場合は、"追跡なし" クエリを発行できます。変更履歴はクエリ レベルで無効にできます。

変更の追跡を無効にすると、オブジェクト キャッシュが事実上オフになります。 エンティティを照会する場合、以前に具体化されたクエリ結果を ObjectStateManager からプルすることで、具体化をスキップすることはできません。 同じコンテキストで同じエンティティを繰り返し照会する場合、実際には変更追跡を有効にすることでパフォーマンスの利点が得られる可能性があります。

ObjectContext を使用してクエリを実行する場合、オブジェクト クエリインスタンスと ObjectSet インスタンスは、設定後に MergeOption を記憶し、そのインスタンスに対して作成されたクエリは親クエリの有効な MergeOption を継承します。 DbContext を使用する場合は、DbSet で AsNoTracking() 修飾子を呼び出して追跡を無効にできます。

#### <a name="511-disabling-change-tracking-for-a-query-when-using-dbcontext"></a>5.1.1 DbContext を使用する場合のクエリの変更追跡の無効化

クエリのモードを NoTracking に切り替えるには、クエリ内の AsNoTracking() メソッドへの呼び出しを連結します。 オブジェクトクエリとは異なり、Db コンテキスト API の DbSet クラスと DbQuery クラスには、マージオプションの変更可能なプロパティがありません。

``` csharp
    var productsForCategory = from p in context.Products.AsNoTracking()
                                where p.Category.CategoryName == selectedCategory
                                select p;


```

#### <a name="512-disabling-change-tracking-at-the-query-level-using-objectcontext"></a>5.1.2 ObjectContext を使用したクエリ レベルでの変更追跡の無効化

``` csharp
    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;

    ((ObjectQuery)productsForCategory).MergeOption = MergeOption.NoTracking;
```

#### <a name="513-disabling-change-tracking-for-an-entire-entity-set-using-objectcontext"></a>5.1.3 ObjectContext を使用したエンティティ セット全体の変更追跡の無効化

``` csharp
    context.Products.MergeOption = MergeOption.NoTracking;

    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;
```

### <a name="52test-metrics-demonstrating-the-performance-benefit-of-notracking-queries"></a>5.2 NoTracking クエリのパフォーマンス上の利点を示すテスト メトリック

このテストでは、追跡と Navision モデルの NoTracking クエリを比較して ObjectStateManager を満たすコストを調べています。 Navision モデルの説明と実行されたクエリの種類については、付録を参照してください。 このテストでは、クエリのリストを反復処理し、それぞれを 1 回実行します。 テストの 2 つのバリエーションを実行しました(1 回は NoTracking クエリで、1 回は既定のマージ オプション"AppendOnly") を使用しました。 各バリエーションを3回実行し、ランの平均値を取りました。 テストの間に、SQL Server のクエリ キャッシュをクリアし、次のコマンドを実行して tempdb を圧縮します。

1.  DBCC DROPCLEANBUFFERS
2.  DBCC FREEPROCCACHE
3.  データベースを圧縮します。

テスト結果、3回の実行の中央値:

|                        | 追跡なし – ワーキング セット | トラッキングなし – 時間 | 追加のみ - ワーキング セット | 追加のみ – 時間 |
|:-----------------------|:--------------------------|:-------------------|:--------------------------|:-------------------|
| **エンティティ フレームワーク 5** | 460361728                 | 1163536 ミリ秒         | 596545536                 | 1273042 ミリ秒         |
| **Entity Framework 6** | 647127040                 | 190228ミリ秒          | 832798720                 | 195521ミリ秒          |

エンティティ フレームワーク 5 は、実行の最後に Entity Framework 6 よりも小さいメモリ フットプリントを持つことになります。 Entity Framework 6 によって消費される追加のメモリは、新しい機能とパフォーマンスを向上する追加のメモリ構造とコードの結果です。

また、ObjectStateManager を使用する場合のメモリ フットプリントにも明確な違いがあります。 Entity Framework 5 は、データベースから具体化したすべてのエンティティを追跡するときに、フットプリントを 30% 増加しました。 エンティティ フレームワーク 6 では、フットプリントが 28% 増加しました。

時間の面では、Entity Framework 6 は大きなマージンでこのテストでエンティティ フレームワーク 5 を上回ります。 エンティティ フレームワーク 6 は、エンティティ フレームワーク 5 で消費された時間の約 16% でテストを完了しました。 さらに、エンティティ フレームワーク 5 は、ObjectStateManager が使用されているときに完了するのに 9% 時間がかかります。 これに対し、エンティティ フレームワーク 6 は、ObjectStateManager を使用する場合に 3% 以上の時間を使用しています。

## <a name="6-query-execution-options"></a>6 クエリ実行オプション

エンティティ フレームワークには、クエリを実行するいくつかの方法があります。 次のオプションを見て、それぞれの長所と短所を比較し、パフォーマンス特性を調べます。

-   エンティティへの LINQ。
-   エンティティへの追跡 LINQ がありません。
-   エンティティ SQL をオブジェクト クエリに対して実行します。
-   エンティティ コマンドを介したエンティティ SQL。
-   ストアクエリを実行します。
-   クエリを実行します。
-   コンパイルされたクエリ。

### <a name="61-linq-to-entities-queries"></a>6.1 エンティティへの LINQ クエリ

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

**長所**

-   CUD 操作に適しています。
-   完全に具体化されたオブジェクト。
-   プログラミング言語に組み込まれた構文で記述するのが最も簡単です。
-   良いパフォーマンス。

**短所**

-   次のような特定の技術的な制限事項:
    -   OUTER JOIN クエリに DefaultIfEmpty を使用するパターンは、Entity SQL の単純な OUTER JOIN ステートメントよりも複雑なクエリになります。
    -   一般的なパターンマッチングでは LIKE を使用できません。

### <a name="62-no-tracking-linq-to-entities-queries"></a>6.2 エンティティへの LINQ クエリの追跡なし

コンテキストが ObjectContext を派生させる場合:

``` csharp
context.Products.MergeOption = MergeOption.NoTracking;
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

コンテキストが DbContext を派生する場合:

``` csharp
var q = context.Products.AsNoTracking()
                        .Where(p => p.Category.CategoryName == "Beverages");
```

**長所**

-   通常の LINQ クエリに対するパフォーマンスが向上しました。
-   完全に具体化されたオブジェクト。
-   プログラミング言語に組み込まれた構文で記述するのが最も簡単です。

**短所**

-   CUD 操作には適していません。
-   次のような特定の技術的な制限事項:
    -   OUTER JOIN クエリに DefaultIfEmpty を使用するパターンは、Entity SQL の単純な OUTER JOIN ステートメントよりも複雑なクエリになります。
    -   一般的なパターンマッチングでは LIKE を使用できません。

NoTracking が指定されていない場合でも、スカラー プロパティをプロジェクトするクエリは追跡されないことに注意してください。 次に例を示します。

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages").Select(p => new { p.ProductName });
```

この特定のクエリでは、NoTracking であることが明示的に指定されていませんが、オブジェクト状態マネージャーに認識されている型を具体化していないので、具体化された結果は追跡されません。

### <a name="63-entity-sql-over-an-objectquery"></a>6.3 オブジェクトクエリに対するエンティティSQL

``` csharp
ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
```

**長所**

-   CUD 操作に適しています。
-   完全に具体化されたオブジェクト。
-   クエリ プランのキャッシュをサポートします。

**短所**

-   言語に組み込まれたクエリ構造よりもユーザー エラーが発生しやすいテキスト クエリ文字列が含まれます。

### <a name="64-entity-sql-over-an-entity-command"></a>6.4 エンティティ コマンド経由のエンティティ SQL

``` csharp
EntityCommand cmd = eConn.CreateCommand();
cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
{
    while (reader.Read())
    {
        // manually 'materialize' the product
    }
}
```

**長所**

-   .NET 4.0 でクエリ プランのキャッシュをサポートします (.NET 4.5 の他のすべてのクエリの種類でプラン キャッシュがサポートされています)。

**短所**

-   言語に組み込まれたクエリ構造よりもユーザー エラーが発生しやすいテキスト クエリ文字列が含まれます。
-   CUD 操作には適していません。
-   結果は自動的に具体化されず、データ リーダーから読み取る必要があります。

### <a name="65-sqlquery-and-executestorequery"></a>6.5 SqlQuery と実行ストアクエリ

データベース上の SqlQuery:

``` csharp
// use this to obtain entities and not track them
var q1 = context.Database.SqlQuery<Product>("select * from products");
```

データベースセットの SqlQuery:

``` csharp
// use this to obtain entities and have them tracked
var q2 = context.Products.SqlQuery("select * from products");
```

エクセグイテストアクエリ:

``` csharp
var beverages = context.ExecuteStoreQuery<Product>(
@"     SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued, P.DiscontinuedDate
       FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
       WHERE        (C.CategoryName = 'Beverages')"
);
```

**長所**

-   プラン コンパイラがバイパスされるため、一般に最も高速なパフォーマンスです。
-   完全に具体化されたオブジェクト。
-   DBSet から使用する場合の CUD 操作に適しています。

**短所**

-   クエリはテキスト形式でエラーが発生しやすい。
-   クエリは、概念セマンティクスではなくストア セマンティクスを使用して、特定のバックエンドに関連付けられています。
-   継承が存在する場合、手作りのクエリは、要求された型のマッピング条件を考慮する必要があります。

### <a name="66-compiledquery"></a>6.6 コンパイル済みクエリ

``` csharp
private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
    (NorthwindEntities context, string categoryName) =>
        context.Products.Where(p => p.Category.CategoryName == categoryName)
        );
…
var q = context.InvokeProductsForCategoryCQ("Beverages");
```

**長所**

-   通常の LINQ クエリに比して最大 7% のパフォーマンス向上を実現します。
-   完全に具体化されたオブジェクト。
-   CUD 操作に適しています。

**短所**

-   複雑さとプログラミングのオーバーヘッドが増加します。
-   コンパイル済みクエリの上で作成すると、パフォーマンスの向上が失われます。
-   一部の LINQ クエリは、匿名型のプロジェクションなど、CompiledQuery として記述できません。

### <a name="67-performance-comparison-of-different-query-options"></a>6.7 異なるクエリオプションのパフォーマンス比較

コンテキストの作成がタイミングを合わない単純なマイクロベンチマークがテストに入れられました。 制御された環境で、キャッシュされていないエンティティのセットに対して 5000 回のクエリを測定しました。 これらの数値は、アプリケーションによって生成された実際の数値を反映するのではなく、異なるクエリオプションがリンゴとリンゴを比較する場合、新しいコンテキストを作成するコストを除いて、パフォーマンスの違いの程度を非常に正確に測定します。

| EF  | テスト                                 | 時間 (ミリ秒) | メモリ   |
|:----|:-------------------------------------|:----------|:---------|
| EF5 | オブジェクトコンテキスト ESQL                   | 2414      | 38801408 |
| EF5 | オブジェクト コンテキスト Linq クエリ             | 2692      | 38277120 |
| EF5 | クエリの追跡なし     | 2818      | 41840640 |
| EF5 | クエリ                 | 2930      | 41771008 |
| EF5 | オブジェクト コンテキスト Linq クエリ追跡なし | 3013      | 38412288 |
|     |                                      |           |          |
| EF6 | オブジェクトコンテキスト ESQL                   | 2059      | 46039040 |
| EF6 | オブジェクト コンテキスト Linq クエリ             | 3,074      | 45248512 |
| EF6 | クエリの追跡なし     | 3125      | 47575040 |
| EF6 | クエリ                 | 3420      | 47652864 |
| EF6 | オブジェクト コンテキスト Linq クエリ追跡なし | 3593      | 45260800 |

![EF5マイクロベンチマーク、5000の暖かい反復](~/ef6/media/ef5micro5000warm.png)

![EF6マイクロベンチマーク、5000の暖かい反復](~/ef6/media/ef6micro5000warm.png)

マイクロベンチマークは、コードの小さな変更に非常に敏感です。 この場合、Entity Framework 5 と Entity Framework 6 のコストの差は[、傍受](~/ef6/fundamentals/logging-and-interception.md)と[トランザクションの改善](~/ef6/saving/transactions.md)が加えたためです。 しかし、これらのマイクロベンチマークの数値は、Entity Framework が行うことの非常に小さな断片に増幅されたビジョンです。 実際のウォーム クエリのシナリオでは、Entity Framework 5 から Entity Framework 6 にアップグレードする場合にパフォーマンスの低下が発生する必要があります。

さまざまなクエリ オプションの実際のパフォーマンスを比較するために、別のクエリ オプションを使用してカテゴリ名が "Beverages" であるすべての製品を選択する 5 つの個別のテスト バリエーションを作成しました。 各イテレーションには、コンテキストを作成するコストと、返されたすべてのエンティティを具体化するコストが含まれます。 10 回の反復は、1000 回の時間指定反復の合計を取る前に、時間がとらずに実行されます。 表示される結果は、各テストの5回の実行から取られた中央値の実行です。 詳細については、テストのコードを含む付録 B を参照してください。

| EF  | テスト                                        | 時間 (ミリ秒) | メモリ   |
|:----|:--------------------------------------------|:----------|:---------|
| EF5 | オブジェクトコンテキスト エンティティ コマンド                | 621       | 39350272 |
| EF5 | データベースに対する Sql クエリ             | 825       | 37519360 |
| EF5 | オブジェクト コンテキスト ストア クエリ                   | 878       | 39460864 |
| EF5 | オブジェクト コンテキスト Linq クエリ追跡なし        | 969       | 38293504 |
| EF5 | オブジェクト クエリを使用した ObjectContext エンティティの SQL | 1089      | 38981632 |
| EF5 | オブジェクト コンテキスト コンパイル済みクエリ                | 1099      | 38682624 |
| EF5 | オブジェクト コンテキスト Linq クエリ                    | 1152      | 38178816 |
| EF5 | クエリの追跡なし            | 1208      | 41803776 |
| EF5 | Db コンテキスト SQL クエリ                | 1414      | 37982208 |
| EF5 | クエリ                        | 1574      | 41738240 |
|     |                                             |           |          |
| EF6 | オブジェクトコンテキスト エンティティ コマンド                | 480       | 47247360 |
| EF6 | オブジェクト コンテキスト ストア クエリ                   | 493       | 46739456 |
| EF6 | データベースに対する Sql クエリ             | 614       | 41607168 |
| EF6 | オブジェクト コンテキスト Linq クエリ追跡なし        | 684       | 46333952 |
| EF6 | オブジェクト クエリを使用した ObjectContext エンティティの SQL | 767       | 48865280 |
| EF6 | オブジェクト コンテキスト コンパイル済みクエリ                | 788       | 48467968 |
| EF6 | クエリの追跡なし            | 878       | 47554560 |
| EF6 | オブジェクト コンテキスト Linq クエリ                    | 953       | 47632384 |
| EF6 | Db コンテキスト SQL クエリ                | 1023      | 41992192 |
| EF6 | クエリ                        | 1290      | 47529984 |


![EF5 ウォーム クエリ 1000 回の反復処理](~/ef6/media/ef5warmquery1000.png)

![EF6 ウォーム クエリ 1000 回の反復処理](~/ef6/media/ef6warmquery1000.png)

> [!NOTE]
> 完全性を高めるには、エンティティコマンドでエンティティSQLクエリを実行するバリエーションが含まれています。 ただし、このようなクエリでは結果が具体化されないため、比較は必ずしもリンゴからリンゴへの比較ではありません。 このテストには、比較をより公平にしようと具体化する近似が含まれます。

このエンド ツー エンドのケースでは、Entity Framework 6 は、はるかに軽い DbContext 初期化と高速なメタデータコレクション&lt;T&gt;検索を含む、スタックのいくつかの部分で行われたパフォーマンスの向上により、Entity Framework 5 を上回ります。

## <a name="7-design-time-performance-considerations"></a>7 設計時のパフォーマンスに関する考慮事項

### <a name="71-inheritance-strategies"></a>7.1 継承戦略

Entity Framework を使用する場合のもう 1 つのパフォーマンス上の考慮事項は、使用する継承戦略です。 Entity Framework では、継承の 3 つの基本的な種類とその組み合わせをサポートしています。

-   階層ごとのテーブル (TPH) – 各継承セットが、行内で表されている階層内の特定の型を示す識別子列を持つテーブルにマップされます。
-   テーブル /タイプ (TPT) – 各型がデータベース内に独自のテーブルを持つ場所。子テーブルは、親テーブルに含まれていない列のみを定義します。
-   クラスごとのテーブル (TPC) – 各型がデータベース内で独自の完全なテーブルを持つ場所。子テーブルは、親タイプで定義されたフィールドを含むすべてのフィールドを定義します。

モデルで TPT 継承を使用する場合、生成されるクエリは他の継承方法で生成されるクエリよりも複雑になり、ストアでの実行時間が長くなる可能性があります。TPT モデルに対するクエリの生成や、結果のオブジェクトの具体化には、通常時間がかかります。

MSDN ブログ記事「エンティティ フレームワークで TPT (テーブル/型) 継承を使用する場合\<https://docs.microsoft.com/archive/blogs/adonet/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework>のパフォーマンスに関する考慮事項」を参照してください。

#### <a name="711-avoiding-tpt-in-model-first-or-code-first-applications"></a>7.1.1 モデルファーストまたはコードファーストアプリケーションでの TPT の回避

TPT スキーマを持つ既存のデータベースに対してモデルを作成する場合、多くのオプションはありません。 ただし、モデルファーストまたはコードファーストを使用してアプリケーションを作成する場合は、パフォーマンス上の問題に対して TPT の継承を避ける必要があります。

エンティティ デザイナー ウィザードでモデルファーストを使用すると、モデル内の任意の継承の TPT が取得されます。 モデルファーストを使用して TPH 継承戦略に切り替える場合は、Visual Studio ギャラリー ( . \< http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/>)) から入手できる "エンティティ デザイナー データベース生成パワー パック" を使用できます。

Code First を使用して継承を使用してモデルのマッピングを構成する場合、EF は既定で TPH を使用するため、継承階層内のすべてのエンティティが同じテーブルにマップされます。 詳細については、MSDN マガジン ( )[http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx)の「エンティティ フレームワーク 4.1 のコード最初のコード」の「Fluent API を使用したマッピング」を参照してください。

### <a name="72-upgrading-from-ef4-to-improve-model-generation-time"></a>7.2 モデル生成時間を改善するために EF4 からアップグレードする

モデルのストアレイヤー (SSDL) を生成するアルゴリズムに対する SQL Server 固有の機能強化は、エンティティ フレームワーク 5 と 6 で、および Visual Studio 2010 SP1 がインストールされている場合のエンティティ フレームワーク 4 の更新プログラムとして利用できます。 次のテスト結果は、非常に大きなモデル(この場合は Navision モデル)を生成するときの改善を示しています。 詳細については、付録 C を参照してください。

モデルには、1005 個のエンティティ セットと 4227 個のアソシエーション セットが含まれています。

| 構成                              | 消費時間の内訳                                                                                                                                               |
|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| ビジュアル スタジオ 2010、エンティティ フレームワーク 4     | SSDLジェネレーション:2時間27分 <br/> マッピング生成: 1 秒 <br/> CSDL ジェネレーション: 1 秒 <br/> オブジェクトレイヤの生成: 1 秒 <br/> ビュー生成:2時間14分 |
| ビジュアル スタジオ 2010 SP1、エンティティ フレームワーク 4 | SSDL 世代: 1 秒 <br/> マッピング生成: 1 秒 <br/> CSDL ジェネレーション: 1 秒 <br/> オブジェクトレイヤの生成: 1 秒 <br/> ビュー生成:1時間53分   |
| ビジュアル スタジオ 2013、エンティティ フレームワーク 5     | SSDL 世代: 1 秒 <br/> マッピング生成: 1 秒 <br/> CSDL ジェネレーション: 1 秒 <br/> オブジェクトレイヤの生成: 1 秒 <br/> ビュー生成:65分    |
| ビジュアル スタジオ 2013、エンティティ フレームワーク 6     | SSDL 世代: 1 秒 <br/> マッピング生成: 1 秒 <br/> CSDL ジェネレーション: 1 秒 <br/> オブジェクトレイヤの生成: 1 秒 <br/> ビューの生成:28秒。   |


SSDL を生成する場合、クライアント開発マシンがサーバーから結果が返されるまでアイドル状態を待機している間、負荷は SQL Server に費やされます。 DBAは、この改善を特に理解すべきである。 また、モデル生成のコスト全体がビュージェネレーションで本質的に発生していることも注目に値します。

### <a name="73-splitting-large-models-with-database-first-and-model-first"></a>7.3 データベースファーストとモデルファーストでの大規模モデルの分割

モデルサイズが大きくなると、デザイナーの表面が煩雑になり、使いにくくなります。 通常、300 を超えるエンティティを持つモデルは、デザイナーを効果的に使用するには大きすぎると考えます。 次のブログ記事では、大きなモデルを分割するためのいくつかのオプション\<https://docs.microsoft.com/archive/blogs/adonet/working-with-large-models-in-entity-framework-part-2>について説明します。

投稿は、Entity Framework の最初のバージョンのために書かれたが、手順は依然として適用されます。

### <a name="74-performance-considerations-with-the-entity-data-source-control"></a>7.4 エンティティ データ ソース コントロールのパフォーマンスに関する考慮事項

EntityDataSource コントロールを使用する Web アプリケーションのパフォーマンスが大幅に低下するマルチスレッドパフォーマンスおよびストレス テストのケースを見てきました。 根本的な原因は、EntityDataSource が Web アプリケーションによって参照されるアセンブリで繰り返し MetadataWorkspace.LoadFromAssembly を呼び出して、エンティティとして使用される型を検出することです。

ソリューションは、エンティティデータソースのコンテキストタイプ名を派生 ObjectContext クラスの型名に設定することです。 これにより、すべての参照アセンブリをスキャンしてエンティティ型をスキャンするメカニズムがオフになります。

ContextTypeName フィールドを設定すると、.NET 4.0 の EntityDataSource がリフレクションを介してアセンブリから型を読み込むことができない場合に ReflectionTypeLoadException をスローする機能上の問題も回避できます。 この問題は.NET 4.5で修正されました。

### <a name="75-poco-entities-and-change-tracking-proxies"></a>7.5 POCO エンティティと変更追跡プロキシ

Entity Framework では、データ クラス自体に変更を加えずに、データ モデルと共にカスタム データ クラスを使用できます。 つまり、既存のドメイン オブジェクトなどの POCO ("plain-old" CLR object) をデータ モデルで使用できます。 これらの POCO データ クラス (永続性に依存していないオブジェクトとも呼ばれます) は、データ モデルで定義されているエンティティにマップされ、エンティティ データ モデル ツールによって生成されるエンティティ型と同じクエリ、挿入、更新、および削除動作のほとんどをサポートします。

Entity Framework は、POCO エンティティの遅延読み込みや自動変更追跡などの機能を有効にする場合に使用される、POCO 型から派生したプロキシ クラスを作成することもできます。 POCO クラスは、次の説明に従って、Entity Framework でプロキシを使用[http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx)できるようにするための特定の要件を満たす必要があります。

チャンス追跡プロキシは、エンティティのプロパティのいずれかが値を変更するたびにオブジェクト状態マネージャーに通知するので、Entity Framework はエンティティの実際の状態を常に認識します。 これは、プロパティの setter メソッドの本体に通知イベントを追加し、オブジェクト状態マネージャーにそのようなイベントを処理させることによって行われます。 プロキシ エンティティの作成は、通常、Entity Framework によって作成された一連のイベントが追加されているため、非プロキシ POCO エンティティを作成するよりもコストがかかることに注意してください。

POCO エンティティに変更追跡プロキシがない場合、エンティティの内容を以前に保存した状態のコピーと比較して変更が検出されます。 この深い比較は、コンテキストに多くのエンティティがある場合、またはエンティティに非常に大量のプロパティがある場合、最後の比較が行われた後に変更されていない場合でも、時間のかかるプロセスになります。

要約すると、変更追跡プロキシの作成時にパフォーマンスの低下が発生しますが、エンティティに多くのプロパティがある場合や、モデルに多数のエンティティがある場合に、変更の追跡によって変更検出プロセスの速度を上げやすくすることができます。 エンティティの量があまり増えないプロパティが少ないエンティティの場合、変更追跡プロキシを使用することはあまり役に立たない場合があります。

## <a name="8-loading-related-entities"></a>8 関連エンティティの読み込み

### <a name="81-lazy-loading-vs-eager-loading"></a>8.1 レイジーロードと一括ロード

Entity Framework では、ターゲット エンティティに関連するエンティティを読み込むさまざまな方法が用意されています。 たとえば、製品を照会する場合、関連する注文をオブジェクト状態マネージャーに読み込む方法は異なります。 パフォーマンスの観点から、関連エンティティを読み込む際に考慮すべき最大の問題は、遅延読み込みと一括読み込みのどちらを使用するかです。

一括読み込みを使用すると、関連エンティティがターゲット エンティティ セットと共に読み込まれます。 クエリで Include ステートメントを使用して、取り込む関連エンティティを指定します。

遅延読み込みを使用する場合、最初のクエリはターゲット エンティティ セットのみを持ち込みます。 ただし、ナビゲーション プロパティにアクセスするたびに、ストアに対して別のクエリが発行され、関連エンティティが読み込まれます。

エンティティが読み込まれると、そのエンティティに対するそれ以降のクエリは、遅延読み込みまたは一括読み込みのどちらを使用しているかにかかわらず、オブジェクト状態マネージャーから直接読み込まれます。

### <a name="82-how-to-choose-between-lazy-loading-and-eager-loading"></a>8.2 遅延読み込みと一括読み込みのどちらかを選択する方法

重要なことは、アプリケーションに対して正しい選択を行うことができるように、遅延読み込みと一括読み込みの違いを理解することです。 これは、大きなペイロードを含む可能性がある単一の要求と、データベースに対する複数の要求間のトレードオフを評価するのに役立ちます。 アプリケーションの一部で一括読み込みを使用し、他の部分で遅延読み込みを行う方が適切な場合があります。

フードの下で何が起こっているかの例として、英国に住んでいる顧客とその注文数を照会するとします。

**一括読み込みの使用**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var ukCustomers = context.Customers.Include(c => c.Orders).Where(c => c.Address.Country == "UK");
    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

**遅延読み込みの使用**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    context.ContextOptions.LazyLoadingEnabled = true;

    //Notice that the Include method call is missing in the query
    var ukCustomers = context.Customers.Where(c => c.Address.Country == "UK");

    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

一括読み込みを使用する場合は、すべての顧客とすべての注文を返す単一のクエリを発行します。 ストア コマンドは次のようになります。

``` SQL
SELECT
[Project1].[C1] AS [C1],
[Project1].[CustomerID] AS [CustomerID],
[Project1].[CompanyName] AS [CompanyName],
[Project1].[ContactName] AS [ContactName],
[Project1].[ContactTitle] AS [ContactTitle],
[Project1].[Address] AS [Address],
[Project1].[City] AS [City],
[Project1].[Region] AS [Region],
[Project1].[PostalCode] AS [PostalCode],
[Project1].[Country] AS [Country],
[Project1].[Phone] AS [Phone],
[Project1].[Fax] AS [Fax],
[Project1].[C2] AS [C2],
[Project1].[OrderID] AS [OrderID],
[Project1].[CustomerID1] AS [CustomerID1],
[Project1].[EmployeeID] AS [EmployeeID],
[Project1].[OrderDate] AS [OrderDate],
[Project1].[RequiredDate] AS [RequiredDate],
[Project1].[ShippedDate] AS [ShippedDate],
[Project1].[ShipVia] AS [ShipVia],
[Project1].[Freight] AS [Freight],
[Project1].[ShipName] AS [ShipName],
[Project1].[ShipAddress] AS [ShipAddress],
[Project1].[ShipCity] AS [ShipCity],
[Project1].[ShipRegion] AS [ShipRegion],
[Project1].[ShipPostalCode] AS [ShipPostalCode],
[Project1].[ShipCountry] AS [ShipCountry]
FROM ( SELECT
      [Extent1].[CustomerID] AS [CustomerID],
       [Extent1].[CompanyName] AS [CompanyName],
       [Extent1].[ContactName] AS [ContactName],
       [Extent1].[ContactTitle] AS [ContactTitle],
       [Extent1].[Address] AS [Address],
       [Extent1].[City] AS [City],
       [Extent1].[Region] AS [Region],
       [Extent1].[PostalCode] AS [PostalCode],
       [Extent1].[Country] AS [Country],
       [Extent1].[Phone] AS [Phone],
       [Extent1].[Fax] AS [Fax],
      1 AS [C1],
       [Extent2].[OrderID] AS [OrderID],
       [Extent2].[CustomerID] AS [CustomerID1],
       [Extent2].[EmployeeID] AS [EmployeeID],
       [Extent2].[OrderDate] AS [OrderDate],
       [Extent2].[RequiredDate] AS [RequiredDate],
       [Extent2].[ShippedDate] AS [ShippedDate],
       [Extent2].[ShipVia] AS [ShipVia],
       [Extent2].[Freight] AS [Freight],
       [Extent2].[ShipName] AS [ShipName],
       [Extent2].[ShipAddress] AS [ShipAddress],
       [Extent2].[ShipCity] AS [ShipCity],
       [Extent2].[ShipRegion] AS [ShipRegion],
       [Extent2].[ShipPostalCode] AS [ShipPostalCode],
       [Extent2].[ShipCountry] AS [ShipCountry],
      CASE WHEN ([Extent2].[OrderID] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C2]
      FROM  [dbo].[Customers] AS [Extent1]
      LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID]
      WHERE N'UK' = [Extent1].[Country]
)  AS [Project1]
ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC
```

遅延読み込みを使用する場合は、最初に次のクエリを発行します。

``` SQL
SELECT
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[CompanyName] AS [CompanyName],
[Extent1].[ContactName] AS [ContactName],
[Extent1].[ContactTitle] AS [ContactTitle],
[Extent1].[Address] AS [Address],
[Extent1].[City] AS [City],
[Extent1].[Region] AS [Region],
[Extent1].[PostalCode] AS [PostalCode],
[Extent1].[Country] AS [Country],
[Extent1].[Phone] AS [Phone],
[Extent1].[Fax] AS [Fax]
FROM [dbo].[Customers] AS [Extent1]
WHERE N'UK' = [Extent1].[Country]
```

顧客の Orders ナビゲーション プロパティにアクセスするたびに、次のような別のクエリがストアに対して発行されます。

``` SQL
exec sp_executesql N'SELECT
[Extent1].[OrderID] AS [OrderID],
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[EmployeeID] AS [EmployeeID],
[Extent1].[OrderDate] AS [OrderDate],
[Extent1].[RequiredDate] AS [RequiredDate],
[Extent1].[ShippedDate] AS [ShippedDate],
[Extent1].[ShipVia] AS [ShipVia],
[Extent1].[Freight] AS [Freight],
[Extent1].[ShipName] AS [ShipName],
[Extent1].[ShipAddress] AS [ShipAddress],
[Extent1].[ShipCity] AS [ShipCity],
[Extent1].[ShipRegion] AS [ShipRegion],
[Extent1].[ShipPostalCode] AS [ShipPostalCode],
[Extent1].[ShipCountry] AS [ShipCountry]
FROM [dbo].[Orders] AS [Extent1]
WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'AROUT'
```

詳細については、「[関連オブジェクトのロード](https://msdn.microsoft.com/library/bb896272.aspx)」を参照してください。

#### <a name="821-lazy-loading-versus-eager-loading-cheat-sheet"></a>8.2.1 レイジーローディング対一括ローディングチートシート

一括読み込みと遅延読み込みのどちらを選択しても、万能というものはありません。 十分な情報に基づいた意思決定を行うことができるように、両方の戦略の違いを理解してみてください。また、コードが次のいずれかのシナリオに適合するかどうかも検討してください。

| シナリオ                                                                    | 私たちの提案                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|:----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 取得したエンティティから多数のナビゲーション プロパティにアクセスする必要がありますか。 | **いいえ**- 両方のオプションはおそらく行います。 ただし、クエリが持ち込んでいるペイロードが大きすぎない場合は、オブジェクトを具体化するために必要なネットワークラウンド トリップが少なくて済むため、一括読み込みを使用するとパフォーマンス上の利点が生じる可能性があります。 <br/> <br/> **はい**- エンティティから多数のナビゲーション プロパティにアクセスする必要がある場合は、一括読み込みでクエリ内の複数の include ステートメントを使用してアクセスします。 含めるエンティティが多いほど、クエリが返すペイロードは大きくなります。 クエリに 3 つ以上のエンティティを含めたら、遅延読み込みに切り替えることを検討してください。 |
| 実行時に必要なデータを正確に把握していますか。                   | **いいえ**- 遅延読み込みはあなたのために良くなります。 そうしないと、必要のないデータをクエリすることになります。 <br/> <br/> **はい**- 熱心な読み込みはおそらくあなたの最善の策です。セット全体をより速く読み込むのに役立ちます。 クエリで大量のデータをフェッチする必要があり、この処理が遅すぎる場合は、代わりに遅延読み込みを試してください。                                                                                                                                                                                                                                                       |
| コードはデータベースから遠く離れていますか? (ネットワーク遅延の増加)  | **いいえ**- ネットワークの遅延が問題でない場合、遅延読み込みを使用するとコードが単純化される場合があります。 アプリケーションのトポロジが変更される可能性があるため、データベースの近さを当然のことと考えないでください。 <br/> <br/> **はい**- ネットワークが問題の場合、自分のシナリオに適したものを決定できるのは自分だけです。 一般的に、一般に、ラウンド トリップが少なくて済むため、一般的に、高い負荷が得られるでしょう。                                                                                                                                                                                                      |


#### <a name="822-performance-concerns-with-multiple-includes"></a>8.2.2 複数のインクルードを含むパフォーマンス上の懸念

サーバー応答時間の問題に関するパフォーマンスに関する質問が聞こえると、問題の原因は複数の Include ステートメントを使用したクエリを頻繁に行う場合です。 関連エンティティをクエリに含めるのは強力ですが、その範囲で何が起こっているのかを理解することが重要です。

複数の Include ステートメントを含むクエリが内部プラン のコンパイラを使用して store コマンドを生成するには、比較的時間がかかります。 この時間の大半は、結果のクエリを最適化するために費やされます。 生成されたストア コマンドには、マッピングに応じて、各インクルードの外部結合またはユニオンが含まれます。 このようなクエリは、データベースから接続された大きなグラフを 1 つのペイロードに取り込み、特にペイロードに多くの冗長性がある場合 (たとえば、複数のレベルの Include を使用して一対多方向のアソシエーションを走査する場合) に帯域幅の問題を発生させます。

クエリが過度に大きなペイロードを返している場合は、ToTraceString を使用してクエリの基になる TSQL にアクセスし、SQL Server 管理スタジオでストア コマンドを実行してペイロード サイズを確認することで確認できます。 このような場合は、必要なデータを取り込むためだけに、クエリ内の Include ステートメントの数を減らしてみてください。 または、クエリを小さな一連のサブクエリに分割することもできます。

**クエリをブレークする前に、次の手順を実行します。**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var customers = from c in context.Customers.Include(c => c.Orders)
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

**クエリをブレークした後:**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var orders = from o in context.Orders
                 where o.Customer.LastName.StartsWith(lastNameParameter)
                 select o;

    orders.Load();

    var customers = from c in context.Customers
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

これは、コンテキストが ID 解決と関連付けの修正を自動的に実行する能力を利用するため、追跡対象のクエリでのみ機能します。

遅延読み込みと同様に、トレードオフは小さいペイロードに対するクエリが多くなります。 個々のプロパティのプロジェクションを使用して、各エンティティから必要なデータのみを明示的に選択することもできますが、この場合はエンティティをロードせず、更新はサポートされません。

#### <a name="823-workaround-to-get-lazy-loading-of-properties"></a>8.2.3 プロパティの遅延読み込みを取得する回避策

エンティティ フレームワークは現在、スカラープロパティまたは複雑なプロパティの遅延読み込みをサポートしていません。 ただし、BLOB などの大きなオブジェクトを含むテーブルがある場合は、テーブル分割を使用して、大きなプロパティを別のエンティティに分割できます。 たとえば、varbinary 写真列を含む Product テーブルがあるとします。 クエリでこのプロパティに頻繁にアクセスする必要がない場合は、テーブル分割を使用して、通常必要なエンティティの部分のみを取り込むことができます。 製品写真を表すエンティティは、明示的に必要な場合にのみ読み込まれます。

テーブル分割を有効にする方法を示す良いリソースは、Gil Finkの「エンティティ フレームワークでのテーブル分割\<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx>」ブログ記事です。

## <a name="9-other-considerations"></a>9 その他の考慮事項

### <a name="91-server-garbage-collection"></a>9.1 サーバ のガベージ コレクション

ユーザーによっては、ガベージ コレクタが適切に構成されていない場合に、期待する並列処理を制限するリソースの競合が発生する場合があります。 EF がマルチスレッドのシナリオで使用される場合、またはサーバー側のシステムに似たアプリケーションで使用される場合は、必ずサーバー のガベージ コレクションを有効にします。 これは、アプリケーション構成ファイルの単純な設定を使用して行われます。

``` xml
<?xmlversion="1.0" encoding="utf-8" ?>
<configuration>
        <runtime>
               <gcServer enabled="true" />
        </runtime>
</configuration>
```

これにより、スレッドの競合が減少し、CPU 飽和シナリオではスループットが最大 30% 向上します。 一般的に、サーバー のガベージ コレクションだけでなく、従来のガベージ コレクション (UI とクライアント側のシナリオに合わせて調整する) を使用して、アプリケーションがどのように動作するかを常にテストする必要があります。

### <a name="92-autodetectchanges"></a>9.2 自動検出の変更

前述したように、Entity Framework は、オブジェクト キャッシュに多数のエンティティがある場合にパフォーマンスの問題を表示する可能性があります。 追加、削除、検索、エントリ、SaveChanges などの特定の操作は、オブジェクト キャッシュの大きさに基づいて大量の CPU を消費する可能性がある DetectChanges の呼び出しをトリガーします。 その理由は、オブジェクトキャッシュとオブジェクト状態マネージャが、コンテキストに対して実行される各操作についてできるだけ同期を保ち、生成されたデータがさまざまなシナリオで正しいことが保証されるためです。

一般的には、アプリケーションの全期間で Entity Framework の自動変更検出を有効にすることをお勧めします。 シナリオが CPU 使用率の高さによって悪影響を受け、プロファイルが原因が DetectChanges の呼び出しであることを示している場合は、コードの重要部分で自動検出の変更を一時的にオフにすることを検討してください。

``` csharp
try
{
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    ...
}
finally
{
    context.Configuration.AutoDetectChangesEnabled = true;
}
```

自動検出の変更を無効にする前に、エンティティ フレームワークがエンティティで行われている変更に関する特定の情報を追跡する能力を失う可能性があることを理解することをお勧めします。 正しく処理されない場合、アプリケーションでデータの不整合が発生する可能性があります。 自動検出の変更をオフにする方法の詳細については\<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/>、 を参照してください。

### <a name="93-context-per-request"></a>9.3 要求ごとのコンテキスト

Entity Framework のコンテキストは、最も最適なパフォーマンス エクスペリエンスを提供するために、短時間のインスタンスとして使用することを意図しています。 コンテキストは短命で破棄されると予想されるため、可能な限り、非常に軽量でメタデータを再利用するように実装されています。 Web シナリオでは、この点を念頭に置いておき、1 つの要求の期間を超えるコンテキストを持たないことが重要です。 同様に、非 Web シナリオでは、エンティティ フレームワークでのキャッシュのさまざまなレベルを理解してコンテキストを破棄する必要があります。 一般的に言えば、アプリケーションの有効期間を通じてコンテキスト インスタンスを持つこと、およびスレッドおよび静的コンテキストごとのコンテキストを避ける必要があります。

### <a name="94-database-null-semantics"></a>9.4 データベースの NULL セマンティクス

既定では、エンティティ フレームワークは、C\#の null 比較セマンティクスを持つ SQL コードを生成します。 次のようなクエリがあるとします。

``` csharp
            int? categoryId = 7;
            int? supplierId = 8;
            decimal? unitPrice = 0;
            short? unitsInStock = 100;
            short? unitsOnOrder = 20;
            short? reorderLevel = null;

            var q = from p incontext.Products
                    wherep.Category.CategoryName == "Beverages"
                          || (p.CategoryID == categoryId
                                || p.SupplierID == supplierId
                                || p.UnitPrice == unitPrice
                                || p.UnitsInStock == unitsInStock
                                || p.UnitsOnOrder == unitsOnOrder
                                || p.ReorderLevel == reorderLevel)
                    select p;

            var r = q.ToList();
```

この例では、"仕入先コード" や "単価" など、エンティティの null 許容プロパティと null 許容の変数の数を比較しています。 このクエリに対して生成された SQL は、パラメーター値が列値と同じか、パラメーターと列の値の両方が NULL かどうかを尋ねます。 これにより、データベース サーバーが NULL を処理する方法が隠され、\#さまざまなデータベース ベンダ間で一貫した C NULL エクスペリエンスが提供されます。 一方、生成されたコードは少し複雑になり、クエリの where ステートメントの比較の量が多く増加すると、パフォーマンスが低下する可能性があります。

この状況に対処する 1 つの方法は、データベースの null セマンティクスを使用することです。 これは、現在 Entity Framework がデータベース エンジン\#が NULL 値を処理する方法を公開する単純な SQL を生成するので、C null セマンティクスとは異なる動作をする可能性があることに注意してください。 データベースの NULL セマンティクスは、コンテキスト構成に対して 1 つの構成行でコンテキストごとにアクティブ化できます。

``` csharp
                context.Configuration.UseDatabaseNullSemantics = true;
```

データベースの NULL セマンティクスを使用する場合、小規模から中規模のクエリではパフォーマンスが向上しませんが、NULL 比較の可能性が多いクエリでは、その違いがより顕著になります。

上記のサンプル クエリでは、制御された環境で実行されているマイクロベンチマークでパフォーマンスの差が 2% 未満でした。

### <a name="95-async"></a>9.5 非同期

エンティティ フレームワーク 6 では、.NET 4.5 以降で実行する場合の非同期操作のサポートが導入されました。 ほとんどの場合、IO 関連の競合があるアプリケーションは、非同期クエリと保存操作を使用すると、最もメリットが得られます。 アプリケーションが IO の競合に苦しまなければ、非同期の使用は、同期的に実行し、同期呼び出しと同じ時間で結果を返す、または最悪の場合は、単に非同期タスクに実行を延期し、シナリオの完了に余分な時間を追加します。

非同期がアプリケーション訪問のパフォーマンスを向上させるかどうかを判断するのに役立つ非同期プログラミングのしくみについては、以下を[http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx)参照してください。 Entity Framework での非同期操作の使用の詳細については、「[非同期クエリと保存](~/ef6/fundamentals/async.md
)」を参照してください。

### <a name="96-ngen"></a>9.6 NGEN

エンティティ フレームワーク 6 は、.NET フレームワークの既定のインストールには含まれていません。 したがって、エンティティ フレームワーク アセンブリは既定では NGEN になっていません。 これにより、開発中の F5 の操作性が低下し、運用環境でのアプリケーションのコールド 起動が低下する可能性があります。 JIT の CPU とメモリのコストを削減するためには、適切なエンティティ フレームワーク イメージを NGEN することをお勧めします。 NGEN を使用した Entity Framework 6 の起動パフォーマンスを向上させる方法の詳細については、「 [NGen を使用したスタートアップ パフォーマンスの向上](~/ef6/fundamentals/performance/ngen.md)」を参照してください。

### <a name="97-code-first-versus-edmx"></a>9.7 コードファーストとEDMX

Entity Framework の理由は、概念モデル (オブジェクト)、ストレージ スキーマ (データベース)、および 2 つの間のマッピングのメモリ内表現を持つことによって、オブジェクト指向プログラミングとリレーショナル データベースの間のインピーダンスの不一致の問題です。 このメタデータは、エンティティ データ モデル、つまり EDM と呼ばれます。 この EDM から、Entity Framework は、メモリ内のオブジェクトからデータベースにデータをラウンドトリップするビューを取得し、戻ります。

Entity Framework が、概念モデル、ストレージ スキーマ、およびマッピングを正式に指定する EDMX ファイルと共に使用される場合、モデルの読み込みステージは EDM が正しいことを検証するだけで済みます (たとえば、マッピングが欠落していないかどうかを確認する)、ビューを生成し、ビューを検証し、このメタデータを使用する準備が整います。 その場合にのみ、クエリを実行したり、新しいデータをデータ ストアに保存したりできます。

コードファーストアプローチは、その中心にある、洗練されたエンティティデータモデルジェネレータです。 エンティティ フレームワークは、提供されたコードから EDM を生成する必要があります。この処理は、モデルに関連するクラスを分析し、規則を適用し、Fluent API を使用してモデルを構成することによって行われます。 EDM がビルドされた後、エンティティ フレームワークは、プロジェクト内に EDMX ファイルが存在する場合と同じように動作します。 したがって、コード First からモデルを構築すると、EDMX を使用する場合と比較して、Entity Framework の起動時間が遅くなるという複雑さが増します。 コストは、構築されるモデルのサイズと複雑さに完全に依存します。

EDMX 対コードファーストの使用を選択する場合、Code First によって導入される柔軟性によって、モデルを初めて構築するコストが増加することを知ることが重要です。 アプリケーションがこの初回ロードのコストに耐えられる場合は、通常、Code First が優先的に行う方法です。

## <a name="10-investigating-performance"></a>10 パフォーマンスの調査

### <a name="101-using-the-visual-studio-profiler"></a>10.1 Visual Studio プロファイラの使用

Entity Framework でパフォーマンスの問題が発生している場合は、Visual Studio に組み込まれているプロファイラーを使用して、アプリケーションが時間を費やしている場所を確認できます。 これは、"ADO.NETエンティティ フレームワークのパフォーマンスを調べる - パート 1" ブログ記事 (Entity Framework がコールド\<https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1>)クエリとウォーム クエリの間に時間を費やす場所を示す) で円グラフを生成するために使用したツールです。

データおよびモデリングの顧客アドバイザリー チームによって書かれた「Visual Studio 2010 プロファイラーを使用したプロファイル エンティティ フレームワーク」ブログ記事は、プロファイラーを使用してパフォーマンスの問題を調査する方法の実際の例を示しています。\<https://docs.microsoft.com/archive/blogs/dmcat/profiling-entity-framework-using-the-visual-studio-2010-profiler>. この投稿は、Windows アプリケーション用に書き込まれました。 Web アプリケーションをプロファイリングする必要がある場合は、Windows パフォーマンス レコーダー (WPR) と Windows パフォーマンス アナライザー (WPA) ツールは、Visual Studio で作業するよりも適切に動作する可能性があります。 WPR と WPA は、Windows の評価と展開キット ( )[http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982)に含まれている Windows パフォーマンス ツールキットの一部です。

### <a name="102-applicationdatabase-profiling"></a>10.2 アプリケーション/データベースのプロファイリング

Visual Studio に組み込まれているプロファイラーなどのツールは、アプリケーションが時間を費やしている場所を示します。別のタイプのプロファイラーは、必要に応じて本番稼働または実稼働前に実行アプリケーションの動的分析を実行し、データベースアクセスの一般的な落とし穴と反パターンを探します。

2 つの市販のプロファイラーは、エンティティ フレームワーク\<http://efprof.com>)プロファイラ (\<http://ormprofiler.com>)および ORMProfiler ( .

アプリケーションがコードファーストを使用する MVC アプリケーションの場合は、StackExchange のミニプロファイラーを使用できます。 スコット・ヘンゼルマンは、このツールをブログで説明\<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx>しています。

アプリケーションのデータベースアクティビティのプロファイリングの詳細については、 Julie Lerman の MSDN マガジンの記事[「Entity Framework でのデータベースアクティビティのプロファイリング」を参照](https://msdn.microsoft.com/magazine/gg490349.aspx)してください。

### <a name="103-database-logger"></a>10.3 データベースロガー

Entity Framework 6 を使用している場合は、組み込みのログ機能の使用も検討してください。 コンテキストの Database プロパティは、単純な 1 行構成を使用してアクティビティをログに記録するように指示できます。

``` csharp
    using (var context = newQueryComparison.DbC.NorthwindEntities())
    {
        context.Database.Log = Console.WriteLine;
        var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
        q.ToList();
    }
```

この例では、データベースアクティビティはコンソールに記録されますが、Log プロパティは任意の Action&lt;文字列&gt;デリゲートを呼び出す設定が可能です。

再コンパイルせずにデータベース ログを有効にする場合、Entity Framework 6.1 以降を使用して、アプリケーションの web.config または app.config ファイルにインターセプターを追加します。

``` xml
  <interceptors>
    <interceptor type="System.Data.Entity.Infrastructure.Interception.DatabaseLogger, EntityFramework">
      <parameters>
        <parameter value="C:\Path\To\My\LogOutput.txt"/>
      </parameters>
    </interceptor>
  </interceptors>
```

再コンパイルせずにログを追加する方法の詳細については、 を\<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/>参照してください。

## <a name="11-appendix"></a>11 付録

### <a name="111-a-test-environment"></a>11.1 A. テスト環境

この環境では、クライアント アプリケーションとは別のコンピューター上のデータベースを使用して 2 台のコンピューターをセットアップします。 マシンは同じラックに入っているので、ネットワークの待ち時間は比較的低くなりますが、単一マシン環境よりも現実的です。

#### <a name="1111-app-server"></a>11.1.1 アプリケーションサーバー

##### <a name="11111-software-environment"></a>11.1.1.1 ソフトウェア環境

-   エンティティ フレームワーク 4 ソフトウェア環境
    -   OS 名: Windows サーバー 2008 R2 エンタープライズ SP1.
    -   ビジュアルスタジオ2010 - 究極。
    -   Visual Studio 2010 SP1 (一部の比較のみ)。
-   エンティティ フレームワーク 5 および 6 ソフトウェア環境
    -   OS 名: Windows 8.1 エンタープライズ
    -   ビジュアルスタジオ2013 – 究極.

##### <a name="11112-hardware-environment"></a>11.1.1.2 ハードウェア環境

-   デュアルプロセッサ: インテル(R) Xeon(R) CPU L5520 W3530 @ 2.27GHz, 2261 Mhz8 GHz, 4 コア, 84 論理プロセッサ.
-   2412 GB ラム。
-   136 GB SCSI250GB SATA 7200 rpm 3GB/秒ドライブは4つのパーティションに分割されます。

#### <a name="1112-db-server"></a>11.1.2 DB サーバ

##### <a name="11121-software-environment"></a>11.1.2.1 ソフトウェア環境

-   OS 名: Windows Server 2008 R28.1 エンタープライズ SP1.
-   SQL Server 2008 R22012。

##### <a name="11122-hardware-environment"></a>11.1.2.2 ハードウェア環境

-   シングルプロセッサ: インテル(R) Xeon(R) CPU L5520 @ 2.27GHz, 2261 MhzES-1620 0 @ 3.60GHz, 4 コア, 8 論理プロセッサ.
-   824 GB ラム。
-   465 GB ATA500GB SATA 7200 rpm 6GB/秒ドライブは4つのパーティションに分割されます。

### <a name="112-b-query-performance-comparison-tests"></a>11.2 B. クエリ パフォーマンス比較テスト

これらのテストを実行するために Northwind モデルが使用されました。 これは、エンティティ フレームワーク デザイナーを使用してデータベースから生成されました。 次に、クエリ実行オプションのパフォーマンスを比較するために次のコードを使用しました。

``` csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity.Infrastructure;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Linq;

namespace QueryComparison
{
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
                );

        public IQueryable<Product> InvokeProductsForCategoryCQ(string categoryName)
        {
            return productsForCategoryCQ(this, categoryName);
        }
    }

    public class QueryTypePerfComparison
    {
        private static string entityConnectionStr = @"metadata=res://*/Northwind.csdl|res://*/Northwind.ssdl|res://*/Northwind.msl;provider=System.Data.SqlClient;provider connection string='data source=.;initial catalog=Northwind;integrated security=True;multipleactiveresultsets=True;App=EntityFramework'";

        public void LINQIncludingContextCreation()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTracking()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                context.Products.MergeOption = MergeOption.NoTracking;

                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void CompiledQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                var q = context.InvokeProductsForCategoryCQ("Beverages");
                q.ToList();
            }
        }

        public void ObjectQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
                products.ToList();
            }
        }

        public void EntityCommand()
        {
            using (EntityConnection eConn = new EntityConnection(entityConnectionStr))
            {
                eConn.Open();
                EntityCommand cmd = eConn.CreateCommand();
                cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

                using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
                {
                    List<Product> productsList = new List<Product>();
                    while (reader.Read())
                    {
                        DbDataRecord record = (DbDataRecord)reader.GetValue(0);

                        // 'materialize' the product by accessing each field and value. Because we are materializing products, we won't have any nested data readers or records.
                        int fieldCount = record.FieldCount;

                        // Treat all products as Product, even if they are the subtype DiscontinuedProduct.
                        Product product = new Product();  

                        product.ProductID = record.GetInt32(0);
                        product.ProductName = record.GetString(1);
                        product.SupplierID = record.GetInt32(2);
                        product.CategoryID = record.GetInt32(3);
                        product.QuantityPerUnit = record.GetString(4);
                        product.UnitPrice = record.GetDecimal(5);
                        product.UnitsInStock = record.GetInt16(6);
                        product.UnitsOnOrder = record.GetInt16(7);
                        product.ReorderLevel = record.GetInt16(8);
                        product.Discontinued = record.GetBoolean(9);

                        productsList.Add(product);
                    }
                }
            }
        }

        public void ExecuteStoreQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectResult<Product> beverages = context.ExecuteStoreQuery<Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Database.SqlQuery\<QueryComparison.DbC.Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbSet()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Products.SqlQuery(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void LINQIncludingContextCreationDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTrackingDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var q = context.Products.AsNoTracking().Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }
    }
}
```

### <a name="113-c-navision-model"></a>11.3 C. ナビジョンモデル

Navision データベースは、マイクロソフトダイナミクス - NAVをデモするために使用される大規模なデータベースです。 生成される概念モデルには、1005 個のエンティティ セットと 4227 個の関連付けセットが含まれます。 テストで使用されるモデルは"フラット"で、継承は追加されていません。

#### <a name="1131-queries-used-for-navision-tests"></a>11.3.1 Navision テストに使用されるクエリ

Navision モデルで使用されるクエリ リストには、Entity SQL クエリの 3 つのカテゴリが含まれています。

##### <a name="11311-lookup"></a>11.3.1.1 ルックアップ

集計を含む単純な検索クエリ

-   カウント: 16232
-   例:

``` xml
  <Query complexity="Lookup">
    <CommandText>Select value distinct top(4) e.Idle_Time From NavisionFKContext.Session as e</CommandText>
  </Query>
```

##### <a name="11312singleaggregating"></a>11.3.1.2 単一集約

複数の集計を含むが小計がない通常の BI クエリ (単一のクエリ)

-   カウント: 2313
-   例:

``` xml
  <Query complexity="SingleAggregating">
    <CommandText>NavisionFK.MDF_SessionLogin_Time_Max()</CommandText>
  </Query>
```

MDF\_セッションログイン\_時間\_Max() がモデル内で次のように定義されている場所:

``` xml
  <Function Name="MDF_SessionLogin_Time_Max" ReturnType="Collection(DateTime)">
    <DefiningExpression>SELECT VALUE Edm.Min(E.Login_Time) FROM NavisionFKContext.Session as E</DefiningExpression>
  </Function>
```

##### <a name="11313aggregatingsubtotals"></a>11.3.1.3 集計小計

集計と小計を含む BI クエリ (ユニオン全体を介して)

-   カウント: 178
-   例:

``` xml
  <Query complexity="AggregatingSubtotals">
    <CommandText>
using NavisionFK;
function AmountConsumed(entities Collection([CRONUS_International_Ltd__Zone])) as
(
    Edm.Sum(select value N.Block_Movement FROM entities as E, E.CRONUS_International_Ltd__Bin as N)
)
function AmountConsumed(P1 Edm.Int32) as
(
    AmountConsumed(select value e from NavisionFKContext.CRONUS_International_Ltd__Zone as e where e.Zone_Ranking = P1)
)
----------------------------------------------------------------------------------------------------------------------
(
    select top(10) Zone_Ranking, Cross_Dock_Bin_Zone, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking, E.Cross_Dock_Bin_Zone
)
union all
(
    select top(10) Zone_Ranking, Cast(null as Edm.Byte) as P2, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking
)
union all
{
    Row(Cast(null as Edm.Int32) as P1, Cast(null as Edm.Byte) as P2, AmountConsumed(select value E
                                                                         from NavisionFKContext.CRONUS_International_Ltd__Zone as E
                                                                         where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed))
}</CommandText>
    <Parameters>
      <Parameter Name="MinAmountConsumed" DbType="Int32" Value="10000" />
    </Parameters>
  </Query>
```
