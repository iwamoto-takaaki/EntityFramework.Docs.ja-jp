---
title: EF4、EF5、および EF6 のパフォーマンスに関する考慮事項-EF6
description: Entity Framework 4、5、および6のパフォーマンスに関する考慮事項
author: divega
ms.date: 10/23/2016
uid: ef6/fundamentals/performance/perf-whitepaper
ms.openlocfilehash: 65584382df3d510f314a576f41c5dee3d2e718e7
ms.sourcegitcommit: abda0872f86eefeca191a9a11bfca976bc14468b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/14/2020
ms.locfileid: "90070537"
---
# <a name="performance-considerations-for-ef-4-5-and-6"></a>EF 4、5、および6のパフォーマンスに関する考慮事項
David Obando、Eric Dettinger、その他

公開日: 2012 年4月

最終更新日: 2014 年5月

------------------------------------------------------------------------

## <a name="1-introduction"></a>1.はじめに

オブジェクトリレーショナルマッピングフレームワークは、オブジェクト指向アプリケーションでのデータアクセスの抽象化を提供するのに便利な方法です。 .NET アプリケーションの場合、Microsoft の推奨される O/RM が Entity Framework ます。 ただし、抽象化を使用すると、パフォーマンスが問題になる可能性があります。

このホワイトペーパーは、Entity Framework を使用してアプリケーションを開発するときのパフォーマンスに関する考慮事項を示し、開発者がパフォーマンスに影響を与える可能性のある Entity Framework 内部アルゴリズムを理解し、Entity Framework を使用するアプリケーションの調査とパフォーマンス向上のヒントを提供するために記述されました。 Web で既に利用可能なパフォーマンスに関する多くの優れたトピックがあります。また、可能な場合は、これらのリソースをポイントすることもできました。

パフォーマンスは、厄介なトピックです。 このホワイトペーパーは、Entity Framework を使用するアプリケーションについて、パフォーマンスに関する意思決定を行うのに役立つリソースとして提供されています。 パフォーマンスを実証するためのテストメトリックがいくつか含まれていますが、これらのメトリックは、アプリケーションに表示されるパフォーマンスの絶対インジケーターとしては意図されていません。

実際には、このドキュメントでは Entity Framework 4 が .NET 4.0 で実行され、Entity Framework 5 および6は .NET 4.5 で実行されることを前提としています。 Entity Framework 5 に加えられたパフォーマンスの向上の多くは、.NET 4.5 に付属するコアコンポーネント内に存在します。

Entity Framework 6 は帯域外リリースであり、.NET に付属する Entity Framework コンポーネントには依存しません。 Entity Framework 6 は .net 4.0 と .NET 4.5 の両方で動作し、.NET 4.0 からアップグレードしていないが、アプリケーションで最新の Entity Framework ビットを必要とするユーザーにとって、大きなパフォーマンス上の利点を提供できます。 このドキュメントには Entity Framework 6 と記載されていますが、このドキュメントの執筆時点で利用可能な最新バージョンを参照しています: バージョン6.1.0。

## <a name="2-cold-vs-warm-query-execution"></a>2. コールドクエリとウォームクエリの実行

特定のモデルに対してクエリを初めて実行すると、Entity Framework は、モデルの読み込みと検証のために多くの作業をバックグラウンドで実行します。 この最初のクエリは、"コールド" クエリとして頻繁に参照されます。既に読み込まれているモデルに対するクエリは、"ウォーム" クエリとも呼ばれ、はるかに高速です。

ここでは、Entity Framework を使用してクエリを実行するときに時間が費やされる場所の概要を示し、Entity Framework 6 での改善点について説明します。

**最初のクエリ実行–コールドクエリ**

| コードユーザーの書き込み                                                                                     | アクション                    | EF4 のパフォーマンスへの影響                                                                                                                                                                                                                                                                                                                                                                                                        | EF5 のパフォーマンスへの影響                                                                                                                                                                                                                                                                                                                                                                                                                                                    | EF6 のパフォーマンスへの影響                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | コンテキストの作成          | Medium                                                                                                                                                                                                                                                                                                                                                                                                                        | Medium                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | クエリ式の作成 | 低                                                                                                                                                                                                                                                                                                                                                                                                                           | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| `  var c1 = q1.First();`                                                                             | LINQ クエリの実行      | -メタデータの読み込み: 高ですが、キャッシュされています <br/> -ビューの生成: 非常に高い可能性があり、キャッシュされている可能性があります <br/> -パラメーターの評価: 中 <br/> -クエリ変換: 中 <br/> -具体化 generation: Medium、cached <br/> -データベースクエリの実行: 高い可能性があります <br/> + 接続します。開く <br/> + Command.ExecuteReader <br/> + DataReader。読み取り <br/> オブジェクトの具体化: 中 <br/> -Id 参照: 中 | -メタデータの読み込み: 高ですが、キャッシュされています <br/> -ビューの生成: 非常に高い可能性があり、キャッシュされている可能性があります <br/> -Parameter 評価: 低 <br/> -クエリ変換: 中、キャッシュ済み <br/> -具体化 generation: Medium、cached <br/> -データベースクエリの実行: 高可用 (状況によってはクエリが向上) <br/> + 接続します。開く <br/> + Command.ExecuteReader <br/> + DataReader。読み取り <br/> オブジェクトの具体化: 中 <br/> -Id 参照: 中 | -メタデータの読み込み: 高ですが、キャッシュされています <br/> -ビューの生成: 中ですが、キャッシュされています <br/> -Parameter 評価: 低 <br/> -クエリ変換: 中、キャッシュ済み <br/> -具体化 generation: Medium、cached <br/> -データベースクエリの実行: 高可用 (状況によってはクエリが向上) <br/> + 接続します。開く <br/> + Command.ExecuteReader <br/> + DataReader。読み取り <br/> オブジェクトの具体化: 中 (EF5 より高速) <br/> -Id 参照: 中 |
| `}`                                                                                                  | 接続します。閉じる          | 低                                                                                                                                                                                                                                                                                                                                                                                                                           | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |


**2番目のクエリの実行–ウォームクエリ**

| コードユーザーの書き込み                                                                                     | アクション                    | EF4 のパフォーマンスへの影響                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | EF5 のパフォーマンスへの影響                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | EF6 のパフォーマンスへの影響                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
|:-----------------------------------------------------------------------------------------------------|:--------------------------|:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `using(var db = new MyContext())` <br/> `{`                                                          | コンテキストの作成          | Medium                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Medium                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var q1 = ` <br/> `    from c in db.Customers` <br/> `    where c.Id == id1` <br/> `    select c;` | クエリ式の作成 | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `  var c1 = q1.First();`                                                                             | LINQ クエリの実行      | -メタデータ ~~読み込み~~ の参照: ~~高、キャッシュ~~ 低 <br/> -ビューの ~~生成~~ の参照: ~~非常に高い可能性があり、キャッシュ~~ された低 <br/> -パラメーターの評価: 中 <br/> -クエリ ~~変換~~ の参照: 中 <br/> -具体化 ~~generation~~ Lookup: ~~Medium、cached~~ 低 <br/> -データベースクエリの実行: 高い可能性があります <br/> + 接続します。開く <br/> + Command.ExecuteReader <br/> + DataReader。読み取り <br/> オブジェクトの具体化: 中 <br/> -Id 参照: 中 | -メタデータ ~~読み込み~~ の参照: ~~高、キャッシュ~~ 低 <br/> -ビューの ~~生成~~ の参照: ~~非常に高い可能性があり、キャッシュ~~ された低 <br/> -Parameter 評価: 低 <br/> -クエリ ~~変換~~ の参照: ~~中、キャッシュ~~ 低 <br/> -具体化 ~~generation~~ Lookup: ~~Medium、cached~~ 低 <br/> -データベースクエリの実行: 高可用 (状況によってはクエリが向上) <br/> + 接続します。開く <br/> + Command.ExecuteReader <br/> + DataReader。読み取り <br/> オブジェクトの具体化: 中 <br/> -Id 参照: 中 | -メタデータ ~~読み込み~~ の参照: ~~高、キャッシュ~~ 低 <br/> -ビューの ~~生成~~ の参照: ~~中で、キャッシュ~~ された低 <br/> -Parameter 評価: 低 <br/> -クエリ ~~変換~~ の参照: ~~中、キャッシュ~~ 低 <br/> -具体化 ~~generation~~ Lookup: ~~Medium、cached~~ 低 <br/> -データベースクエリの実行: 高可用 (状況によってはクエリが向上) <br/> + 接続します。開く <br/> + Command.ExecuteReader <br/> + DataReader。読み取り <br/> オブジェクトの具体化: 中 (EF5 より高速) <br/> -Id 参照: 中 |
| `}`                                                                                                  | 接続します。閉じる          | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 低                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |


コールドクエリとウォームクエリの両方のパフォーマンスコストを削減するには、いくつかの方法があります。これらについては、次のセクションで説明します。 具体的には、事前に生成されたビューを使用して、コールドクエリでのモデル読み込みのコストを削減することを検討します。これは、ビューの生成中に発生するパフォーマンスの問題を軽減するのに役立ちます。 ウォームクエリでは、クエリプランのキャッシュ、追跡クエリ、およびさまざまなクエリ実行オプションについて説明します。

### <a name="21-what-is-view-generation"></a>2.1 ビューの生成とは

ビューの世代を理解するために、まず、"マッピングビュー" とは何かを理解する必要があります。 マッピングビューは、各エンティティセットとアソシエーションのマッピングで指定された変換の実行可能表現です。 内部的には、これらのマッピングビューは CQTs (正規クエリツリー) の形になります。 マッピングビューには、次の2種類があります。

-   クエリビュー: データベーススキーマから概念モデルに移動するために必要な変換を表します。
-   更新ビュー: 概念モデルからデータベーススキーマに移動するために必要な変換を表します。

概念モデルは、さまざまな方法でデータベーススキーマとは異なる場合があることに注意してください。 たとえば、1つのテーブルを使用して、2つの異なるエンティティ型のデータを格納することができます。 継承と非自明なマッピングでは、マッピングビューの複雑さが増します。

マッピングの仕様に基づいてこれらのビューを計算するプロセスは、ビュー生成と呼ばれます。 ビューの生成は、モデルが読み込まれたとき、またはビルド時に "事前に生成されたビュー" を使用して動的に実行できます。後者は、Entity SQL ステートメントの形式で C または VB ファイルにシリアル化され \# ます。

ビューが生成されると、それらも検証されます。 パフォーマンスの観点から見ると、ビュー生成のコストの大部分は、実際にはビューの検証であり、エンティティ間の接続が意味を持ち、サポートされているすべての操作に対して適切なカーディナリティがあることが確認されます。

エンティティセットに対するクエリを実行すると、クエリが対応するクエリビューと結合され、この構成の結果がプランコンパイラを通じて実行され、バッキングストアが理解できるクエリの表現が作成されます。 SQL Server の場合、このコンパイルの最終的な結果は T-sql SELECT ステートメントになります。 エンティティセットに対して最初に更新を実行すると、同様のプロセスによって更新ビューが実行され、ターゲットデータベースの DML ステートメントに変換されます。

### <a name="22-factors-that-affect-view-generation-performance"></a>2.2 ビューの生成パフォーマンスに影響を与える要因

ビュー生成手順のパフォーマンスは、モデルのサイズだけでなく、モデルの相互接続方法にも依存します。 2つのエンティティが継承チェーンまたはアソシエーションを介して接続されている場合は、接続されていると言います。 同様に、2つのテーブルが外部キーを介して接続されている場合は、接続されます。 スキーマ内の接続されたエンティティとテーブルの数が増えるにつれて、ビューの生成コストが増加します。

ビューの生成と検証に使用するアルゴリズムは、最悪の場合には指数関数的ですが、これを向上させるためにいくつかの最適化を使用します。 パフォーマンスに悪影響を及ぼす最大の要因は次のとおりです。

-   エンティティの数と、これらのエンティティ間のアソシエーションの量を参照するモデルサイズ。
-   モデルの複雑さ、特に多数の型が関係する継承。
-   外部キーの関連付けではなく、独立した関連付けを使用します。

小規模の単純なモデルでは、事前に生成されたビューを使用しないほどコストが小さくなる可能性があります。 モデルのサイズと複雑さが増すにつれて、ビューの生成と検証のコストを削減するために使用できるオプションがいくつかあります。

### <a name="23-using-pre-generated-views-to-decrease-model-load-time"></a>2.3 事前に生成されたビューを使用したモデルの読み込み時間の短縮

Entity Framework 6 で事前に生成されたビューを使用する方法の詳細については[、事前に生成されたマッピングビュー](xref:ef6/fundamentals/performance/pre-generated-views)に関するページを参照してください。

#### <a name="231-pre-generated-views-using-the-entity-framework-power-tools-community-edition"></a>2.3.1 Entity Framework Power Tools Community エディションを使用して事前に生成されたビュー

[Entity Framework 6 の Power Tools Community エディション](https://marketplace.visualstudio.com/items?itemName=ErikEJ.EntityFramework6PowerToolsCommunityEdition)を使用して、モデルクラスファイルを右クリックし、[Entity Framework] メニューを使用して [ビューの生成] を選択すると、EDMX モデルと Code First モデルのビューを生成できます。 Entity Framework Power Tools Community Edition は、DbContext で派生したコンテキストでのみ動作します。

#### <a name="232-how-to-use-pre-generated-views-with-a-model-created-by-edmgen"></a>2.3.2 Edmgen.exe によって作成されたモデルで事前生成されたビューを使用する方法

Edmgen.exe は、.NET に付属し、Entity Framework 4 および5で動作するユーティリティですが、Entity Framework 6 では動作しません。 Edmgen.exe を使用すると、モデルファイル、オブジェクトレイヤー、およびビューをコマンドラインから生成できます。 出力の1つは、選択した言語 (VB または C) のビューファイルになり \# ます。 これは、各エンティティセットの Entity SQL スニペットを含むコードファイルです。 事前に生成されたビューを有効にするには、単にファイルをプロジェクトに含めます。

モデルのスキーマファイルを手動で編集する場合は、ビューファイルを再生成する必要があります。 これを行うには、 **/mode: ViewGeneration** フラグを使用して edmgen.exe を実行します。

#### <a name="233-how-to-use-pre-generated-views-with-an-edmx-file"></a>2.3.3 EDMX ファイルで事前に生成されたビューを使用する方法

また、Edmgen.exe を使用して EDMX ファイルのビューを生成することもできます。前に参照した MSDN トピックでは、これを行うためのビルド前イベントを追加する方法について説明していますが、これは複雑であり、不可能な場合もあります。 一般に、モデルが edmx ファイル内にある場合は、T4 テンプレートを使用してビューを生成する方が簡単です。

ADO.NET チームのブログには、ビューの生成に T4 テンプレートを使用する方法を説明する投稿があり \<https://docs.microsoft.com/archive/blogs/adonet/how-to-use-a-t4-template-for-view-generation> ます ()。 この投稿には、ダウンロードしてプロジェクトに追加できるテンプレートが含まれています。 テンプレートは最初のバージョンの Entity Framework 用に記述されているので、最新バージョンの Entity Framework で動作することは保証されていません。 ただし、Visual Studio ギャラリーから Entity Framework 4 と5from ビュー生成テンプレートの最新のセットをダウンロードできます。

-   VB.NET: \<http://visualstudiogallery.msdn.microsoft.com/118b44f2-1b91-4de2-a584-7a680418941d>
-   C \# : \<http://visualstudiogallery.msdn.microsoft.com/ae7730ce-ddab-470f-8456-1b313cd2c44d>

Entity Framework 6 を使用している場合は、で Visual Studio ギャラリーからビュー生成 T4 テンプレートを取得でき \<http://visualstudiogallery.msdn.microsoft.com/18a7db90-6705-4d19-9dd1-0a6c23d0751f> ます。

### <a name="24-reducing-the-cost-of-view-generation"></a>2.4 ビューの生成コストの削減

事前に生成されたビューを使用すると、モデルの読み込み (実行時) からデザイン時までのビューの生成コストが変化します。 これにより、実行時の起動時のパフォーマンスが向上しますが、開発中はビューの生成が困難になります。 コンパイル時と実行時の両方で、ビュー生成のコストを削減するために役立ついくつかの追加のテクニックがあります。

#### <a name="241-using-foreign-key-associations-to-reduce-view-generation-cost"></a>2.4.1 外部キーの関連付けを使用してビューの生成コストを削減する

モデル内のアソシエーションを依存関係から外部キーへの関連付けに切り替えると、ビューの生成にかかる時間が大幅に短縮されました。

この改善点を示すために、Edmgen.exe を使用して2つのバージョンの Navision モデルを生成しました。 *注: Navision モデルの説明については、「付録 C」を参照してください。* Navision モデルは、非常に大量のエンティティとリレーションシップがあるため、この演習では興味深いものです。

この非常に大きなモデルの1つのバージョンが、外部キーの関連付けを使用して生成され、もう一方は独立したアソシエーションを使用して生成されました。 次に、各モデルのビューの生成に要した時間を計測しました。 Entity Framework 5 テストでは、クラス EntityViewGenerator から GenerateViews () メソッドを使用してビューを生成していましたが、Entity Framework 6 テストでは StorageMappingItemCollection クラスの GenerateViews () メソッドが使用されていました。 これは、Entity Framework 6 コードベースで発生したコードの再構築に起因します。

Entity Framework 5 を使用すると、外部キーを使用したモデルのビュー生成には、ラボコンピューターで65分かかりました。 独立した関連付けを使用したモデルのビューを生成するのにかかる時間は不明です。 毎月の更新プログラムをインストールするために、ラボでコンピューターを再起動する前に、1か月以上テストを実行しています。

Entity Framework 6 を使用すると、外部キーを使用したモデルのビュー生成は、同じラボコンピューターで28秒かかりました。 独立アソシエーションを使用するモデルのビュー生成には、58秒かかりました。 ビュー生成コードで Entity Framework 6 に対して行われた機能強化により、多くのプロジェクトでは、起動時間を短縮するために事前に生成されたビューは必要ありません。

Entity Framework 4 および5の事前生成ビューは、Edmgen.exe または Entity Framework パワーツールで実行できます。 Entity Framework 6 ビューの生成は、Entity Framework パワーツールを使用するか、 [事前に生成されたマッピングビュー](xref:ef6/fundamentals/performance/pre-generated-views)で説明されているようにプログラムで行うことができます。

##### <a name="2411-how-to-use-foreign-keys-instead-of-independent-associations"></a>2.4.1.1 独立した関連付けの代わりに外部キーを使用する方法

Edmgen.exe または Visual Studio で Entity Designer を使用する場合、既定では FKs が使用され、FKs と IAs を切り替えるためのチェックボックスまたはコマンドラインフラグは1つだけになります。

大きな Code First モデルを使用している場合は、独立した関連付けを使用すると、ビューの生成に対して同じ効果が得られます。 依存オブジェクトのクラスに外部キープロパティを含めることで、この影響を回避できます。ただし、開発者によっては、オブジェクトモデルが汚染されることを考慮しています。 このトピックの詳細については、「」を参照 \<http://blog.oneunicorn.com/2011/12/11/whats-the-deal-with-mapping-foreign-keys-using-the-entity-framework/> してください。

| 使用する場合      | 方法                                                                                                                                                                                                                                                                                                                              |
|:----------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| エンティティ デザイナー | 2つのエンティティ間の関連付けを追加した後、参照に関する制約があることを確認します。 参照制約は、独立した関連付けではなく外部キーを使用するように Entity Framework に指示します。 詳細については、「」を参照してください \<https://docs.microsoft.com/archive/blogs/efdesign/foreign-keys-in-the-entity-framework> 。 |
| Edmgen.exe          | Edmgen.exe を使用してデータベースからファイルを生成する場合、外部キーが尊重され、そのようなモデルに追加されます。 Edmgen.exe によって公開されるさまざまなオプションの詳細については、「」を参照してください [http://msdn.microsoft.com/library/bb387165.aspx](https://msdn.microsoft.com/library/bb387165.aspx) 。                           |
| Code First      | Code First を使用する場合に依存オブジェクトの外部キープロパティを含める方法については、 [Code First 規則](xref:ef6/modeling/code-first/conventions/built-in) のトピックの「リレーションシップ規則」セクションを参照してください。                                                                                              |

#### <a name="242-moving-your-model-to-a-separate-assembly"></a>2.4.2 モデルを別のアセンブリに移動する

モデルがアプリケーションのプロジェクトに直接含まれており、ビルド前のイベントまたは T4 テンプレートを使用してビューを生成すると、モデルが変更されていなくても、プロジェクトが再構築されるたびに、ビューの生成と検証が行われます。 モデルを別のアセンブリに移動し、アプリケーションのプロジェクトから参照する場合は、モデルを含むプロジェクトをリビルドする必要なく、アプリケーションに他の変更を加えることができます。

*注:*  モデルを別のアセンブリに移動する場合は、モデルの接続文字列をクライアントプロジェクトのアプリケーション構成ファイルにコピーすることを忘れないでください。

#### <a name="243-disable-validation-of-an-edmx-based-model"></a>2.4.3 edmx ベースのモデルの検証を無効にする

EDMX モデルは、モデルが変更されていない場合でも、コンパイル時に検証されます。 モデルが既に検証済みの場合は、[プロパティ] ウィンドウで "ビルド時に検証" プロパティを false に設定することにより、コンパイル時に検証を抑制できます。 マッピングまたはモデルを変更すると、変更を確認するための検証を一時的に再び有効にすることができます。

Entity Framework 6 の Entity Framework Designer に対してパフォーマンスが向上しました。また、"ビルド時の検証" のコストは、以前のバージョンのデザイナーよりもはるかに少なくなっています。

## <a name="3-caching-in-the-entity-framework"></a>Entity Framework での3キャッシュ

Entity Framework には、次の形式のキャッシュが組み込まれています。

1.  オブジェクトキャッシュ: ObjectContext インスタンスに組み込まれている ObjectStateManager は、そのインスタンスを使用して取得されたオブジェクトのメモリを追跡します。 これは、第1レベルのキャッシュとも呼ばれます。
2.  クエリプランのキャッシュ-クエリが複数回実行された場合に、生成されたストアコマンドを再利用します。
3.  メタデータのキャッシュ-モデルのメタデータを、同じモデルへの異なる接続間で共有します。

EF が既定で提供するキャッシュに加えて、ラッピングプロバイダーと呼ばれる特殊な種類の ADO.NET データプロバイダーを使用して、データベースから取得した結果のキャッシュを使用して Entity Framework を拡張することもできます。これは、第2レベルのキャッシュとも呼ばれます。

### <a name="31-object-caching"></a>3.1 オブジェクトキャッシュ

既定では、EF によって具体化される直前に、クエリの結果でエンティティが返されるときに、ObjectContext は同じキーを持つエンティティが既に ObjectStateManager に読み込まれているかどうかを確認します。 同じキーを持つエンティティが既に存在する場合は、EF によってクエリの結果に含まれます。 EF は引き続きデータベースに対してクエリを発行しますが、この動作は、エンティティを複数回具体化するコストの多くを回避できます。

#### <a name="311-getting-entities-from-the-object-cache-using-dbcontext-find"></a>3.1.1 DbContext 検索を使用してオブジェクトキャッシュからエンティティを取得する

通常のクエリとは異なり、DbSet の Find メソッド (EF 4.1 で初めて使用される Api) は、データベースに対してクエリを発行する前に、メモリ内で検索を実行します。 2つの異なる ObjectContext インスタンスは2つの異なる ObjectStateManager インスタンスを持つことに注意してください。つまり、個別のオブジェクトキャッシュを持つことになります。

Find は、primary key 値を使用して、コンテキストによって追跡されるエンティティを検索します。 エンティティがコンテキスト内にない場合は、クエリが実行され、データベースに対して評価されます。また、エンティティがコンテキストまたはデータベースに見つからない場合は null が返されます。 また、Find では、コンテキストに追加されていても、まだデータベースに保存されていないエンティティも返されます。

Find を使用する場合は、パフォーマンスに関する考慮事項があります。 既定でこのメソッドを呼び出すと、データベースへのコミットが保留中の変更を検出するために、オブジェクトキャッシュの検証がトリガーされます。 オブジェクトキャッシュ内に非常に多くのオブジェクトがある場合、またはオブジェクトキャッシュに追加されている大きなオブジェクトグラフにオブジェクトが含まれている場合、このプロセスは非常にコストが高くなる可能性がありますが、無効にすることもできます。 場合によっては、自動的に検出された変更を無効にしたときに、Find メソッドを呼び出すことによって、大きな違いを感じることがあります。 ただし、2番目の次数の次数は、オブジェクトが実際にキャッシュ内にある場合と、オブジェクトをデータベースから取得する必要がある場合に認識されます。 次に示すのは、マイクロベンチマークのいくつかを使用して取得した測定値が、5000エンティティの読み込みでミリ秒単位で示されたグラフの例です。

![.NET 4.5 対数スケール](~/ef6/media/net45logscale.png ".NET 4.5-対数スケール")

自動検出の変更が無効になっている Find の例を次に示します。

``` csharp
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    context.Configuration.AutoDetectChangesEnabled = true;
    ...
```

Find メソッドを使用する場合は、次の点を考慮する必要があります。

1.  オブジェクトがキャッシュにない場合は、Find の利点は否定されますが、構文はキーによるクエリよりも単純です。
2.  [変更を自動的に検出する] が有効になっている場合、Find メソッドのコストは、モデルの複雑さとオブジェクトキャッシュ内のエンティティの量に応じて、1つの大きさになるか、さらに多くなる可能性があります。

また、Find は検索するエンティティだけを返し、関連付けられているエンティティがまだオブジェクトキャッシュにない場合は、そのエンティティが自動的に読み込まれないことに注意してください。 関連付けられたエンティティを取得する必要がある場合は、一括読み込みでキーによるクエリを使用できます。 詳細については、「 **8.1 の遅延読み込みと一括読み込み**」を参照してください。

#### <a name="312-performance-issues-when-the-object-cache-has-many-entities"></a>オブジェクトキャッシュに多数のエンティティがある場合のパフォーマンスの問題の3.1.2

オブジェクトキャッシュを使用すると、Entity Framework の全体的な応答性を向上させることができます。 ただし、オブジェクトキャッシュに大量のエンティティが読み込まれている場合、Add、Remove、Find、Entry、SaveChanges などの特定の操作に影響を与える可能性があります。 特に、検出された変更の呼び出しをトリガーする操作は、非常に大きなオブジェクトキャッシュによって悪影響を受けます。 [検出された変更] オブジェクトグラフをオブジェクト状態マネージャーと同期し、そのパフォーマンスがオブジェクトグラフのサイズによって直接決定されます。 検出の変更の詳細については、「 [POCO エンティティの変更の追跡](https://msdn.microsoft.com/library/dd456848.aspx)」を参照してください。

Entity Framework 6 を使用する場合、開発者は、コレクションに対して反復処理を実行し、インスタンスごとに Add を呼び出すのではなく、DbSet に対して直接 AddRange と RemoveRange 設定を呼び出すことができます。 範囲のメソッドを使用する利点は、追加されたエンティティごとに1回ではなく、エンティティのセット全体に対して、検出された変更のコストが1回だけ支払われることです。

### <a name="32-query-plan-caching"></a>3.2 クエリプランのキャッシュ

クエリが最初に実行されると、内部プランコンパイラによって、概念クエリがストアコマンドに変換されます (たとえば、SQL Server に対して実行される T-sql)。クエリプランのキャッシュが有効になっている場合、次にクエリが実行されるときに、ストアコマンドが実行のためにクエリプランキャッシュから直接取得され、プランコンパイラはバイパスされます。

クエリプランキャッシュは、同じ AppDomain 内の ObjectContext インスタンス間で共有されます。 クエリプランのキャッシュを活用するために、ObjectContext インスタンスを保持する必要はありません。

#### <a name="321-some-notes-about-query-plan-caching"></a>3.2.1 クエリプランのキャッシュに関する注意事項

-   クエリプランキャッシュは、すべての種類のクエリ (Entity SQL、LINQ to Entities、CompiledQuery オブジェクト) で共有されます。
-   既定では、EntityCommand または ObjectQuery のどちらを使用して実行されたかにかかわらず、Entity SQL クエリに対してクエリプランのキャッシュが有効になっています。 また、.NET 4.5 の Entity Framework の LINQ to Entities クエリと Entity Framework 6 では、既定で有効になっています。
    -   クエリプランのキャッシュを無効にするには、EnablePlanCaching プロパティ (EntityCommand または ObjectQuery) を false に設定します。 次に例を示します。
``` csharp
                    var query = from customer in context.Customer
                                where customer.CustomerId == id
                                select new
                                {
                                    customer.CustomerId,
                                    customer.Name
                                };
                    ObjectQuery oQuery = query as ObjectQuery;
                    oQuery.EnablePlanCaching = false;
```
-   パラメーター化クエリの場合、パラメーターの値を変更しても、キャッシュされたクエリにヒットします。 ただし、パラメーターのファセット (サイズ、有効桁数、小数点以下桁数など) を変更すると、キャッシュ内の別のエントリがヒットします。
-   Entity SQL を使用する場合、クエリ文字列はキーの一部になります。 クエリを変更しても、クエリが機能的に同等である場合でも、キャッシュエントリが異なることになります。 これには、大文字と小文字の違いや空白の変更も含まれます。
-   LINQ を使用する場合、クエリはキーの一部を生成するために処理されます。 したがって、LINQ 式を変更すると、別のキーが生成されます。
-   その他の技術的な制限が適用される場合があります。詳細については、「Autocompiled されたクエリ」を参照してください。

#### <a name="322-cache-eviction-algorithm"></a>3.2.2 キャッシュ削除アルゴリズム

内部アルゴリズムがどのように機能するかを理解することは、クエリプランのキャッシュを有効または無効にするタイミングを判断するのに役立ちます。 クリーンアップアルゴリズムは次のとおりです。

1.  キャッシュに一連のエントリ (800) が格納されたら、定期的に (分単位) キャッシュをスイープするタイマーを開始します。
2.  キャッシュスイープ中、エントリは LFRU (最も頻繁に使用されていない) のキャッシュから削除されます。 このアルゴリズムは、どのエントリを取り出すかを決定するときに、ヒットカウントと有効期間の両方を考慮します。
3.  キャッシュスイープが終了するたびに、キャッシュに800エントリが再度含まれます。

すべてのキャッシュエントリは、削除するエントリを決定するときに、同じように処理されます。 これは、CompiledQuery のストアコマンドが、Entity SQL クエリのストアコマンドと同じように削除される可能性があることを意味します。

キャッシュの削除タイマーは、キャッシュ内に800エンティティがあるときに開始されますが、キャッシュはこのタイマーが開始されてから60秒しかスイープされないことに注意してください。 つまり、最大60秒の場合、キャッシュのサイズが非常に大きくなる可能性があります。

#### <a name="323-test-metrics-demonstrating-query-plan-caching-performance"></a>クエリプランのキャッシュパフォーマンスを示す3.2.3 テストメトリック

アプリケーションのパフォーマンスに対するクエリプランのキャッシュの効果を示すために、Navision モデルに対して多数の Entity SQL クエリを実行したテストを実行しました。 Navision モデルの説明と実行されたクエリの種類については、「付録」を参照してください。 このテストでは、まずクエリの一覧を反復処理し、各クエリを1回ずつ実行してキャッシュに追加します (キャッシュが有効になっている場合)。 このステップは、時間がありません。 次に、メインスレッドを60秒以上スリープ状態にして、キャッシュスイープを実行できるようにします。最後に、キャッシュされたクエリを実行するために、2回目にリストを反復処理します。 さらに、SQL Server プランのキャッシュは、クエリの各セットが実行される前にフラッシュされます。これにより、クエリプランのキャッシュによって得られる利点が正確に反映されるようになります。

##### <a name="3231-test-results"></a>3.2.3.1 テスト結果

| テスト                                                                   | キャッシュなし EF5 | キャッシュされた EF5 | キャッシュなし EF6 | キャッシュされた EF6 |
|:-----------------------------------------------------------------------|:-------------|:-----------|:-------------|:-----------|
| すべての18723クエリの列挙                                          | 124          | 125.4      | 124.3        | 125.3      |
| スイープの回避 (複雑さに関係なく最初の800のクエリのみ)  | 41.7         | 5.5        | 40.5         | 5.4        |
| 集計の集計クエリのみ (スイープを回避する合計 178) | 39.5         | 4.5        | 38.1         | 4.6        |

*すべての時間 (秒単位)。*

教訓-多数の個別のクエリ (動的に作成されたクエリなど) を実行する場合、キャッシュは役に立ちません。また、キャッシュの結果として得られるキャッシュは、実際には、プランのキャッシュを使用した場合のパフォーマンスを向上させることができます。

集計の集計クエリは、テストしたクエリの中で最も複雑なクエリです。 クエリが複雑になるほど、クエリプランのキャッシュによって得られる利点が多くなります。

CompiledQuery は実際にはプランがキャッシュされた LINQ クエリであるため、CompiledQuery と同等の Entity SQL クエリの比較には同様の結果が得られます。 実際、アプリに多数の動的 Entity SQL クエリがある場合、キャッシュにクエリを入力すると、CompiledQueries がキャッシュからフラッシュされるときに、実質的に "逆コンパイル" されます。 このシナリオでは、動的クエリのキャッシュを無効にして CompiledQueries の優先順位を設定することにより、パフォーマンスが向上する場合があります。 しかし、もちろん、動的クエリではなく、パラメーター化クエリを使用するようにアプリケーションを書き直してください。

### <a name="33-using-compiledquery-to-improve-performance-with-linq-queries"></a>3.3 LINQ クエリで CompiledQuery を使用してパフォーマンスを向上させる

Microsoft のテストでは、CompiledQuery を使用すると、autocompiled された LINQ クエリで7% のメリットが得られることが示されています。つまり、Entity Framework スタックからコードを実行するのに7% 少ない時間を費やすことになります。アプリケーションが7% 高速であるという意味ではありません。 一般に、EF 5.0 での CompiledQuery オブジェクトの作成と保守にかかるコストは、利点と比較すると問題にならない可能性があります。 マイレージは異なる場合があるため、プロジェクトに余分なプッシュが必要な場合は、このオプションを選択してください。 CompiledQueries は ObjectContext 派生モデルとのみ互換性があり、DbContext 派生モデルと互換性がないことに注意してください。

CompiledQuery の作成と呼び出しの詳細については、「 [コンパイル済みクエリ (LINQ to Entities)](https://msdn.microsoft.com/library/bb896297.aspx)」を参照してください。

CompiledQuery を使用する場合は、次の2つの点を考慮する必要があります。つまり、静的インスタンスを使用する必要があり、省かによって発生する問題です。 ここでは、これら2つの考慮事項の詳細について説明します。

#### <a name="331-use-static-compiledquery-instances"></a>3.3.1 static CompiledQuery インスタンスを使用する

LINQ クエリのコンパイルは時間がかかるプロセスであるため、データベースからデータをフェッチする必要があるたびに、このクエリを実行しないようにします。 CompiledQuery インスタンスを使用すると、一度コンパイルして複数回実行できますが、同じ CompiledQuery インスタンスを何度もコンパイルするのではなく、毎回再利用する必要があります。 CompiledQuery インスタンスを格納するための静的メンバーの使用が必要になります。そうしないと、利点は得られません。

たとえば、選択したカテゴリの製品の表示を処理するために、ページに次のメソッド本体があるとします。

``` csharp
    // Warning: this is the wrong way of using CompiledQuery
    using (NorthwindEntities context = new NorthwindEntities())
    {
        string selectedCategory = this.categoriesList.SelectedValue;

        var productsForCategory = CompiledQuery.Compile<NorthwindEntities, string, IQueryable<Product>>(
            (NorthwindEntities nwnd, string category) =>
                nwnd.Products.Where(p => p.Category.CategoryName == category)
        );

        this.productsGrid.DataSource = productsForCategory.Invoke(context, selectedCategory).ToList();
        this.productsGrid.DataBind();
    }

    this.productsGrid.Visible = true;
```

この場合は、メソッドが呼び出されるたびに、新しい CompiledQuery インスタンスを作成します。 クエリプランキャッシュからストアコマンドを取得することによってパフォーマンス上の利点を確認するのではなく、新しいインスタンスが作成されるたびに CompiledQuery がプランコンパイラを経由します。 実際には、メソッドが呼び出されるたびに、新しい CompiledQuery エントリでクエリプランキャッシュに汚染されます。

代わりに、コンパイルされたクエリの静的インスタンスを作成する必要があるため、メソッドが呼び出されるたびに、同じコンパイル済みのクエリを呼び出すことになります。 これを行う方法の1つとして、CompiledQuery インスタンスをオブジェクトコンテキストのメンバーとして追加する方法があります。次に、ヘルパーメソッドを使用して CompiledQuery にアクセスすることにより、これを簡単に行うことができます。

``` csharp
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IEnumerable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
            );

        public IEnumerable<Product> GetProductsForCategory(string categoryName)
        {
            return productsForCategoryCQ.Invoke(this, categoryName).ToList();
        }
```

このヘルパーメソッドは次のように呼び出されます。

``` csharp
    this.productsGrid.DataSource = context.GetProductsForCategory(selectedCategory);
```

#### <a name="332-composing-over-a-compiledquery"></a>3.3.2 CompiledQuery を構成する

LINQ クエリを構成する機能は非常に便利です。これを行うには、 *Skip ()* や *Count ()* などの IQueryable の後にメソッドを呼び出すだけです。 ただし、これを行うと、実質的に新しい IQueryable オブジェクトが返されます。 技術的には CompiledQuery の構成を防ぐことはできませんが、これを行うと、プランコンパイラを再度渡す必要がある新しい IQueryable オブジェクトが生成されます。

一部のコンポーネントでは、構成済みの IQueryable オブジェクトを使用して高度な機能を有効にします。 たとえば、ASP のようにします。ネットワークの GridView は、SelectMethod プロパティを使用して IQueryable オブジェクトにデータバインドできます。 次に、GridView がこの IQueryable オブジェクトを構成して、データモデルに対する並べ替えとページングを可能にします。 ご覧のように、GridView に CompiledQuery を使用しても、コンパイルされたクエリにはヒットしませんが、新しい autocompiled 済みクエリが生成されます。

これには、クエリにプログレッシブフィルターを追加する場合があります。 たとえば、オプションのフィルター (Country や OrdersCount など) に対して複数のドロップダウンリストを含む Customers ページがあるとします。 CompiledQuery の IQueryable の結果に対してこれらのフィルターを構成できますが、これを行うと、実行するたびに新しいクエリがプランコンパイラを通過します。

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployee();

        if (this.orderCountFilterList.SelectedItem.Value != defaultFilterText)
        {
            int orderCount = int.Parse(orderCountFilterList.SelectedValue);
            myCustomers = myCustomers.Where(c => c.Orders.Count > orderCount);
        }

        if (this.countryFilterList.SelectedItem.Value != defaultFilterText)
        {
            myCustomers = myCustomers.Where(c => c.Address.Country == countryFilterList.SelectedValue);
        }

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 この再コンパイルを回避するには、考えられるフィルターを考慮して CompiledQuery を書き直します。

``` csharp
    private static readonly Func<NorthwindEntities, int, int?, string, IQueryable<Customer>> customersForEmployeeWithFiltersCQ = CompiledQuery.Compile(
        (NorthwindEntities context, int empId, int? countFilter, string countryFilter) =>
            context.Customers.Where(c => c.Orders.Any(o => o.EmployeeID == empId))
            .Where(c => countFilter.HasValue == false || c.Orders.Count > countFilter)
            .Where(c => countryFilter == null || c.Address.Country == countryFilter)
        );
```

これは、次のような UI で呼び出されます。

``` csharp
    using (NorthwindEntities context = new NorthwindEntities())
    {
        int? countFilter = (this.orderCountFilterList.SelectedIndex == 0) ?
            (int?)null :
            int.Parse(this.orderCountFilterList.SelectedValue);

        string countryFilter = (this.countryFilterList.SelectedIndex == 0) ?
            null :
            this.countryFilterList.SelectedValue;

        IQueryable<Customer> myCustomers = context.InvokeCustomersForEmployeeWithFilters(
                countFilter, countryFilter);

        this.customersGrid.DataSource = myCustomers;
        this.customersGrid.DataBind();
    }
```

 ここでのトレードオフとして、生成されたストアコマンドには常に null チェック付きのフィルターがありますが、データベースサーバーを最適化するには非常に簡単である必要があります。

``` SQL
...
WHERE ((0 = (CASE WHEN (@p__linq__1 IS NOT NULL) THEN cast(1 as bit) WHEN (@p__linq__1 IS NULL) THEN cast(0 as bit) END)) OR ([Project3].[C2] > @p__linq__2)) AND (@p__linq__3 IS NULL OR [Project3].[Country] = @p__linq__4)
```

### <a name="34-metadata-caching"></a>3.4 メタデータのキャッシュ

Entity Framework では、メタデータのキャッシュもサポートされています。 これは基本的に、同じモデルへの異なる接続間での型情報と型対データベースマッピング情報のキャッシュです。 メタデータキャッシュは、AppDomain ごとに一意です。

#### <a name="341-metadata-caching-algorithm"></a>3.4.1 Metadata キャッシュアルゴリズム

1.  モデルのメタデータ情報は、各 EntityConnection の ItemCollection に格納されます。
    -   注として、モデルのさまざまな部分に異なる ItemCollection オブジェクトがあります。 たとえば、StoreItemCollections には、データベースモデルに関する情報が含まれています。ObjectItemCollection には、データモデルに関する情報が含まれています。EdmItemCollection には、概念モデルに関する情報が含まれています。

2.  2つの接続が同じ接続文字列を使用する場合は、同じ ItemCollection インスタンスを共有します。
3.  機能的に同等の接続文字列では、異なるメタデータキャッシュが生成される可能性があります。 接続文字列をトークン化するので、トークンの順序を変更するだけで、共有メタデータが生成されます。 しかし、機能的に同じように見える2つの接続文字列は、トークン化後に同一として評価されない場合があります。
4.  ItemCollection は、使用するために定期的にチェックされます。 ワークスペースが最近アクセスされていないと判断された場合は、次回のキャッシュスイープでクリーンアップ用にマークされます。
5.  EntityConnection を作成するだけで、メタデータキャッシュが作成されます (ただし、接続が開かれるまで、その中の項目コレクションは初期化されません)。 このワークスペースは、"使用中" ではないことがキャッシュアルゴリズムによって判断されるまで、メモリ内に残ります。

お客様のアドバイザリチームは、大規模なモデルを使用する場合に "廃止" を避けるために、ItemCollection への参照を保持することを説明するブログ記事を執筆しまし \<https://docs.microsoft.com/archive/blogs/appfabriccat/holding-a-reference-to-the-ef-metadataworkspace-for-wcf-services> た。

#### <a name="342-the-relationship-between-metadata-caching-and-query-plan-caching"></a>メタデータのキャッシュとクエリプランのキャッシュの関係を3.4.2

クエリプランのキャッシュインスタンスは、MetadataWorkspace のストア型の ItemCollection に存在します。 つまり、キャッシュされたストアコマンドは、特定の MetadataWorkspace を使用してインスタンス化されたコンテキストに対してクエリを実行するために使用されます。 また、2つの接続文字列が少し異なり、トークン化後に一致しない場合は、クエリプランのキャッシュインスタンスが異なることになります。

### <a name="35-results-caching"></a>3.5 結果のキャッシュ

結果のキャッシュ ("第2レベルのキャッシュ" とも呼ばれます) を使用すると、クエリの結果をローカルキャッシュに保持できます。 クエリを発行するときは、まず、ストアに対してクエリを実行する前に、結果をローカルで使用できるかどうかを確認します。 Entity Framework では結果のキャッシュが直接サポートされていませんが、ラッピングプロバイダーを使用して第2レベルのキャッシュを追加することができます。 2番目のレベルのキャッシュを使用してプロバイダーをラップする例は、 [NCache に基づく Entity Framework 第2レベルのキャッシュ](https://www.alachisoft.com/ncache/entity-framework.html)です。

この第2レベルのキャッシュの実装は、LINQ 式の評価 (および funcletized) 後に行われる挿入された機能であり、クエリ実行プランが最初のレベルのキャッシュから計算または取得されます。 2番目のレベルのキャッシュでは、生のデータベースの結果だけが格納されるため、具体化パイプラインは後でも実行されます。

#### <a name="351-additional-references-for-results-caching-with-the-wrapping-provider"></a>3.5.1 ラッププロバイダーを使用した結果のキャッシュに関するその他の参照情報

-   ジュリー Lerman は、Windows Server AppFabric のキャッシュを使用するようにサンプルラッピングプロバイダーを更新する方法を含む、Entity Framework と Windows Azure での第2レベルのキャッシュに関する MSDN 記事を執筆しました。 [https://msdn.microsoft.com/magazine/hh394143.aspx](https://msdn.microsoft.com/magazine/hh394143.aspx)
-   Entity Framework 5 で作業している場合、チームのブログには、Entity Framework 5 のキャッシュプロバイダーで実行する方法を説明する投稿があります \<https://docs.microsoft.com/archive/blogs/adonet/ef-caching-with-jarek-kowalskis-provider> 。 また、2番目のレベルのキャッシュをプロジェクトに自動的に追加するための T4 テンプレートも含まれています。

## <a name="4-autocompiled-queries"></a>4 autocompiled クエリ

Entity Framework を使用してデータベースに対してクエリを実行する場合は、実際に結果を具体化する前に一連の手順を実行する必要があります。このような手順の1つは、クエリのコンパイルです。 Entity SQL のクエリは自動的にキャッシュされるため、パフォーマンスが良好であるとわかっています。そのため、同じクエリを2回目または3回実行すると、プランコンパイラをスキップし、キャッシュされたプランを代わりに使用できます。

Entity Framework 5 では、LINQ to Entities クエリの自動キャッシュも導入されました。 Entity Framework の過去のエディションでは、パフォーマンスを向上させるために CompiledQuery を作成するのが一般的です。これは、LINQ to Entities クエリをキャッシュ可能にするためです。 キャッシュは CompiledQuery を使用せずに自動的に実行されるため、この機能を "autocompiled されたクエリ" と呼びます。 クエリプランのキャッシュとそのしくみの詳細については、「クエリプランのキャッシュ」を参照してください。

Entity Framework は、クエリを再コンパイルする必要があるかどうかを検出し、以前にコンパイルされた場合でもクエリが呼び出されたときにそのクエリを実行します。 クエリの再コンパイルの原因となる一般的な条件は次のとおりです。

-   クエリに関連付けられている MergeOption を変更します。 キャッシュされたクエリは使用されません。代わりに、プランコンパイラが再度実行され、新しく作成されたプランがキャッシュされます。
-   ContextOptions の値を変更します。 MergeOption を変更するのと同じ効果が得られます。

その他の条件により、クエリでキャッシュを使用できなくなる場合があります。 一般的な例を次に示します。

-   IEnumerable T を使用し &lt; &gt; ます。&lt; &gt; (T 値) を格納します。
-   定数を使用してクエリを生成する関数を使用します。
-   マップされていないオブジェクトのプロパティを使用します。
-   再コンパイルが必要な別のクエリにクエリをリンクします。

### <a name="41-using-ienumerablelttgtcontainslttgtt-value"></a>4.1 IEnumerable T を使用して &lt; &gt; います。&lt;T &gt; (t 値) を含む

Entity Framework では、IEnumerable T を呼び出すクエリはキャッシュされません &lt; &gt; 。&lt; &gt; コレクションの値は volatile と見なされるため、メモリ内コレクションに対して t (t 値) が格納されます。 次のクエリ例はキャッシュされないため、常にプランコンパイラによって処理されます。

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var query = context.MyEntities
                    .Where(entity => ids.Contains(entity.Id));

    var results = query.ToList();
    ...
}
```

Contains が実行される IEnumerable のサイズによって、クエリのコンパイル速度や速度が決まります。 上の例に示されているような大きなコレクションを使用すると、パフォーマンスが大幅に低下する可能性があります。

Entity Framework 6 では、IEnumerable T の最適化が含まれてい &lt; &gt; ます。&lt; &gt; クエリが実行されるときには、t (t 値) を含みます。 生成される SQL コードは、生成され、読みやすくなります。また、ほとんどの場合、サーバーでもより高速に実行されます。

### <a name="42-using-functions-that-produce-queries-with-constants"></a>4.2 定数を使用したクエリを生成する関数の使用

Skip ()、Take ()、Contains ()、および Def/Tifempty () LINQ 演算子は、パラメーターを使用して SQL クエリを生成するのではなく、値を定数として渡します。 このため、それ以外の場合は、クエリプランのキャッシュが EF stack とデータベースサーバーの両方に汚染され、その後のクエリ実行で同じ定数が使用されていない限り、再利用されません。 次に例を示します。

``` csharp
var id = 10;
...
using (var context = new MyContext())
{
    var query = context.MyEntities.Select(entity => entity.Id).Contains(id);

    var results = query.ToList();
    ...
}
```

この例では、このクエリが id に対して異なる値を使用して実行されるたびに、クエリが新しいプランにコンパイルされます。

特に、ページングを行うときに Skip と Take を使用することに注意してください。 EF6 では、これらのメソッドには、キャッシュされたクエリプランを効果的に再利用できるようにするラムダオーバーロードがあります。 EF はこれらのメソッドに渡された変数をキャプチャし、SQLparameters に変換することができます。 これによってキャッシュクリーナーを維持することもできます。それ以外の場合、Skip と Take の異なる定数を使用する各クエリは、独自のクエリプランキャッシュエントリを取得します。

次のコードについて考えてみます。これは最適ではありませんが、このクラスのクエリを知性することのみを目的としています。

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

この同じコードのより高速なバージョンでは、ラムダを使用した Skip の呼び出しが必要になります。

``` csharp
var customers = context.Customers.OrderBy(c => c.LastName);
for (var i = 0; i < count; ++i)
{
    var currentCustomer = customers.Skip(() => i).FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

2番目のスニペットは、クエリが実行されるたびに同じクエリプランが使用されるため、最大で11% 高速に実行されます。これにより、CPU 時間が節約され、クエリキャッシュの汚染を回避できます。 さらに、スキップするパラメーターはクロージャ内にあるため、コードは次のようになります。

``` csharp
var i = 0;
var skippyCustomers = context.Customers.OrderBy(c => c.LastName).Skip(() => i);
for (; i < count; ++i)
{
    var currentCustomer = skippyCustomers.FirstOrDefault();
    ProcessCustomer(currentCustomer);
}
```

### <a name="43-using-the-properties-of-a-non-mapped-object"></a>4.3 マップされていないオブジェクトのプロパティを使用する

クエリで、マップされていないオブジェクトの種類のプロパティをパラメーターとして使用する場合、クエリはキャッシュされません。 次に例を示します。

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();

    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myObject.MyProperty)
                select entity;

   var results = query.ToList();
    ...
}
```

この例では、NonMappedType クラスがエンティティモデルの一部ではないとします。 このクエリは、マップされていない型を使用しないように簡単に変更できます。代わりに、クエリのパラメーターとしてローカル変数を使用します。

``` csharp
using (var context = new MyContext())
{
    var myObject = new NonMappedType();
    var myValue = myObject.MyProperty;
    var query = from entity in context.MyEntities
                where entity.Name.StartsWith(myValue)
                select entity;

    var results = query.ToList();
    ...
}
```

この場合、クエリはキャッシュされ、クエリプランキャッシュの恩恵を受けることができます。

### <a name="44-linking-to-queries-that-require-recompiling"></a>4.4 再コンパイルが必要なクエリへのリンク

前と同じ例に従って、再コンパイルが必要なクエリに依存する2番目のクエリがある場合、2番目のクエリも再コンパイルされます。 このシナリオを説明する例を次に示します。

``` csharp
int[] ids = new int[10000];
...
using (var context = new MyContext())
{
    var firstQuery = from entity in context.MyEntities
                        where ids.Contains(entity.Id)
                        select entity;

    var secondQuery = from entity in context.MyEntities
                        where firstQuery.Any(otherEntity => otherEntity.Id == entity.Id)
                        select entity;

    var results = secondQuery.ToList();
    ...
}
```

この例はジェネリックですが、firstQuery へのリンクによって、クエリがキャッシュされないようにする方法を示しています。 最初のクエリが再コンパイルを必要とするクエリでなかった場合、そのクエリはキャッシュされています。

## <a name="5-notracking-queries"></a>5個の NoTracking クエリ

### <a name="51-disabling-change-tracking-to-reduce-state-management-overhead"></a>5.1 変更の追跡を無効にして状態管理のオーバーヘッドを削減する

読み取り専用のシナリオで、ObjectStateManager にオブジェクトを読み込むオーバーヘッドを回避する必要がある場合は、"追跡しない" クエリを発行できます。変更の追跡は、クエリレベルで無効にすることができます。

ただし、変更の追跡を無効にすることで、オブジェクトキャッシュを効果的に無効にすることに注意してください。 エンティティに対してクエリを実行する場合、以前に具体化されたクエリの結果を ObjectStateManager からプルすることで、具体化をスキップすることはできません。 同じコンテキストで同じエンティティに対して繰り返しクエリを実行する場合、変更の追跡を有効にすると、パフォーマンス上の利点が得られる可能性があります。

ObjectContext を使用してクエリを実行する場合、ObjectQuery インスタンスと ObjectSet インスタンスは、設定されると、MergeOption を記憶します。これらのインスタンスで構成されるクエリは、親クエリの有効な MergeOption を継承します。 DbContext を使用する場合、Dbcontext で AsNoTracking () 修飾子を呼び出すことによって追跡を無効にすることができます。

#### <a name="511-disabling-change-tracking-for-a-query-when-using-dbcontext"></a>5.1.1 DbContext を使用する場合のクエリの変更の追跡の無効化

クエリで AsNoTracking () メソッドの呼び出しを連結することによって、クエリのモードを NoTracking に切り替えることができます。 ObjectQuery とは異なり、Dbset API の DbSet および Dbset クラスには、MergeOption の変更可能なプロパティがありません。

``` csharp
    var productsForCategory = from p in context.Products.AsNoTracking()
                                where p.Category.CategoryName == selectedCategory
                                select p;


```

#### <a name="512-disabling-change-tracking-at-the-query-level-using-objectcontext"></a>5.1.2 ObjectContext を使用してクエリレベルで変更の追跡を無効にする

``` csharp
    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;

    ((ObjectQuery)productsForCategory).MergeOption = MergeOption.NoTracking;
```

#### <a name="513-disabling-change-tracking-for-an-entire-entity-set-using-objectcontext"></a>5.1.3 ObjectContext を使用してエンティティセット全体の変更の追跡を無効にする

``` csharp
    context.Products.MergeOption = MergeOption.NoTracking;

    var productsForCategory = from p in context.Products
                                where p.Category.CategoryName == selectedCategory
                                select p;
```

### <a name="52test-metrics-demonstrating-the-performance-benefit-of-notracking-queries"></a>5.2 NoTracking クエリのパフォーマンス上の利点を示す、テストメトリック

このテストでは、追跡を Navision モデルの NoTracking クエリと比較することによって、ObjectStateManager の読み込みにかかるコストを確認します。 Navision モデルの説明と実行されたクエリの種類については、「付録」を参照してください。 このテストでは、クエリの一覧を反復処理し、各クエリを1回ずつ実行します。 2種類のテストを実行しました。1回は NoTracking クエリ、もう1回は "AppendOnly" の既定のマージオプションです。 各バリエーションを3回実行し、実行の平均値を取得しました。 テストの間に、SQL Server のクエリキャッシュをクリアし、次のコマンドを実行して tempdb を圧縮します。

1.  DBCC DROPCLEANBUFFERS
2.  DBCC FREEPROCCACHE
3.  DBCC SHRINKDATABASE (tempdb、0)

テスト結果、3回を超える実行:

|                        | 追跡なし–作業セット | 追跡なし–時間 | 追加のみ-ワーキングセット | 追加のみ–時間 |
|:-----------------------|:--------------------------|:-------------------|:--------------------------|:-------------------|
| **Entity Framework 5** | 460361728                 | 1163536ミリ秒         | 596545536                 | 1273042ミリ秒         |
| **Entity Framework 6** | 647127040                 | 190228ミリ秒          | 832798720                 | 195521ミリ秒          |

Entity Framework 5 では Entity Framework 6 の場合よりも、実行の終了時にメモリフットプリントが小さくなります。 Entity Framework 6 によって消費される追加メモリは、新しい機能を有効にし、パフォーマンスを向上させるための追加のメモリ構造とコードの結果になります。

また、ObjectStateManager を使用する場合、メモリフットプリントにも明確な違いがあります。 Entity Framework 5 では、データベースから具体化されたすべてのエンティティを追跡するときに、フットプリントを30% 増やしました。 Entity Framework 6 では、その場合、フットプリントは28% 増加しています。

時間については、Entity Framework 6 は、このテストでは大きな余白によって 5 Entity Framework を意味します。 Entity Framework 6 は、Entity Framework 5 によって消費された時間の約16% でテストを完了しました。 また、ObjectStateManager が使用されている場合、Entity Framework 5 は完了するまでに9% の時間がかかります。 これに対し、Entity Framework 6 では、ObjectStateManager の使用時に3% の時間が使用されています。

## <a name="6-query-execution-options"></a>6クエリ実行オプション

Entity Framework は、いくつかの異なる方法でクエリを実行できます。 次のオプションを見て、それぞれの長所と短所を比較し、パフォーマンス特性を確認します。

-   LINQ to Entities。
-   追跡 LINQ to Entities がありません。
-   ObjectQuery を Entity SQL します。
-   EntityCommand を Entity SQL します。
-   System.data.objects.objectcontext.executestorequery.
-   SqlQuery.
-   CompiledQuery.

### <a name="61-linq-to-entities-queries"></a>6.1 LINQ to Entities のクエリ

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

**長所**

-   CUD 操作に適しています。
-   完全に具体化したオブジェクト。
-   プログラミング言語に組み込まれている構文で記述するのが最も簡単です。
-   優れたパフォーマンス。

**短所**

-   次のような特定の技術的制限。
    -   外部結合クエリで DefaultIfEmpty を使用するパターンは、Entity SQL の単純外部結合ステートメントよりも複雑なクエリになります。
    -   一般的なパターンマッチングと同様にを使用することはできません。

### <a name="62-no-tracking-linq-to-entities-queries"></a>6.2 LINQ to Entities クエリは追跡しません

コンテキストが ObjectContext を派生する場合:

``` csharp
context.Products.MergeOption = MergeOption.NoTracking;
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
```

コンテキストが DbContext を派生する場合:

``` csharp
var q = context.Products.AsNoTracking()
                        .Where(p => p.Category.CategoryName == "Beverages");
```

**長所**

-   通常の LINQ クエリよりもパフォーマンスが向上しました。
-   完全に具体化したオブジェクト。
-   プログラミング言語に組み込まれている構文で記述するのが最も簡単です。

**短所**

-   CUD 操作には適していません。
-   次のような特定の技術的制限。
    -   外部結合クエリで DefaultIfEmpty を使用するパターンは、Entity SQL の単純外部結合ステートメントよりも複雑なクエリになります。
    -   一般的なパターンマッチングと同様にを使用することはできません。

NoTracking が指定されていない場合でも、スカラープロパティを射影するクエリは追跡されないことに注意してください。 次に例を示します。

``` csharp
var q = context.Products.Where(p => p.Category.CategoryName == "Beverages").Select(p => new { p.ProductName });
```

この特定のクエリでは、明示的に NoTracking が指定されていませんが、オブジェクト状態マネージャーが認識している型を具体化していないため、具体化された結果は追跡されません。

### <a name="63-entity-sql-over-an-objectquery"></a>6.3 ObjectQuery 上での Entity SQL

``` csharp
ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
```

**長所**

-   CUD 操作に適しています。
-   完全に具体化したオブジェクト。
-   クエリプランのキャッシュをサポートします。

**短所**

-   には、言語に組み込まれているクエリの構造よりもユーザーエラーが発生しやすいテキストクエリ文字列が含まれています。

### <a name="64-entity-sql-over-an-entity-command"></a>6.4 Entity コマンドの Entity SQL

``` csharp
EntityCommand cmd = eConn.CreateCommand();
cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
{
    while (reader.Read())
    {
        // manually 'materialize' the product
    }
}
```

**長所**

-   は、.NET 4.0 のクエリプランのキャッシュをサポートしています (プランキャッシュは、.NET 4.5 の他のすべての種類のクエリでサポートされています)。

**短所**

-   には、言語に組み込まれているクエリの構造よりもユーザーエラーが発生しやすいテキストクエリ文字列が含まれています。
-   CUD 操作には適していません。
-   結果は自動的に具体化されず、データリーダーから読み取る必要があります。

### <a name="65-sqlquery-and-executestorequery"></a>6.5 SqlQuery と ExecuteStoreQuery

データベースに対する SqlQuery:

``` csharp
// use this to obtain entities and not track them
var q1 = context.Database.SqlQuery<Product>("select * from products");
```

DbSet に対する SqlQuery:

``` csharp
// use this to obtain entities and have them tracked
var q2 = context.Products.SqlQuery("select * from products");
```

ExecyteStoreQuery:

``` csharp
var beverages = context.ExecuteStoreQuery<Product>(
@"     SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued, P.DiscontinuedDate
       FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
       WHERE        (C.CategoryName = 'Beverages')"
);
```

**長所**

-   通常、plan コンパイラをバイパスした後のパフォーマンスが最速になります。
-   完全に具体化したオブジェクト。
-   DbSet から使用する場合の CUD 操作に適しています。

**短所**

-   クエリはテキストであり、エラーが発生しやすくなります。
-   クエリは、概念セマンティクスではなくストアセマンティクスを使用して、特定のバックエンドに関連付けられています。
-   継承が存在する場合、handcrafted クエリは、要求された型のマッピング条件を考慮する必要があります。

### <a name="66-compiledquery"></a>6.6 CompiledQuery

``` csharp
private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
    (NorthwindEntities context, string categoryName) =>
        context.Products.Where(p => p.Category.CategoryName == categoryName)
        );
…
var q = context.InvokeProductsForCategoryCQ("Beverages");
```

**長所**

-   は、通常の LINQ クエリよりも最大7% のパフォーマンス向上を実現します。
-   完全に具体化したオブジェクト。
-   CUD 操作に適しています。

**短所**

-   複雑さとプログラミングのオーバーヘッドが増加します。
-   コンパイルされたクエリの上に作成すると、パフォーマンスが向上します。
-   一部の LINQ クエリは、匿名型の射影など、CompiledQuery として書き込むことはできません。

### <a name="67-performance-comparison-of-different-query-options"></a>6.7 さまざまなクエリオプションのパフォーマンス比較

コンテキストの作成がタイムアウトしていない単純なマイクロベンチマークがテストに配置されました。 管理された環境で、キャッシュされていないエンティティのセットに対して、5000回のクエリを実行することを測定しています。 これらの数値には、アプリケーションによって生成される実際の数値は反映されませんが、新しいコンテキストを作成するコストを除いて、異なるクエリオプションを使用した場合に発生するパフォーマンスの差異の程度を正確に測定することができます。

| EF  | テスト                                 | 時間 (ミリ秒) | メモリ   |
|:----|:-------------------------------------|:----------|:---------|
| EF5 | ObjectContext ESQL                   | 2414      | 38801408 |
| EF5 | ObjectContext Linq クエリ             | 2692      | 38277120 |
| EF5 | DbContext Linq クエリの追跡なし     | 2818      | 41840640 |
| EF5 | DbContext Linq クエリ                 | 2930      | 41771008 |
| EF5 | ObjectContext Linq クエリの追跡なし | 3013      | 38412288 |
|     |                                      |           |          |
| EF6 | ObjectContext ESQL                   | 2059      | 46039040 |
| EF6 | ObjectContext Linq クエリ             | 3,074      | 45248512 |
| EF6 | DbContext Linq クエリの追跡なし     | 3125      | 47575040 |
| EF6 | DbContext Linq クエリ                 | 3420      | 47652864 |
| EF6 | ObjectContext Linq クエリの追跡なし | 3593      | 45260800 |

![EF5 マイクロベンチマーク、5000ウォームイテレーション](~/ef6/media/ef5micro5000warm.png)

![EF6 マイクロベンチマーク、5000ウォームイテレーション](~/ef6/media/ef6micro5000warm.png)

マイクロベンチマークは、コードの小さな変更に非常に敏感です。 この場合、Entity Framework 5 と Entity Framework 6 のコストの差は、 [インターセプト](xref:ef6/fundamentals/logging-and-interception) と [トランザクションの機能強化](xref:ef6/saving/transactions)が追加されているためです。 ただし、これらのマイクロベンチマーク数値は、Entity Framework が何を行うかをごくわずかな部分に分割したものです。 ウォームクエリの実際のシナリオでは、Entity Framework 5 から Entity Framework 6 にアップグレードした場合、パフォーマンスが低下することはありません。

さまざまなクエリオプションの実際のパフォーマンスを比較するために、別のクエリオプションを使用してカテゴリ名が "飲み物" であるすべての製品を選択する5つの個別のテストバリエーションを作成しました。 各イテレーションには、コンテキストを作成するコストと、返されたすべてのエンティティを具体化するコストが含まれます。 10回のイテレーションは、時間が1000のイテレーションの合計を取得する前に、タイムアウトしません。 表示される結果は、各テストの5回の実行で行われた実行の中央値です。 詳細については、テスト用のコードが含まれている付録 B を参照してください。

| EF  | テスト                                        | 時間 (ミリ秒) | メモリ   |
|:----|:--------------------------------------------|:----------|:---------|
| EF5 | ObjectContext エンティティコマンド                | 621       | 39350272 |
| EF5 | データベースに対する DbContext Sql クエリ             | 825       | 37519360 |
| EF5 | ObjectContext ストアクエリ                   | 878       | 39460864 |
| EF5 | ObjectContext Linq クエリの追跡なし        | 969       | 38293504 |
| EF5 | オブジェクトクエリを使用した ObjectContext エンティティ Sql | 1089      | 38981632 |
| EF5 | ObjectContext コンパイル済みクエリ                | 1099      | 38682624 |
| EF5 | ObjectContext Linq クエリ                    | 1152      | 38178816 |
| EF5 | DbContext Linq クエリの追跡なし            | 1208      | 41803776 |
| EF5 | Dbcontext に対する DbContext Sql クエリ                | 1414      | 37982208 |
| EF5 | DbContext Linq クエリ                        | 1574      | 41738240 |
|     |                                             |           |          |
| EF6 | ObjectContext エンティティコマンド                | 480       | 47247360 |
| EF6 | ObjectContext ストアクエリ                   | 493       | 46739456 |
| EF6 | データベースに対する DbContext Sql クエリ             | 614       | 41607168 |
| EF6 | ObjectContext Linq クエリの追跡なし        | 684       | 46333952 |
| EF6 | オブジェクトクエリを使用した ObjectContext エンティティ Sql | 767       | 48865280 |
| EF6 | ObjectContext コンパイル済みクエリ                | 788       | 48467968 |
| EF6 | DbContext Linq クエリの追跡なし            | 878       | 47554560 |
| EF6 | ObjectContext Linq クエリ                    | 953       | 47632384 |
| EF6 | Dbcontext に対する DbContext Sql クエリ                | 1023      | 41992192 |
| EF6 | DbContext Linq クエリ                        | 1290      | 47529984 |


![EF5 ウォームクエリ1000イテレーション](~/ef6/media/ef5warmquery1000.png)

![EF6 ウォームクエリ1000イテレーション](~/ef6/media/ef6warmquery1000.png)

> [!NOTE]
> 完全を期すために、EntityCommand に対してクエリ Entity SQL を実行するバリエーションを含めています。 ただし、このようなクエリの結果は具体化されていないため、比較は必ずしも公平なものではありません。 このテストには、比較の fairer を試すための、具体化の近似値が含まれています。

このエンドツーエンドのケースでは、Entity Framework 6 は、スタックのいくつかの部分でパフォーマンスが向上したため、Entity Framework 5 を上回ることになります。これには、DbContext の初期化や、より迅速な MetadataCollection 検索などが含ま &lt; &gt; れます。

## <a name="7-design-time-performance-considerations"></a>7デザイン時のパフォーマンスに関する考慮事項

### <a name="71-inheritance-strategies"></a>7.1 継承戦略

Entity Framework を使用する場合のパフォーマンスに関するもう1つの考慮事項は、使用する継承方法です。 Entity Framework では、3種類の基本的な継承とその組み合わせがサポートされています。

-   階層あたりのテーブル (TPH) –各継承セットは、列で表されている階層内の特定の型を示す識別子列を持つテーブルにマップされます。
-   種類ごとのテーブル (TPT) –各型には、データベース内に独自のテーブルがあります。子テーブルは、親テーブルに含まれていない列のみを定義します。
-   テーブルごとのテーブル (TPC) –各型には、データベース内に独自の完全なテーブルがあります。子テーブルは、親の型で定義されているものも含め、すべてのフィールドを定義します。

モデルで TPT 継承が使用されている場合、生成されるクエリは、他の継承戦略で生成されるクエリよりも複雑になります。そのため、ストアの実行時間が長くなる可能性があります。通常、TPT モデルに対してクエリを生成し、結果のオブジェクトを具体化するのに時間がかかります。

Entity Framework に関する MSDN のブログ記事「」の「TPT を使用する場合のパフォーマンスに関する考慮事項 (型ごとのテーブル) の継承」を参照してください \<https://docs.microsoft.com/archive/blogs/adonet/performance-considerations-when-using-tpt-table-per-type-inheritance-in-the-entity-framework> 。

#### <a name="711-avoiding-tpt-in-model-first-or-code-first-applications"></a>Model First または Code First アプリケーションの7.1.1 を回避する

TPT スキーマを持つ既存のデータベースに対してモデルを作成する場合、多くのオプションはありません。 ただし、Model First または Code First を使用してアプリケーションを作成する場合は、パフォーマンスの問題に対する TPT 継承を避ける必要があります。

Entity Designer ウィザードで Model First を使用すると、モデル内のすべての継承について TPT が得られます。 Model First で TPH 継承戦略に切り替える場合は、Visual Studio ギャラリー () から利用可能な "Entity Designer データベース生成パワーパック" を使用でき \<http://visualstudiogallery.msdn.microsoft.com/df3541c3-d833-4b65-b942-989e7ec74c87/> ます。

Code First を使用して、継承によってモデルのマッピングを構成する場合、EF では既定で TPH が使用されるため、継承階層内のすべてのエンティティが同じテーブルにマップされます。 詳細については、MSDN マガジンの「Code First in Entity Framework 4.1」 () の「Fluent API を使用したマッピング」セクションを参照してください [http://msdn.microsoft.com/magazine/hh126815.aspx](https://msdn.microsoft.com/magazine/hh126815.aspx) 。

### <a name="72-upgrading-from-ef4-to-improve-model-generation-time"></a>7.2 モデルの生成時間を向上させるための EF4 からのアップグレード

モデルのストア層 (SSDL) を生成するアルゴリズムに対する SQL Server 固有の向上は、Visual Studio 2010 SP1 がインストールされている場合に Entity Framework 5 と6、および Entity Framework 4 の更新プログラムとして使用できます。 次のテスト結果は、非常に大規模なモデル (この場合は Navision モデル) を生成するときの改善点を示しています。 詳細については、「付録 C」を参照してください。

このモデルには、1005エンティティセットと4227アソシエーションセットが含まれています。

| 構成                              | 消費された時間の内訳                                                                                                                                               |
|:-------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Visual Studio 2010、Entity Framework 4     | SSDL Generation: 2 時間27分 <br/> マッピングの生成: 1 秒 <br/> CSDL の生成: 1 秒 <br/> ObjectLayer の生成: 1 秒 <br/> ビュー生成: 2 h 14 分 |
| Visual Studio 2010 SP1、Entity Framework 4 | SSDL Generation: 1 秒 <br/> マッピングの生成: 1 秒 <br/> CSDL の生成: 1 秒 <br/> ObjectLayer の生成: 1 秒 <br/> ビューの生成: 1 時間53分   |
| Visual Studio 2013、Entity Framework 5     | SSDL Generation: 1 秒 <br/> マッピングの生成: 1 秒 <br/> CSDL の生成: 1 秒 <br/> ObjectLayer の生成: 1 秒 <br/> ビュー生成:65 分    |
| Visual Studio 2013、Entity Framework 6     | SSDL Generation: 1 秒 <br/> マッピングの生成: 1 秒 <br/> CSDL の生成: 1 秒 <br/> ObjectLayer の生成: 1 秒 <br/> ビューの生成:28 秒。   |


SSDL を生成するときに、負荷はほぼすべて SQL Server で費やされていますが、クライアント開発マシンはサーバーから結果が返されるまで待機しています。 Dba は、特にこの改善に感謝します。 また、基本的には、モデルの生成のコスト全体が、ビューの生成時に反映されることに注意してください。

### <a name="73-splitting-large-models-with-database-first-and-model-first"></a>7.3 Database First と Model First を使用した大規模なモデルの分割

モデルのサイズが増加するにつれて、デザイナー画面が乱雑になり、使用が困難になります。 通常、デザイナーを効果的に使用するには、300個を超えるエンティティを含むモデルが大きすぎると考えられます。 次のブログ投稿では、大規模なモデルを分割するためのいくつかのオプションについて説明し \<https://docs.microsoft.com/archive/blogs/adonet/working-with-large-models-in-entity-framework-part-2> ます。

この投稿は Entity Framework の最初のバージョン用に書かれていますが、手順は引き続き適用されます。

### <a name="74-performance-considerations-with-the-entity-data-source-control"></a>7.4 Entity Data Source Control でのパフォーマンスに関する考慮事項

EntityDataSource コントロールを使用する web アプリケーションのパフォーマンスが大幅に低下している、マルチスレッドのパフォーマンステストとストレステストのケースを見てきました。 根底にある原因は、EntityDataSource が、エンティティとして使用される型を検出するために、Web アプリケーションによって参照されるアセンブリに対して LoadFromAssembly を繰り返し呼び出すことです。

解決策は、EntityDataSource の ContextTypeName を派生した ObjectContext クラスの型名に設定することです。 これにより、参照されるすべてのアセンブリをエンティティ型に対してスキャンするメカニズムが無効になります。

また、[ContextTypeName] フィールドを設定すると、リフレクションを介してアセンブリから型を読み込むことができない場合に、.NET 4.0 の EntityDataSource が ReflectionTypeLoadException をスローする機能の問題も回避されます。 この問題は、.NET 4.5 で修正されました。

### <a name="75-poco-entities-and-change-tracking-proxies"></a>7.5 POCO エンティティと変更追跡プロキシ

Entity Framework を使用すると、データクラス自体を変更することなく、カスタムデータクラスをデータモデルと共に使用できます。 つまり、既存のドメイン オブジェクトなどの POCO ("plain-old" CLR object) をデータ モデルで使用できます。 これらの POCO データクラス (永続化非依存オブジェクトとも呼ばれます) は、データモデルで定義されているエンティティにマップされ、Entity Data Model ツールによって生成されるエンティティ型と同じクエリ、挿入、更新、および削除の動作のほとんどをサポートします。

また Entity Framework は、POCO 型から派生したプロキシクラスを作成することもできます。これは、POCO エンティティに対する遅延読み込みや自動変更追跡などの機能を有効にする場合に使用されます。 Entity Framework がプロキシを使用できるようにするには、「」の説明に従って、POCO クラスが特定の要件を満たしている必要があり [http://msdn.microsoft.com/library/dd468057.aspx](https://msdn.microsoft.com/library/dd468057.aspx) ます。

エンティティのいずれかのプロパティの値が変更されるたびに、追跡プロキシがオブジェクト状態マネージャーに通知します。そのため、Entity Framework エンティティの実際の状態が常に認識されます。 これを行うには、プロパティの setter メソッドの本体に通知イベントを追加し、オブジェクト状態マネージャーでそのようなイベントを処理します。 プロキシエンティティの作成は、通常、Entity Framework によって作成されたイベントのセットによって、プロキシ以外の POCO エンティティを作成するよりもコストが高くなることに注意してください。

POCO エンティティに変更追跡プロキシが設定されていない場合、エンティティのコンテンツと前回保存された状態のコピーとを比較することで、変更が検出されます。 コンテキスト内に多数のエンティティがある場合、またはエンティティのプロパティの量が非常に多い場合、最後の比較が行われてから変更されていない場合でも、この詳細な比較は時間がかかるプロセスになります。

まとめ: 変更追跡プロキシの作成時にパフォーマンスに影響を与えますが、変更の追跡機能を使用すると、エンティティに多数のプロパティがある場合、またはモデルに多数のエンティティがある場合に、変更の検出プロセスを高速化できます。 エンティティの量があまり大きくならない、少数のプロパティを持つエンティティの場合は、変更追跡プロキシを使用した方がメリットがない可能性があります。

## <a name="8-loading-related-entities"></a>8関連エンティティの読み込み

### <a name="81-lazy-loading-vs-eager-loading"></a>8.1 遅延読み込みと一括読み込み

Entity Framework には、ターゲットエンティティに関連するエンティティを読み込むためのさまざまな方法が用意されています。 たとえば、製品のクエリを実行すると、関連する注文がオブジェクト状態マネージャーに読み込まれるさまざまな方法があります。 パフォーマンスの観点から、関連エンティティの読み込み時に考慮する最大の問題は、遅延読み込みと一括読み込みのどちらを使用するかということです。

一括読み込みを使用する場合、関連エンティティはターゲットエンティティセットと共に読み込まれます。 クエリで Include ステートメントを使用して、どの関連エンティティを取り込むかを指定します。

遅延読み込みを使用する場合、最初のクエリではターゲットエンティティセットのみが取り込まれます。 ただし、ナビゲーションプロパティにアクセスするたびに、関連エンティティを読み込むために、ストアに対して別のクエリが発行されます。

エンティティが読み込まれると、そのエンティティに対するその他のクエリは、遅延読み込みと一括読み込みのどちらを使用しているかにかかわらず、オブジェクト状態マネージャーから直接読み込まれます。

### <a name="82-how-to-choose-between-lazy-loading-and-eager-loading"></a>8.2 遅延読み込みと一括読み込みを選択する方法

重要なのは、アプリケーションに適切な選択を行うことができるように、遅延読み込みと一括読み込みの違いを理解することです。 これは、データベースに対する複数の要求と、大きなペイロードを含む可能性のある単一の要求との間のトレードオフを評価するのに役立ちます。 アプリケーションの一部で一括読み込みを使用し、他の部分では遅延読み込みを使用することが適切な場合があります。

内部で起こっていることの例として、英国に住んでいる顧客とその注文数についてクエリを実行するとします。

**一括読み込みの使用**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var ukCustomers = context.Customers.Include(c => c.Orders).Where(c => c.Address.Country == "UK");
    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

**遅延読み込みの使用**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    context.ContextOptions.LazyLoadingEnabled = true;

    //Notice that the Include method call is missing in the query
    var ukCustomers = context.Customers.Where(c => c.Address.Country == "UK");

    var chosenCustomer = AskUserToPickCustomer(ukCustomers);
    Console.WriteLine("Customer Id: {0} has {1} orders", customer.CustomerID, customer.Orders.Count);
}
```

一括読み込みを使用する場合は、すべての顧客とすべての注文を返す単一のクエリを発行します。 ストアコマンドは次のようになります。

``` SQL
SELECT
[Project1].[C1] AS [C1],
[Project1].[CustomerID] AS [CustomerID],
[Project1].[CompanyName] AS [CompanyName],
[Project1].[ContactName] AS [ContactName],
[Project1].[ContactTitle] AS [ContactTitle],
[Project1].[Address] AS [Address],
[Project1].[City] AS [City],
[Project1].[Region] AS [Region],
[Project1].[PostalCode] AS [PostalCode],
[Project1].[Country] AS [Country],
[Project1].[Phone] AS [Phone],
[Project1].[Fax] AS [Fax],
[Project1].[C2] AS [C2],
[Project1].[OrderID] AS [OrderID],
[Project1].[CustomerID1] AS [CustomerID1],
[Project1].[EmployeeID] AS [EmployeeID],
[Project1].[OrderDate] AS [OrderDate],
[Project1].[RequiredDate] AS [RequiredDate],
[Project1].[ShippedDate] AS [ShippedDate],
[Project1].[ShipVia] AS [ShipVia],
[Project1].[Freight] AS [Freight],
[Project1].[ShipName] AS [ShipName],
[Project1].[ShipAddress] AS [ShipAddress],
[Project1].[ShipCity] AS [ShipCity],
[Project1].[ShipRegion] AS [ShipRegion],
[Project1].[ShipPostalCode] AS [ShipPostalCode],
[Project1].[ShipCountry] AS [ShipCountry]
FROM ( SELECT
      [Extent1].[CustomerID] AS [CustomerID],
       [Extent1].[CompanyName] AS [CompanyName],
       [Extent1].[ContactName] AS [ContactName],
       [Extent1].[ContactTitle] AS [ContactTitle],
       [Extent1].[Address] AS [Address],
       [Extent1].[City] AS [City],
       [Extent1].[Region] AS [Region],
       [Extent1].[PostalCode] AS [PostalCode],
       [Extent1].[Country] AS [Country],
       [Extent1].[Phone] AS [Phone],
       [Extent1].[Fax] AS [Fax],
      1 AS [C1],
       [Extent2].[OrderID] AS [OrderID],
       [Extent2].[CustomerID] AS [CustomerID1],
       [Extent2].[EmployeeID] AS [EmployeeID],
       [Extent2].[OrderDate] AS [OrderDate],
       [Extent2].[RequiredDate] AS [RequiredDate],
       [Extent2].[ShippedDate] AS [ShippedDate],
       [Extent2].[ShipVia] AS [ShipVia],
       [Extent2].[Freight] AS [Freight],
       [Extent2].[ShipName] AS [ShipName],
       [Extent2].[ShipAddress] AS [ShipAddress],
       [Extent2].[ShipCity] AS [ShipCity],
       [Extent2].[ShipRegion] AS [ShipRegion],
       [Extent2].[ShipPostalCode] AS [ShipPostalCode],
       [Extent2].[ShipCountry] AS [ShipCountry],
      CASE WHEN ([Extent2].[OrderID] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C2]
      FROM  [dbo].[Customers] AS [Extent1]
      LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CustomerID] = [Extent2].[CustomerID]
      WHERE N'UK' = [Extent1].[Country]
)  AS [Project1]
ORDER BY [Project1].[CustomerID] ASC, [Project1].[C2] ASC
```

遅延読み込みを使用する場合は、最初に次のクエリを発行します。

``` SQL
SELECT
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[CompanyName] AS [CompanyName],
[Extent1].[ContactName] AS [ContactName],
[Extent1].[ContactTitle] AS [ContactTitle],
[Extent1].[Address] AS [Address],
[Extent1].[City] AS [City],
[Extent1].[Region] AS [Region],
[Extent1].[PostalCode] AS [PostalCode],
[Extent1].[Country] AS [Country],
[Extent1].[Phone] AS [Phone],
[Extent1].[Fax] AS [Fax]
FROM [dbo].[Customers] AS [Extent1]
WHERE N'UK' = [Extent1].[Country]
```

顧客の Orders ナビゲーションプロパティにアクセスするたびに、次のような別のクエリがストアに対して発行されます。

``` SQL
exec sp_executesql N'SELECT
[Extent1].[OrderID] AS [OrderID],
[Extent1].[CustomerID] AS [CustomerID],
[Extent1].[EmployeeID] AS [EmployeeID],
[Extent1].[OrderDate] AS [OrderDate],
[Extent1].[RequiredDate] AS [RequiredDate],
[Extent1].[ShippedDate] AS [ShippedDate],
[Extent1].[ShipVia] AS [ShipVia],
[Extent1].[Freight] AS [Freight],
[Extent1].[ShipName] AS [ShipName],
[Extent1].[ShipAddress] AS [ShipAddress],
[Extent1].[ShipCity] AS [ShipCity],
[Extent1].[ShipRegion] AS [ShipRegion],
[Extent1].[ShipPostalCode] AS [ShipPostalCode],
[Extent1].[ShipCountry] AS [ShipCountry]
FROM [dbo].[Orders] AS [Extent1]
WHERE [Extent1].[CustomerID] = @EntityKeyValue1',N'@EntityKeyValue1 nchar(5)',@EntityKeyValue1=N'AROUT'
```

詳細については、「 [関連オブジェクトの読み込み](https://msdn.microsoft.com/library/bb896272.aspx)」を参照してください。

#### <a name="821-lazy-loading-versus-eager-loading-cheat-sheet"></a>8.2.1 の遅延読み込みと一括読み込みのカンニングペーパー

一括読み込みと遅延読み込みのどちらを選択した場合でも、そのようなことはありません。 最初に両方の戦略の違いを理解して、十分な情報に基づいた意思決定を行うことができるようにします。また、コードが次のいずれかのシナリオに適合するかどうかを検討してください。

| シナリオ                                                                    | 提案                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
|:----------------------------------------------------------------------------|:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| フェッチされたエンティティから多数のナビゲーションプロパティにアクセスする必要がありますか。 | **いいえ** -両方のオプションが実行されます。 ただし、クエリによって読み込まれるペイロードが大きすぎる場合は、一括読み込みを使用すると、オブジェクトを具体化するためのネットワークラウンドトリップが少なくなるため、パフォーマンスが向上する可能性があります。 <br/> <br/> **はい** -エンティティから多数のナビゲーションプロパティにアクセスする必要がある場合は、一括読み込みを使用してクエリで複数の include ステートメントを使用します。 追加するエンティティが多いほど、クエリが返すペイロードが大きくなります。 クエリに3つ以上のエンティティを含める場合は、遅延読み込みに切り替えることを検討してください。 |
| 実行時にどのようなデータが必要になるかを正確に把握していますか。                   | 遅延読み込みは適切ではあり**ません**。 そうしないと、不要なデータのクエリを終了する可能性があります。 <br/> <br/> **はい** -一括読み込みが最適な方法です。これにより、セット全体を高速に読み込むことができます。 クエリで膨大な量のデータをフェッチする必要があり、それが遅すぎる場合は、代わりに遅延読み込みを試してください。                                                                                                                                                                                                                                                       |
| コードはデータベースから遠く実行されていますか? (ネットワーク待機時間の増加)  | **いいえ** -ネットワーク待機時間が問題にならない場合、遅延読み込みを使用するとコードが簡略化される可能性があります。 アプリケーションのトポロジが変更される可能性があることに注意してください。そのため、データベースの距離を許可しないようにしてください。 <br/> <br/> **はい** -ネットワークが問題になった場合は、お客様のシナリオに適したものを決定できます。 通常、一括読み込みは、必要なラウンドトリップが少なくなるため、より適切になります。                                                                                                                                                                                                      |


#### <a name="822-performance-concerns-with-multiple-includes"></a>複数のインクルードに関する8.2.2 のパフォーマンスの問題

サーバーの応答時間の問題に関連するパフォーマンスの質問がある場合、問題の原因は複数の Include ステートメントを使用したクエリであることがよくあります。 クエリ内に関連エンティティを含めることは強力ですが、内部で何が起こっているのかを理解することが重要です。

内部プランコンパイラを通じてストアコマンドを生成するために、複数の Include ステートメントが含まれているクエリでは、比較的長い時間がかかります。 この時間の大半は、結果として得られるクエリの最適化に費やされます。 生成されたストアコマンドには、マッピングに応じて、各インクルードの外部結合または共用体が含まれます。 このようなクエリでは、1つのペイロードでデータベースから大規模に接続されたグラフが表示されます。これにより、特にペイロードに多くの冗長性がある場合 (たとえば、複数のレベルのインクルードを使用して一対多の方向でアソシエーションを走査する場合など) に、帯域幅の問題が acerbate ます。

クエリの基になる TSQL にアクセスすることによってクエリが非常に大きなペイロードを返すケースを確認するには、ToTraceString を使用し、SQL Server Management Studio でストアコマンドを実行して、ペイロードサイズを確認します。 このような場合は、必要なデータを取り込むために、クエリ内の Include ステートメントの数を減らすことができます。 または、クエリを次のように、より小さなサブクエリのシーケンスに分割することもできます。

**クエリを中断する前に、次のようにします。**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var customers = from c in context.Customers.Include(c => c.Orders)
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

**クエリを中断した後、次のようになります。**

``` csharp
using (NorthwindEntities context = new NorthwindEntities())
{
    var orders = from o in context.Orders
                 where o.Customer.LastName.StartsWith(lastNameParameter)
                 select o;

    orders.Load();

    var customers = from c in context.Customers
                    where c.LastName.StartsWith(lastNameParameter)
                    select c;

    foreach (Customer customer in customers)
    {
        ...
    }
}
```

これは、コンテキストが id 解決とアソシエーションの修正を自動的に実行するために必要な機能を使用しているため、追跡対象のクエリでのみ機能します。

遅延読み込みと同様に、より小さなペイロードに対するクエリが増えることになります。 個々のプロパティのプロジェクションを使用して、各エンティティから必要なデータのみを明示的に選択することもできますが、この場合、エンティティは読み込まれません。更新はサポートされません。

#### <a name="823-workaround-to-get-lazy-loading-of-properties"></a>8.2.3 プロパティの遅延読み込みを取得するための回避策

Entity Framework は、スカラープロパティまたは複合プロパティの遅延読み込みを現在サポートしていません。 ただし、BLOB などのラージオブジェクトを含むテーブルがある場合は、テーブル分割を使用して、大きなプロパティを別のエンティティに分けることができます。 たとえば、varbinary photo 列を含む Product テーブルがあるとします。 クエリでこのプロパティに頻繁にアクセスする必要がない場合は、テーブル分割を使用して、通常必要なエンティティの部分だけを取り込むことができます。 製品の写真を表すエンティティは、明示的に必要なときにのみ読み込まれます。

テーブル分割を有効にする方法を示す適切なリソースは、Gil Fink の「Entity Framework でのテーブル分割」のブログ記事「」に記載されて \<http://blogs.microsoft.co.il/blogs/gilf/archive/2009/10/13/table-splitting-in-entity-framework.aspx> います。

## <a name="9-other-considerations"></a>9その他の考慮事項

### <a name="91-server-garbage-collection"></a>9.1 サーバーのガベージコレクション

ユーザーによっては、ガベージコレクターが適切に構成されていないときに必要な並列処理を制限するリソースの競合が発生することがあります。 マルチスレッドのシナリオで EF を使用する場合、またはサーバー側のシステムに似たアプリケーションで EF を使用する場合は、必ずサーバーのガベージコレクションを有効にしてください。 これは、アプリケーション構成ファイルの単純な設定を使用して行います。

``` xml
<?xmlversion="1.0" encoding="utf-8" ?>
<configuration>
        <runtime>
               <gcServer enabled="true" />
        </runtime>
</configuration>
```

これにより、スレッドの競合を減らし、CPU の飽和状態のシナリオで最大30% のスループットを向上させることができます。 一般的に、アプリケーションがどのように動作するかは、常に、クラシックガベージコレクション (UI とクライアント側のシナリオに合わせて調整されます) とサーバーのガベージコレクションを使用してテストする必要があります。

### <a name="92-autodetectchanges"></a>9.2 自動検出の変更

既に説明したように、オブジェクトキャッシュに多数のエンティティがある場合、Entity Framework によってパフォーマンスの問題が発生する可能性があります。 Add、Remove、Find、Entry、SaveChanges などの特定の操作では、オブジェクトキャッシュのサイズに基づいて大量の CPU を消費する可能性がある、検出された変更への呼び出しをトリガーします。 その理由は、オブジェクトキャッシュとオブジェクト状態マネージャーは、コンテキストに対して実行される各操作で可能な限り同期を維持しようとし、生成されたデータがさまざまなシナリオで適切であることが保証されるためです。

一般に、アプリケーションの有効期間全体に対して、Entity Framework の自動変更検出を有効にしておくことをお勧めします。 CPU の使用率が高いためにシナリオが低下しており、その原因が検出された変更への呼び出しであることがプロファイルに示されている場合は、コードの重要な部分で Auto検出の変更を一時的に無効にすることを検討してください。

``` csharp
try
{
    context.Configuration.AutoDetectChangesEnabled = false;
    var product = context.Products.Find(productId);
    ...
}
finally
{
    context.Configuration.AutoDetectChangesEnabled = true;
}
```

Auto検出の変更をオフにする前に、エンティティに対して行われた変更に関する特定の情報を追跡する機能が Entity Framework によって失われる可能性があることを理解しておくことをお勧めします。 正しく処理されないと、アプリケーションのデータの不整合が発生する可能性があります。 自動検出の変更を無効にする方法の詳細については、「」を参照 \<http://blog.oneunicorn.com/2012/03/12/secrets-of-detectchanges-part-3-switching-off-automatic-detectchanges/> してください。

### <a name="93-context-per-request"></a>9.3 要求ごとのコンテキスト

Entity Framework のコンテキストは、最適なパフォーマンスエクスペリエンスを提供するために、有効期間の短いインスタンスとして使用することを意図しています。 コンテキストは、存続期間が短く、破棄されると想定されます。そのため、非常に軽量でメタデータを可能な限り再利用するように実装されています。 Web シナリオでは、このことを念頭に置いて、1つの要求の期間を超えてコンテキストを保持しないことが重要です。 同様に、web 以外のシナリオでは、Entity Framework でのさまざまなキャッシュレベルの理解に基づいてコンテキストを破棄する必要があります。 一般に、アプリケーションの有効期間全体にわたってコンテキストインスタンスが存在しないようにする必要があります。また、スレッドごとのコンテキストと静的コンテキストについても考慮する必要があります。

### <a name="94-database-null-semantics"></a>9.4 データベースの null セマンティクス

Entity Framework 既定では、C null 比較セマンティクスを持つ SQL コードが生成され \# ます。 次のようなクエリがあるとします。

``` csharp
            int? categoryId = 7;
            int? supplierId = 8;
            decimal? unitPrice = 0;
            short? unitsInStock = 100;
            short? unitsOnOrder = 20;
            short? reorderLevel = null;

            var q = from p incontext.Products
                    wherep.Category.CategoryName == "Beverages"
                          || (p.CategoryID == categoryId
                                || p.SupplierID == supplierId
                                || p.UnitPrice == unitPrice
                                || p.UnitsInStock == unitsInStock
                                || p.UnitsOnOrder == unitsOnOrder
                                || p.ReorderLevel == reorderLevel)
                    select p;

            var r = q.ToList();
```

この例では、"仕入先" や "UnitPrice" など、エンティティの null 許容型の変数と null 値を許容する変数を比較しています。 このクエリに対して生成された SQL は、パラメーター値が列の値と同じかどうか、またはパラメーターと列の両方の値が null であるかどうかを確認します。 これにより、データベースサーバーが null を処理する方法が隠蔽され、さまざまなデータベースベンダーに対して一貫した C null エクスペリエンスが提供され \# ます。 一方、生成されるコードは少し複雑で、クエリの where ステートメント内の比較の量が大きくなると、適切に動作しない可能性があります。

この状況に対処する方法の1つは、データベースの null セマンティクスを使用することです。 これに \# より、データベースエンジンが null 値を処理する方法を公開するより単純な SQL が生成されるように Entity Framework なったため、C の null セマンティクスと動作が異なる可能性があることに注意してください。 データベースの null セマンティクスは、コンテキスト構成に対して1つの構成行を使用して、コンテキストごとにアクティブにすることができます。

``` csharp
                context.Configuration.UseDatabaseNullSemantics = true;
```

小規模から中規模のクエリでは、データベースの null セマンティクスを使用しても、出ることのパフォーマンスが向上することはありませんが、大きな null 比較が多数あるクエリでは、この違いがより顕著になります。

上記のクエリの例では、制御された環境で実行されているマイクロベンチマークでパフォーマンスの差が2% 未満でした。

### <a name="95-async"></a>9.5 非同期

Entity Framework 6 では、.NET 4.5 以降で実行する場合の非同期操作のサポートが導入されました。 ほとんどの場合、IO に関連する競合が発生するアプリケーションでは、非同期クエリ操作と保存操作の使用が最も効果的です。 アプリケーションで IO の競合が発生しない場合は、非同期の使用によって同期的に実行され、同期呼び出しと同じ時間で結果が返されます。最悪の場合は、実行を非同期タスクに延期し、シナリオの完了に時間を追加するだけで済みます。

非同期プログラミングのしくみについて説明します。これは、非同期のアプリケーションのパフォーマンスが向上するかどうかを判断するのに役立ち [http://msdn.microsoft.com/library/hh191443.aspx](https://msdn.microsoft.com/library/hh191443.aspx) ます。 Entity Framework での非同期操作の使用の詳細については、「 [Async Query And Save](xref:ef6/fundamentals/async
)」を参照してください。

### <a name="96-ngen"></a>9.6 NGEN

Entity Framework 6 は、.NET Framework の既定のインストールには付属していません。 そのため、Entity Framework のアセンブリは既定では NGEN ではありません。つまり、すべての Entity Framework コードは、他の MSIL アセンブリと同じ JIT'ing コストの影響を受けます。 これにより、開発中に F5 キーを押しながら、運用環境でアプリケーションのコールド起動を行うことができます。 JIT'ing の CPU とメモリのコストを削減するために、必要に応じて Entity Framework のイメージを NGEN することをお勧めします。 NGEN を使用して Entity Framework 6 の起動パフォーマンスを向上させる方法の詳細については、「 [ngen を使用した起動時のパフォーマンスの向上](xref:ef6/fundamentals/performance/ngen)」を参照してください。

### <a name="97-code-first-versus-edmx"></a>9.7 Code First と EDMX の比較

概念モデル (オブジェクト)、ストレージスキーマ (データベース)、およびその2つの間のマッピングをメモリ内で表現することによって、オブジェクト指向プログラミングとリレーショナルデータベース間のインピーダンス不一致の問題について Entity Framework します。 このメタデータは、Entity Data Model、または短期の EDM と呼ばれます。 この EDM からは、Entity Framework によって、メモリ内のオブジェクトからデータベースおよびデータベースへのラウンドトリップデータへのビューが導き出されます。

概念モデル、ストレージスキーマ、およびマッピングを正式に指定する EDMX ファイルと共に Entity Framework を使用する場合、モデルの読み込み段階では、EDM が正しいことを検証するだけで済みます (たとえば、マッピングがないことを確認します)。次にビューを生成し、ビューを検証して、このメタデータを使用できるようにします。 その後、クエリを実行したり、新しいデータをデータストアに保存したりできます。

Code First アプローチは、高度な Entity Data Model ジェネレーターです。 Entity Framework は、指定されたコードから EDM を生成する必要があります。そのためには、モデルに関連するクラスを分析し、規則を適用し、Fluent API を使用してモデルを構成します。 EDM がビルドされると、Entity Framework、プロジェクト内に EDMX ファイルが存在するのと同じように動作します。 したがって、Code First からモデルを構築すると、EDMX を使用する場合と比較した場合に、Entity Framework の起動時間が長くなります。 コストは、構築されるモデルのサイズと複雑さに完全に依存しています。

EDMX と Code First の使用を選択する場合は、Code First によって導入された柔軟性によって、モデルを初めて構築するコストが高くなることを理解しておくことが重要です。 アプリケーションがこの初回読み込みのコストに耐えられる場合は、通常、Code First をお勧めします。

## <a name="10-investigating-performance"></a>10パフォーマンスの調査

### <a name="101-using-the-visual-studio-profiler"></a>10.1 Visual Studio Profiler の使用

Entity Framework にパフォーマンス上の問題が発生している場合は、Visual Studio に組み込まれているもののようなプロファイラーを使用して、アプリケーションが時間を費やしている場所を確認できます。 これは、"ADO.NET Entity Framework のパフォーマンスを調査する (パート 1)」ブログの投稿 () で円グラフを生成するために使用したツールです。これにより、 \<https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1> Entity Framework がコールドクエリとウォームクエリの時間を費やす場所が示されます。

「Visual Studio 2010 Profiler を使用したプロファイル Entity Framework」では、データとモデリングの顧客アドバイザリチームによって作成された、実際の例を示しています。この記事では、プロファイラーを使用してパフォーマンスの問題を調査する方法について説明し   \<https://docs.microsoft.com/archive/blogs/dmcat/profiling-entity-framework-using-the-visual-studio-2010-profiler> ます。 この投稿は windows アプリケーション用に作成されました。 Web アプリケーションをプロファイリングする必要がある場合は、Windows パフォーマンスレコーダー (WPR) ツールと Windows Performance Analyzer (WPA) ツールが Visual Studio からの作業よりも適切に機能する可能性があります。 WPR と WPA は、windows アセスメント & amp; デプロイメントキット () に含まれている Windows パフォーマンスツールキットに含まれてい [http://www.microsoft.com/download/details.aspx?id=39982](https://www.microsoft.com/download/details.aspx?id=39982) ます。

### <a name="102-applicationdatabase-profiling"></a>10.2 アプリケーション/データベースプロファイリング

Visual Studio に組み込まれているプロファイラーなどのツールによって、アプリケーションの使用時間がわかります。また、必要に応じて運用中または運用前のアプリケーションの動的分析を実行し、データベースアクセスの一般的な落とし穴やアンチパターンを検索する、別の種類のプロファイラーを使用できます。

Entity Framework Profiler ( \<http://efprof.com> ) と ORMProfiler () という2つの使用可能なプロファイラーがあり \<http://ormprofiler.com> ます。

アプリケーションが Code First を使用する MVC アプリケーションの場合は、StackExchange の MiniProfiler を使用できます。 Scott マン Selman は、のブログでこのツールについて説明し \<http://www.hanselman.com/blog/NuGetPackageOfTheWeek9ASPNETMiniProfilerFromStackExchangeRocksYourWorld.aspx> ます。

アプリケーションのデータベースアクティビティのプロファイリングの詳細については、「 [Entity Framework でのデータベースアクティビティのプロファイリング」と](https://msdn.microsoft.com/magazine/gg490349.aspx)いうジュリー LERMAN の MSDN マガジンの記事を参照してください。

### <a name="103-database-logger"></a>10.3 データベースロガー

Entity Framework 6 を使用している場合は、組み込みのログ記録機能の使用も検討してください。 コンテキストのデータベースプロパティは、単純な1行構成を使用してアクティビティをログに記録するように指示できます。

``` csharp
    using (var context = newQueryComparison.DbC.NorthwindEntities())
    {
        context.Database.Log = Console.WriteLine;
        var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
        q.ToList();
    }
```

この例では、データベースアクティビティはコンソールにログ記録されますが、ログプロパティは、任意のアクション文字列デリゲートを呼び出すように構成でき &lt; &gt; ます。

再コンパイルせずにデータベースのログ記録を有効にし、Entity Framework 6.1 以降を使用している場合は、アプリケーションの web.config または app.config ファイルにインターセプターを追加します。

``` xml
  <interceptors>
    <interceptor type="System.Data.Entity.Infrastructure.Interception.DatabaseLogger, EntityFramework">
      <parameters>
        <parameter value="C:\Path\To\My\LogOutput.txt"/>
      </parameters>
    </interceptor>
  </interceptors>
```

再コンパイルせずにログを追加する方法の詳細については、「」を参照 \<http://blog.oneunicorn.com/2014/02/09/ef-6-1-turning-on-logging-without-recompiling/> してください。

## <a name="11-appendix"></a>11付録

### <a name="111-a-test-environment"></a>11.1 A. テスト環境

この環境では、2コンピューターのセットアップを、クライアントアプリケーションとは別のコンピューター上のデータベースと共に使用します。 マシンは同じラックに存在するため、ネットワーク待機時間は比較的低く、単一コンピューター環境よりも現実的です。

#### <a name="1111-app-server"></a>11.1.1 アプリサーバー

##### <a name="11111-software-environment"></a>11.1.1.1 ソフトウェア環境

-   Entity Framework 4 ソフトウェア環境
    -   OS 名: Windows Server 2008 R2 Enterprise SP1。
    -   Visual Studio 2010 – Ultimate。
    -   Visual Studio 2010 SP1 (一部の比較でのみ)。
-   Entity Framework 5 および6ソフトウェア環境
    -   OS 名: Windows 8.1 Enterprise
    -   Visual Studio 2013 – Ultimate。

##### <a name="11112-hardware-environment"></a>11.1.1.2 ハードウェア環境

-   デュアルプロセッサ: Intel (R) Xeon (R) CPU L5520 W3530 @ 2.27 GHz、2261 Mhz8 GHz、4コア (s)、84論理プロセッサ。
-   2412 GB RamRAM。
-   136 GB SCSI250GB SATA 7200 rpm GB/s ドライブを4つのパーティションに分割します。

#### <a name="1112-db-server"></a>11.1.2 DB サーバー

##### <a name="11121-software-environment"></a>11.1.2.1 ソフトウェア環境

-   OS 名: Windows Server 2008 R 28.1 Enterprise SP1。
-   SQL Server 2008 R22012。

##### <a name="11122-hardware-environment"></a>11.1.2.2 ハードウェア環境

-   シングルプロセッサ: Intel (R) Xeon (R) CPU L5520 @ 2.27 GHz、2261 MhzES-1620 0 @ 3.60 GHz、4コア (s)、8個の論理プロセッサ。
-   824 GB RamRAM。
-   465 GB ATA500GB SATA 7200 rpm 6 GB/s ドライブを4つのパーティションに分割します。

### <a name="112-b-query-performance-comparison-tests"></a>11.2 b. クエリパフォーマンス比較テスト

Northwind モデルは、これらのテストを実行するために使用されました。 これは、Entity Framework デザイナーを使用してデータベースから生成されたものです。 次に、クエリ実行オプションのパフォーマンスを比較するために、次のコードを使用しました。

``` csharp
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Data.Entity.Infrastructure;
using System.Data.EntityClient;
using System.Data.Objects;
using System.Linq;

namespace QueryComparison
{
    public partial class NorthwindEntities : ObjectContext
    {
        private static readonly Func<NorthwindEntities, string, IQueryable<Product>> productsForCategoryCQ = CompiledQuery.Compile(
            (NorthwindEntities context, string categoryName) =>
                context.Products.Where(p => p.Category.CategoryName == categoryName)
                );

        public IQueryable<Product> InvokeProductsForCategoryCQ(string categoryName)
        {
            return productsForCategoryCQ(this, categoryName);
        }
    }

    public class QueryTypePerfComparison
    {
        private static string entityConnectionStr = @"metadata=res://*/Northwind.csdl|res://*/Northwind.ssdl|res://*/Northwind.msl;provider=System.Data.SqlClient;provider connection string='data source=.;initial catalog=Northwind;integrated security=True;multipleactiveresultsets=True;App=EntityFramework'";

        public void LINQIncludingContextCreation()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTracking()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                context.Products.MergeOption = MergeOption.NoTracking;

                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void CompiledQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                var q = context.InvokeProductsForCategoryCQ("Beverages");
                q.ToList();
            }
        }

        public void ObjectQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectQuery<Product> products = context.Products.Where("it.Category.CategoryName = 'Beverages'");
                products.ToList();
            }
        }

        public void EntityCommand()
        {
            using (EntityConnection eConn = new EntityConnection(entityConnectionStr))
            {
                eConn.Open();
                EntityCommand cmd = eConn.CreateCommand();
                cmd.CommandText = "Select p From NorthwindEntities.Products As p Where p.Category.CategoryName = 'Beverages'";

                using (EntityDataReader reader = cmd.ExecuteReader(CommandBehavior.SequentialAccess))
                {
                    List<Product> productsList = new List<Product>();
                    while (reader.Read())
                    {
                        DbDataRecord record = (DbDataRecord)reader.GetValue(0);

                        // 'materialize' the product by accessing each field and value. Because we are materializing products, we won't have any nested data readers or records.
                        int fieldCount = record.FieldCount;

                        // Treat all products as Product, even if they are the subtype DiscontinuedProduct.
                        Product product = new Product();  

                        product.ProductID = record.GetInt32(0);
                        product.ProductName = record.GetString(1);
                        product.SupplierID = record.GetInt32(2);
                        product.CategoryID = record.GetInt32(3);
                        product.QuantityPerUnit = record.GetString(4);
                        product.UnitPrice = record.GetDecimal(5);
                        product.UnitsInStock = record.GetInt16(6);
                        product.UnitsOnOrder = record.GetInt16(7);
                        product.ReorderLevel = record.GetInt16(8);
                        product.Discontinued = record.GetBoolean(9);

                        productsList.Add(product);
                    }
                }
            }
        }

        public void ExecuteStoreQuery()
        {
            using (NorthwindEntities context = new NorthwindEntities())
            {
                ObjectResult<Product> beverages = context.ExecuteStoreQuery<Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Database.SqlQuery\<QueryComparison.DbC.Product>(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void ExecuteStoreQueryDbSet()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var beverages = context.Products.SqlQuery(
@"    SELECT        P.ProductID, P.ProductName, P.SupplierID, P.CategoryID, P.QuantityPerUnit, P.UnitPrice, P.UnitsInStock, P.UnitsOnOrder, P.ReorderLevel, P.Discontinued
    FROM            Products AS P INNER JOIN Categories AS C ON P.CategoryID = C.CategoryID
    WHERE        (C.CategoryName = 'Beverages')"
);
                beverages.ToList();
            }
        }

        public void LINQIncludingContextCreationDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {                 
                var q = context.Products.Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }

        public void LINQNoTrackingDbContext()
        {
            using (var context = new QueryComparison.DbC.NorthwindEntities())
            {
                var q = context.Products.AsNoTracking().Where(p => p.Category.CategoryName == "Beverages");
                q.ToList();
            }
        }
    }
}
```

### <a name="113-c-navision-model"></a>11.3 Navision モデル

Navision データベースは、Microsoft Dynamics – NAV のデモに使用される大規模なデータベースです。 生成された概念モデルには、1005エンティティセットと4227アソシエーションセットが含まれています。 テストで使用されているモデルは "フラット" です。継承は追加されていません。

#### <a name="1131-queries-used-for-navision-tests"></a>Navision テストに使用される11.3.1 クエリ

Navision モデルで使用されるクエリの一覧には、Entity SQL クエリの3つのカテゴリが含まれています。

##### <a name="11311-lookup"></a>11.3.1.1 Lookup

集計のない単純な参照クエリ

-   カウント: 16232
-   例:

``` xml
  <Query complexity="Lookup">
    <CommandText>Select value distinct top(4) e.Idle_Time From NavisionFKContext.Session as e</CommandText>
  </Query>
```

##### <a name="11312singleaggregating"></a>11.3.1.2 SingleAggregating

複数の集計を含む通常の BI クエリですが、小計はありません (単一のクエリ)

-   カウント: 2313
-   例:

``` xml
  <Query complexity="SingleAggregating">
    <CommandText>NavisionFK.MDF_SessionLogin_Time_Max()</CommandText>
  </Query>
```

ここ \_ で、MDF の sessionlogin \_ Time \_ Max () は、モデルでは次のように定義されています。

``` xml
  <Function Name="MDF_SessionLogin_Time_Max" ReturnType="Collection(DateTime)">
    <DefiningExpression>SELECT VALUE Edm.Min(E.Login_Time) FROM NavisionFKContext.Session as E</DefiningExpression>
  </Function>
```

##### <a name="11313aggregatingsubtotals"></a>11.3.1.3 集計の集計

集計と小計を含む BI クエリ (union all 経由)

-   カウント: 178
-   例:

``` xml
  <Query complexity="AggregatingSubtotals">
    <CommandText>
using NavisionFK;
function AmountConsumed(entities Collection([CRONUS_International_Ltd__Zone])) as
(
    Edm.Sum(select value N.Block_Movement FROM entities as E, E.CRONUS_International_Ltd__Bin as N)
)
function AmountConsumed(P1 Edm.Int32) as
(
    AmountConsumed(select value e from NavisionFKContext.CRONUS_International_Ltd__Zone as e where e.Zone_Ranking = P1)
)
----------------------------------------------------------------------------------------------------------------------
(
    select top(10) Zone_Ranking, Cross_Dock_Bin_Zone, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking, E.Cross_Dock_Bin_Zone
)
union all
(
    select top(10) Zone_Ranking, Cast(null as Edm.Byte) as P2, AmountConsumed(GroupPartition(E))
    from NavisionFKContext.CRONUS_International_Ltd__Zone as E
    where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed
    group by E.Zone_Ranking
)
union all
{
    Row(Cast(null as Edm.Int32) as P1, Cast(null as Edm.Byte) as P2, AmountConsumed(select value E
                                                                         from NavisionFKContext.CRONUS_International_Ltd__Zone as E
                                                                         where AmountConsumed(E.Zone_Ranking) > @MinAmountConsumed))
}</CommandText>
    <Parameters>
      <Parameter Name="MinAmountConsumed" DbType="Int32" Value="10000" />
    </Parameters>
  </Query>
```
