---
title: DbContext の使用-EF6
description: Entity Framework 6 での DbContext の使用
author: divega
ms.date: 10/23/2016
uid: ef6/fundamentals/working-with-dbcontext
ms.openlocfilehash: 83f3f318c6cd1b0ea440bd472a651ff4454716f1
ms.sourcegitcommit: abda0872f86eefeca191a9a11bfca976bc14468b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/14/2020
ms.locfileid: "90072149"
---
# <a name="working-with-dbcontext"></a>DbContext の操作

Entity Framework を使用して .NET オブジェクトを使用してデータのクエリ、挿入、更新、および削除を行うには、まず、モデルで定義されているエンティティとリレーションシップをデータベース内のテーブルにマップする [モデルを作成](xref:ef6/modeling/index) する必要があります。

モデルを作成すると、アプリケーションが対話するプライマリクラスは `System.Data.Entity.DbContext` (多くの場合、コンテキストクラスと呼ばれます) になります。 モデルに関連付けられている DbContext を使用して、次のことを行うことができます。
- クエリの作成と実行   
- クエリ結果をエンティティオブジェクトとして具体化する
- これらのオブジェクトに加えられた変更を追跡する
- オブジェクトの変更をデータベースに保存する
- メモリ内のオブジェクトを UI コントロールにバインドする

このページでは、コンテキストクラスを管理する方法に関するガイダンスを示します。  

## <a name="defining-a-dbcontext-derived-class"></a>DbContext 派生クラスの定義  

コンテキストを使用する場合は、DbContext から派生するクラスを定義し、コンテキスト内の指定されたエンティティのコレクションを表す Dbcontext プロパティを公開することをお勧めします。 EF デザイナーを使用している場合は、コンテキストが生成されます。 Code First を使用する場合は、通常、コンテキストを自分で記述します。  

``` csharp
public class ProductContext : DbContext
{
    public DbSet<Category> Categories { get; set; }
    public DbSet<Product> Products { get; set; }
}
```  

コンテキストを取得した後は、これらのプロパティを使用して、コンテキスト内のエンティティを照会、追加 ( `Add` またはメソッドを使用 `Attach` ) または削除 (を使用 `Remove` ) できます。 コンテキストオブジェクトのプロパティへのアクセスは、 `DbSet` 指定された型のすべてのエンティティを返す開始クエリを表します。 プロパティにアクセスするだけではクエリが実行されないことに注意してください。 クエリは次の場合に実行されます。  

- `foreach` (C#) または `For Each` (Visual Basic) ステートメントによって列挙された場合。  
- これは、、、などのコレクション操作によって列挙され `ToArray` `ToDictionary` `ToList` ます。  
- やなどの LINQ `First` 演算子 `Any` は、クエリの最も外側の部分で指定されます。  
- 次のいずれかのメソッドが呼び出されます。 `Load` `DbEntityEntry.Reload`  `Database.ExecuteSqlCommand` `DbSet<T>.Find` 指定したキーを持つエンティティがコンテキストに既に読み込まれていない場合は、拡張メソッド、、、および。  

## <a name="lifetime"></a>有効期間  

コンテキストの有効期間は、インスタンスが作成されると開始され、インスタンスが破棄またはガベージコレクトされるときに終了します。 コンテキストで制御されるすべてのリソースをブロックの最後に破棄する場合は、 **を** 使用します。 **を**使用すると、コンパイラは自動的に try/finally ブロックを作成し、 **finally**ブロックで dispose を呼び出します。  

``` csharp
public void UseProducts()
{
    using (var context = new ProductContext())
    {     
        // Perform data access using the context
    }
}
```  

コンテキストの有効期間を決定するときの一般的なガイドラインを次に示します。  

- Web アプリケーションを操作する場合は、要求ごとにコンテキストインスタンスを使用します。  
- Windows Presentation Foundation (WPF) または Windows フォームを使用する場合は、フォームごとにコンテキストインスタンスを使用します。 これにより、コンテキストによって提供される変更追跡機能を使用できます。  
- コンテキストインスタンスが依存関係挿入コンテナーによって作成されている場合、通常、コンテキストを破棄するのはコンテナーの役割です。
- コンテキストがアプリケーションコードで作成されている場合は、不要になったときにコンテキストを破棄することを忘れないでください。  
- 実行時間の長いコンテキストを使用する場合は、次の点を考慮してください。  
    - オブジェクトとその参照をメモリに読み込むと、コンテキストのメモリ消費量が急速に増加する可能性があります。 これは、パフォーマンスを低下させる原因になります。  
    - コンテキストはスレッドセーフではないため、同時に処理を行う複数のスレッド間で共有することはできません。
    - 例外によってコンテキストが回復不能な状態になると、アプリケーション全体が終了する可能性があります。  
    - データの照会時と更新時の時間差が大きくなると、コンカレンシーに関する問題が生じる可能性が高くなります。  

## <a name="connections"></a>接続  

既定では、コンテキストはデータベースへの接続を管理します。 コンテキストが開き、必要に応じて接続が閉じられます。 たとえば、コンテキストは、クエリを実行するための接続を開き、すべての結果セットが処理されたときに接続を閉じます。  

接続の開閉をより詳細に制御する必要がある場合もあります。 たとえば、SQL Server Compact を使用する場合、パフォーマンスを向上させるために、アプリケーションの有効期間中、データベースに対して開いている接続を個別に維持することをお勧めします。 `Connection` プロパティを使用することにより、手動でこのプロセスを管理できます。  
