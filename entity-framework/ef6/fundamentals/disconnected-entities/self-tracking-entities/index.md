---
title: 自己追跡エンティティ - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 5e60f5be-7bbb-4bf8-835e-0ac808d6c84a
ms.openlocfilehash: 3bb9759d89fbd0c10b911625aa7d0afd7747de14
ms.sourcegitcommit: 9b562663679854c37c05fca13d93e180213fb4aa
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/07/2020
ms.locfileid: "78413357"
---
# <a name="self-tracking-entities"></a>自己追跡エンティティ

> [!IMPORTANT]
> 自己追跡エンティティ テンプレートの使用は現在お勧めしていません。 既存のアプリケーションをサポートするためにのみ引き続き使用できます。 アプリケーションで、エンティティの切断されたグラフを操作する必要がある場合は、代替の方法を検討してください。たとえば、コミュニティによってより積極的に開発された自己追跡エンティティに似たテクノロジである[追跡可能なエンティティ](https://trackableentities.github.io/)を使用するか、または、低レベルの変更追跡 API を使用してカスタム コードを記述してください。

Entity Framework ベースのアプリケーションでは、オブジェクトの変更はコンテキストによって追跡されます。 SaveChanges メソッドを使用して、データベースに変更を確定します。 n 層アプリケーションを使用する場合、エンティティ オブジェクトが通常コンテキストから切り離され、変更を追跡する方法およびそれらの変更をコンテキストにレポートする方法を決定する必要があります。 自己追跡エンティティ (STE) は、任意の層での変更を追跡し、その後これらの変更を保存するコンテキストに再生することができます。  

STE エンティティは、オブジェクト グラフに対する変更が行われる層でコンテキストを利用できない場合にのみ使用します。 コンテキストを使用できる場合、変更の追跡のコンテキストが処理するために、STE を使用する必要はありません。  

このテンプレート項目は、2 つの .tt (テキスト テンプレート) ファイルを生成します。  

- **\<モデル名\>.tt** ファイルは、エンティティ型と、自己追跡エンティティが使用する変更追跡ロジックおよび自己追跡エンティティで状態設定が可能な拡張メソッドを含むヘルパー クラスを生成します。  
- **\<モデル名\>.Context.tt** ファイルは、派生コンテキストと、**ObjectContext** および **ObjectSet** クラスの **ApplyChanges** メソッドを含む拡張クラスを生成します。 これらのメソッドは、自己追跡エンティティのグラフに含まれている変更追跡情報を検証して、データベースに変更内容を保存するために実行しなければならない一連の操作を推論します。  

## <a name="get-started"></a>開始するには  

最初に、「[Self-Tracking Entities Walkthrough](walkthrough.md)」(自己追跡エンティティ チュートリアル) ページを参照してください。  

## <a name="functional-considerations-when-working-with-self-tracking-entities"></a>自己追跡エンティティの使用に関する機能上の考慮事項  
> [!IMPORTANT]
> 自己追跡エンティティ テンプレートの使用は現在お勧めしていません。 既存のアプリケーションをサポートするためにのみ引き続き使用できます。 アプリケーションで、エンティティの切断されたグラフを操作する必要がある場合は、代替の方法を検討してください。たとえば、コミュニティによってより積極的に開発された自己追跡エンティティに似たテクノロジである[追跡可能なエンティティ](https://trackableentities.github.io/)を使用するか、または、低レベルの変更追跡 API を使用してカスタム コードを記述してください。

自己追跡エンティティを使用する際は、次の点に注意してください。  

- エンティティ型を含むアセンブリへの参照がクライアント プロジェクトにあることを確認します。 クライアント プロジェクトにサービス参照のみ追加する場合、クライアント プロジェクトは実際の自己追跡エンティティ型ではなく WCF プロキシ型を使用します。 つまり、クライアントでエンティティの追跡を管理する自動通知機能を取得することはできません。 エンティティ型を意図的に含めない場合は、クライアントで変更追跡情報を手動で設定して、変更内容がサービスに送り返されるようにする必要があります。  
- サービス操作の呼び出しはステートレスで行い、この呼び出しによってオブジェクト コンテキストの新しいインスタンスを作成する必要があります。 また、ブロックを**使用して**オブジェクト コンテキストを作成することをお勧めします。  
- クライアントで変更されたグラフをサービスに送信した後、クライアントで同じグラフを引き続き使用する場合は、グラフを手動で反復処理し、各オブジェクトで **AcceptChanges** メソッドを呼び出して変更トラッカーをリセットする必要があります。  

    > データベースによって生成される値 (たとえば、ID やコンカレンシーの値) を持つプロパティがグラフ内のオブジェクトに含まれている場合、**SaveChanges** メソッドが呼び出された後に、それらのプロパティの値をデータベースによって生成される値に置き換えます。 サービス操作を実装して、保存されたオブジェクトまたはオブジェクト用に生成されたプロパティ値の一覧をクライアントに返すことができます。 その後で、クライアントはオブジェクト インスタンスまたはオブジェクトのプロパティ値を、サービス操作から返されるオブジェクトまたはプロパティ値に置き換える必要があります。  
- 複数のサービス要求からグラフをマージすると、作成されるグラフでオブジェクトのキー値が重複する可能性があります。 **ApplyChanges** メソッドを呼び出す場合、Entity Framework では重複キーを持つオブジェクトを削除せず、代わりに例外がスローされます。 グラフでキー値が重複しないようにするには、ブログの記事「[自己追跡エンティティ: ApplyChanges および重複するエンティティ](https://go.microsoft.com/fwlink/?LinkID=205119&clcid=0x409)」で説明されているいずれかのパターンに従ってください。  
- 外部キーのプロパティを設定してオブジェクト間のリレーションシップを変更すると、参照ナビゲーション プロパティは null に設定され、クライアントの適切なプリンシパル エンティティと同期されません。 グラフがオブジェクト コンテキストにアタッチされた後 (たとえば、**ApplyChanges** メソッドの呼び出し後)、外部キーのプロパティとナビゲーション プロパティが同期されます。  

    > 参照ナビゲーション プロパティが適切なプリンシパル オブジェクトと同期されない場合は、外部キーのリレーションシップで連鎖削除を指定していた場合に問題となる可能性があります。 プリンシパルを削除すると、依存オブジェクトに削除が反映されません。 連鎖削除を指定していた場合は、外部キーのプロパティを設定する代わりに、ナビゲーション プロパティを使用してリレーションシップを変更します。  
- 自己追跡エンティティは遅延読み込みを実行できません。  
- バイナリ シリアル化および ASP.NET 状態管理オブジェクトへのシリアル化は自己追跡エンティティによってサポートされていません。 ただし、バイナリ シリアル化のサポートを追加するようにテンプレートをカスタマイズできます。 詳細については、「[自己追跡エンティティでのバイナリ シリアル化および ViewState の使用](https://go.microsoft.com/fwlink/?LinkId=199208)」を参照してください。  

## <a name="security-considerations"></a>セキュリティに関する考慮事項  

次のセキュリティに関する考慮事項は、自己追跡エンティティを使用する場合に考慮する必要があります。  

- サービスは、信頼されていないクライアントからの、または信頼されていないチャネルを経由した、データの取得または更新の要求を信頼しません。 クライアントは認証されている必要があります。また、セキュリティで保護されたチャネルまたはメッセージ エンベロープを使用する必要があります。 クライアントによるデータの取得または更新の要求は、特定のシナリオに対して予想される正当な変更に準拠することを確認するために検証する必要があります。  
- 機密情報 (社会保障番号など) をエンティティ キーとして使用しないでください。 これにより、完全に信頼されていないクライアントに自己追跡エンティティのグラフ内の機密情報が誤ってシリアル化される可能性が低くなります。 独立した関連付けでは、シリアル化される情報に関連するエンティティの元のキーは、クライアントにも送信される可能性があります。  
- 機密データを含む例外メッセージがクライアント層に反映されないように、サーバー層での **ApplyChanges** および **SaveChanges** の呼び出しを例外処理コードにラップする必要があります。  
